/* eslint-disable */

// These type declarations are only intended for use for Windy plugin development.
declare namespace L {
    // Generated by dts-bundle-generator v9.5.1
    
    // @ts-expect-error
    import * as geojson from 'geojson';
    // @ts-expect-error
    import { mat2, mat4, vec3, vec4 } from 'gl-matrix';
    
    /**
     * A typescript reimplementation of Leaflet's point merged with Mapbox' or MapLibre's Point API, from https://github.com/mapbox/point-geometry/
     *
     * Can be used in place of both.
     *
     * ---
     *
     * Represents a point with `x` and `y` coordinates in pixels.
     *
     * @example
     *
     * ```js
     * var point = L.point(200, 300);
     * ```
     *
     * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
     *
     * ```js
     * map.panBy([200, 300]);
     * map.panBy(L.point(200, 300));
     * ```
     *
     * Note that `Point` does not inherit from Leaflet's `Class` object,
     * which means new classes can't inherit from it, and new methods
     * can't be added to it with the `include` function.
     */
    class Point {
        /**
         * The `x` coordinate of the point.
         */
        x: number;
        /**
         * The `y` coordinate of the point.
         */
        y: number;
        constructor(x: number, y: number, round?: boolean);
        /**
         * Returns a copy of the current point.
         */
        clone(): Point;
        /**
         * Returns the result of addition of the current and the given points, yielding a new point.
         */
        add(point: PointExpression): Point;
        /**
         * @internal
         * Addition that modifies the current point instance.
         *
         * Destructive, used directly for performance in situations where it's safe to modify existing point
         */
        _add(point: Point): this;
        /**
         * Returns the result of subtraction of the given point from the current, yielding a new point.
         * The same as {@link sub}.
         */
        subtract(point: PointExpression): Point;
        /**
         * @internal
         * Subtraction that modifies the current point instance.
         * The same as {@link _sub}.
         */
        _subtract(point: Point): this;
        /**
         * Returns the result of division of the current point by the given number, yielding a new point.
         */
        divideBy(num: number): Point;
        /**
         * @internal
         * Division that modifies the current point instance.
         */
        _divideBy(num: number): Point;
        /**
         * Returns the result of multiplication of the current point by the given number, yielding a new point.
         */
        multiplyBy(num: number): Point;
        /**
         * @internal
         * Multiplication that modifies the current point instance.
         */
        _multiplyBy(num: number): this;
        /**
         * Multiply each coordinate of the current point by each coordinate of
         * `scale`. In linear algebra terms, multiply the point by the
         * [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
         * defined by `scale`.
         */
        scaleBy(point: Point): Point;
        /**
         * Inverse of `scaleBy`. Divide each coordinate of the current point by
         * each coordinate of `scale`.
         */
        unscaleBy(point: Point): Point;
        /**
         * Returns a copy of the current point with rounded coordinates.
         */
        round(): Point;
        /**
         * @internal
         * Rounds this point instance in-place.
         */
        _round(): this;
        /**
         * Returns a copy of the current point with floored coordinates (rounded down).
         */
        floor(): Point;
        /**
         * @internal
         * Applies `Math.floor()` to x and y of this point instance in-place.
         */
        _floor(): this;
        /**
         * Returns a copy of the current point with ceiled coordinates (rounded up).
         */
        ceil(): Point;
        /**
         * @internal
         * Applies `Math.floor()` to x and y of this point instance in-place.
         */
        _ceil(): this;
        /**
         * Returns a copy of the current point with truncated coordinates (rounded towards zero).
         */
        trunc(): Point;
        /**
         * @internal
         * Truncates the coordinates (rounds towards zero) of the current point instance.
         */
        _trunc(): this;
        /**
         * Returns the cartesian distance between the current and the given points.
         */
        distanceTo(point: PointExpression): number;
        /**
         * Returns `true` if the given point-like object has the same coordinates.
         */
        equals(point: PointExpression): boolean;
        /**
         * Returns `true` if both coordinates of the given point-like object are less than the corresponding current point coordinates (in absolute values).
         */
        contains(point: PointExpression): boolean;
        /**
         * Returns a string representation of the point for debugging purposes.
         */
        toString(): string;
        /**
         * Returns the result of subtraction of the given point from the current, yielding a new point.
         * The same as {@link subtract}.
         */
        sub(point: PointExpression): Point;
        /**
         * @internal
         * Subtraction that modifies the current point instance.
         * The same as {@link _subtract}.
         */
        _sub(point: Point): this;
        /**
         * Divide this point's x & y coordinates by point, yielding a new point.
         */
        divByPoint(p: PointExpression): Point;
        _divByPoint(p: Point): this;
        /**
         * Returns the result of division of the current point by the given number, yielding a new point.
         */
        div(num: number): Point;
        /**
         * @internal
         * Division that modifies the current point instance.
         */
        _div(num: number): Point;
        /**
         * Returns the result of multiplication of the current point by the given number, yielding a new point.
         */
        mult(num: number): Point;
        /**
         * Returns the result of multiplication of the current point by the given number.
         */
        _mult(num: number): this;
        /**
         * Multiply this point's x & y coordinates by point, yielding a new point.
         */
        multByPoint(p: PointExpression): Point;
        _multByPoint(p: Point): this;
        /**
         * Rotate this point around the 0, 0 origin by an angle a,
         * given in radians, yielding a new point.
         * @param a - angle to rotate around, in radians
         */
        rotate(a: number): Point;
        /**
         * Rotate this point around p point by an angle a,
         * given in radians, yielding a new point.
         * @param a - angle to rotate around, in radians
         * @param p - Point to rotate around
         */
        rotateAround(a: number, p: Point): Point;
        /**
         * Multiply this point by a 4x1 transformation matrix, yielding a new point.
         * @param m - transformation matrix
         */
        matMult(m: [
            number,
            number,
            number,
            number
        ]): Point;
        /**
         * Calculate this point but as a unit vector from 0, 0, meaning
         * that the distance from the resulting point to the 0, 0
         * coordinate will be equal to 1 and the angle from the resulting
         * point to the 0, 0 coordinate will be the same as before.
         * Yields a new point.
         */
        unit(): Point;
        /**
         * Compute a perpendicular point, where the new y coordinate
         * is the old x coordinate and the new x coordinate is the old y
         * coordinate multiplied by -1.
         * Yields a new point.
         */
        perp(): Point;
        /**
         * Return the magnitude of this point: this is the Euclidean
         * distance from the 0, 0 coordinate to this point's x and y
         * coordinates.
         */
        mag(): number;
        /**
         * Calculate the distance from this point to another point
         * @param p - the other point
         */
        dist(p: Point): number;
        /**
         * Calculate the distance from this point to another point,
         * without the square root step. Useful if you're comparing
         * relative distances.
         * @param p - the other point
         */
        distSqr(p: Point): number;
        /**
         * Get the angle from the 0, 0 coordinate to this point, in radians
         * coordinates.
         */
        angle(): number;
        /**
         * Get the angle from this point to another point, in radians
         * @param b - the other point
         */
        angleTo(b: Point): number;
        /**
         * Get the angle between this point and another point, in radians
         * @param b - the other point
         */
        angleWith(b: Point): number;
        /**
         * Find the angle of the two vectors, solving the formula for
         * the cross product a x b = |a||b|sin(θ) for θ.
         * @param x - the x-coordinate
         * @param y - the y-coordinate
         */
        angleWithSep(x: number, y: number): number;
        _matMult(m: [
            number,
            number,
            number,
            number
        ]): this;
        _unit(): this;
        _perp(): this;
        _rotate(angle: number): this;
        _rotateAround(angle: number, p: Point): this;
        /**
         * Construct a point from an array if necessary, otherwise if the input
         * is already a Point, return it unchanged.
         */
        static convert(p: PointExpression): Point;
    }
    type PointExpression = Point | [
        number,
        number
    ] | number[] | {
        x: number | string;
        y: number | string;
    };
    /**
     * A type used to store the tile's expiration date and cache control definition
     */
    type ExpiryData = {
        cacheControl?: string | null;
        expires?: Date | string | null;
    };
    /**
     * A `RequestParameters` object to be returned from Map.options.transformRequest callbacks.
     * @example
     * ```ts
     * // use transformRequest to modify requests that begin with `http://myHost`
     * transformRequest: function(url, resourceType) {
     *  if (resourceType === 'Source' && url.indexOf('http://myHost') > -1) {
     *    return {
     *      url: url.replace('http', 'https'),
     *      headers: { 'my-custom-header': true },
     *      credentials: 'include'  // Include cookies for cross-origin requests
     *    }
     *   }
     * }
     * ```
     */
    type RequestParameters = {
        /**
         * The URL to be requested.
         */
        url: string;
        /**
         * The headers to be sent with the request.
         */
        headers?: any;
        /**
         * Request method `'GET' | 'POST' | 'PUT'`.
         */
        method?: "GET" | "POST" | "PUT";
        /**
         * Request body.
         */
        body?: string;
        /**
         * Response body type to be returned.
         */
        type?: "string" | "json" | "arrayBuffer" | "image";
        /**
         * `'same-origin'|'include'` Use 'include' to send cookies with cross-origin requests.
         */
        credentials?: "same-origin" | "include";
        /**
         * If `true`, Resource Timing API information will be collected for these transformed requests and returned in a resourceTiming property of relevant data events.
         */
        collectResourceTiming?: boolean;
        /**
         * Parameters supported only by browser fetch API. Property of the Request interface contains the cache mode of the request. It controls how the request will interact with the browser's HTTP cache. (https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)
         */
        cache?: RequestCache;
    };
    /**
     * The response object returned from a successful AJAx request
     */
    type GetResourceResponse<T> = ExpiryData & {
        data: T;
    };
    /**
     * An error thrown when a HTTP request results in an error response.
     */
    class AJAXError extends Error {
        /**
         * The response's HTTP status code.
         */
        status: number;
        /**
         * The response's HTTP status text.
         */
        statusText: string;
        /**
         * The request's URL.
         */
        url: string;
        /**
         * The response's body.
         */
        body: Blob;
        /**
         * @param status - The response's HTTP status code.
         * @param statusText - The response's HTTP status text.
         * @param url - The request's URL.
         * @param body - The response's body.
         */
        constructor(status: number, statusText: string, url: string, body: Blob);
    }
    /**
     * This method type is used to register a protocol handler.
     * Use the abort controller for aborting requests.
     * Return a promise with the relevant resource response.
     */
    type AddProtocolAction = (requestParameters: RequestParameters, abortController: AbortController) => Promise<GetResourceResponse<any>>;
    /**
     * This is a global config object used to store the configuration
     * It is available in the workers as well.
     * Only serializable data should be stored in it.
     */
    type Config = {
        MAX_PARALLEL_IMAGE_REQUESTS: number;
        MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: number;
        MAX_TILE_CACHE_ZOOM_LEVELS: number;
        REGISTERED_PROTOCOLS: {
            [x: string]: AddProtocolAction;
        };
        WORKER_URL: string;
    };
    const config: Config;
    /**
     * A {@link LngLat} object, an array of two numbers representing longitude and latitude,
     * or an object with `lng` and `lat` or `lon` and `lat` properties.
     *
     * @group Geography and Geometry
     *
     * @example
     * ```ts
     * let v1 = new LngLat(-122.420679, 37.772537);
     * let v2 = [-122.420679, 37.772537];
     * let v3 = {lon: -122.420679, lat: 37.772537};
     * ```
     */
    type LngLatLike = LngLat | {
        lng: number;
        lat: number;
    } | {
        lon: number;
        lat: number;
    } | [
        number,
        number
    ];
    /**
     * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.
     * These coordinates are based on the [WGS84 (EPSG:4326) standard](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84).
     *
     * MapLibre GL JS uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match the
     * [GeoJSON specification](https://tools.ietf.org/html/rfc7946).
     *
     * Note that any MapLibre GL JS method that accepts a `LngLat` object as an argument or option
     * can also accept an `Array` of two numbers and will perform an implicit conversion.
     * This flexible type is documented as {@link LngLatLike}.
     *
     * @group Geography and Geometry
     *
     * @example
     * ```ts
     * let ll = new LngLat(-123.9749, 40.7736);
     * ll.lng; // = -123.9749
     * ```
     * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
     * @see [Display a popup](https://maplibre.org/maplibre-gl-js/docs/examples/popup/)
     * @see [Create a timeline animation](https://maplibre.org/maplibre-gl-js/docs/examples/timeline-animation/)
     */
    class LngLat {
        /**
         * Longitude, measured in degrees.
         */
        lng: number;
        /**
         * Latitude, measured in degrees.
         */
        lat: number;
        /**
         * @param lng - Longitude, measured in degrees.
         * @param lat - Latitude, measured in degrees.
         */
        constructor(lng: number, lat: number);
        /**
         * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
         *
         * @returns The wrapped `LngLat` object.
         * @example
         * ```ts
         * let ll = new LngLat(286.0251, 40.7736);
         * let wrapped = ll.wrap();
         * wrapped.lng; // = -73.9749
         * ```
         */
        wrap(): LngLat;
        /**
         * Returns the coordinates represented as an array of two numbers.
         *
         * @returns The coordinates represented as an array of longitude and latitude.
         * @example
         * ```ts
         * let ll = new LngLat(-73.9749, 40.7736);
         * ll.toArray(); // = [-73.9749, 40.7736]
         * ```
         */
        toArray(): [
            number,
            number
        ];
        /**
         * Returns the coordinates represent as a string.
         *
         * @returns The coordinates represented as a string of the format `'LngLat(lng, lat)'`.
         * @example
         * ```ts
         * let ll = new LngLat(-73.9749, 40.7736);
         * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
         * ```
         */
        toString(): string;
        /**
         * Returns the approximate distance between a pair of coordinates in meters
         * Uses the Haversine Formula (from R.W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol. 68, no. 2, 1984, p. 159)
         *
         * @param lngLat - coordinates to compute the distance to
         * @returns Distance in meters between the two coordinates.
         * @example
         * ```ts
         * let new_york = new LngLat(-74.0060, 40.7128);
         * let los_angeles = new LngLat(-118.2437, 34.0522);
         * new_york.distanceTo(los_angeles); // = 3935751.690893987, "true distance" using a non-spherical approximation is ~3966km
         * ```
         */
        distanceTo(lngLat: LngLat): number;
        /**
         * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties
         * to a `LngLat` object.
         *
         * If a `LngLat` object is passed in, the function returns it unchanged.
         *
         * @param input - An array of two numbers or object to convert, or a `LngLat` object to return.
         * @returns A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.
         * @example
         * ```ts
         * let arr = [-73.9749, 40.7736];
         * let ll = LngLat.convert(arr);
         * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
         * ```
         */
        static convert(input: LngLatLike): LngLat;
    }
    interface ILngLat {
        lng: number;
        lat: number;
        wrap(): ILngLat;
        toArray(): [
            number,
            number
        ];
        distanceTo(lngLat: ILngLat): number;
        toString(): string;
    }
    interface IMercatorCoordinate {
        x: number;
        y: number;
        z: number;
        toLngLat(): ILngLat;
        toAltitude(): number;
        meterInMercatorCoordinateUnits(): number;
    }
    interface ICanonicalTileID {
        z: number;
        x: number;
        y: number;
        key: string;
        equals(id: ICanonicalTileID): boolean;
        url(urls: Array<string>, pixelRatio: number, scheme: string | null): string;
        isChildOf(parent: ICanonicalTileID): boolean;
        getTilePoint(coord: IMercatorCoordinate): Point;
        toString(): string;
    }
    /**
     * A `MercatorCoordinate` object represents a projected three dimensional position.
     *
     * `MercatorCoordinate` uses the web mercator projection ([EPSG:3857](https://epsg.io/3857)) with slightly different units:
     *
     * - the size of 1 unit is the width of the projected world instead of the "mercator meter"
     * - the origin of the coordinate space is at the north-west corner instead of the middle
     *
     * For example, `MercatorCoordinate(0, 0, 0)` is the north-west corner of the mercator world and
     * `MercatorCoordinate(1, 1, 0)` is the south-east corner. If you are familiar with
     * [vector tiles](https://github.com/mapbox/vector-tile-spec) it may be helpful to think
     * of the coordinate space as the `0/0/0` tile with an extent of `1`.
     *
     * The `z` dimension of `MercatorCoordinate` is conformal. A cube in the mercator coordinate space would be rendered as a cube.
     *
     * @group Geography and Geometry
     *
     * @example
     * ```ts
     * let nullIsland = new MercatorCoordinate(0.5, 0.5, 0);
     * ```
     * @see [Add a custom style layer](https://maplibre.org/maplibre-gl-js/docs/examples/custom-style-layer/)
     */
    class MercatorCoordinate implements IMercatorCoordinate {
        x: number;
        y: number;
        z: number;
        /**
         * @param x - The x component of the position.
         * @param y - The y component of the position.
         * @param z - The z component of the position.
         */
        constructor(x: number, y: number, z?: number);
        /**
         * Project a `LngLat` to a `MercatorCoordinate`.
         *
         * @param lngLatLike - The location to project.
         * @param altitude - The altitude in meters of the position.
         * @returns The projected mercator coordinate.
         * @example
         * ```ts
         * let coord = MercatorCoordinate.fromLngLat({ lng: 0, lat: 0}, 0);
         * coord; // MercatorCoordinate(0.5, 0.5, 0)
         * ```
         */
        static fromLngLat(lngLatLike: LngLatLike, altitude?: number): MercatorCoordinate;
        /**
         * Returns the `LngLat` for the coordinate.
         *
         * @returns The `LngLat` object.
         * @example
         * ```ts
         * let coord = new MercatorCoordinate(0.5, 0.5, 0);
         * let lngLat = coord.toLngLat(); // LngLat(0, 0)
         * ```
         */
        toLngLat(): LngLat;
        /**
         * Returns the altitude in meters of the coordinate.
         *
         * @returns The altitude in meters.
         * @example
         * ```ts
         * let coord = new MercatorCoordinate(0, 0, 0.02);
         * coord.toAltitude(); // 6914.281956295339
         * ```
         */
        toAltitude(): number;
        /**
         * Returns the distance of 1 meter in `MercatorCoordinate` units at this latitude.
         *
         * For coordinates in real world units using meters, this naturally provides the scale
         * to transform into `MercatorCoordinate`s.
         *
         * @returns Distance of 1 meter in `MercatorCoordinate` units.
         */
        meterInMercatorCoordinateUnits(): number;
    }
    class CanonicalTileID implements ICanonicalTileID {
        z: number;
        x: number;
        y: number;
        key: string;
        constructor(z: number, x: number, y: number);
        equals(id: ICanonicalTileID): boolean;
        url(urls: Array<string>, pixelRatio: number, scheme?: string | null): string;
        isChildOf(parent: ICanonicalTileID): boolean;
        getTilePoint(coord: IMercatorCoordinate): Point;
        toString(): string;
    }
    class UnwrappedTileID {
        wrap: number;
        canonical: CanonicalTileID;
        key: string;
        constructor(wrap: number, canonical: CanonicalTileID);
    }
    /**
     * An overscaled tile identifier
     */
    class OverscaledTileID {
        overscaledZ: number;
        wrap: number;
        canonical: CanonicalTileID;
        key: string;
        /**
         * This matrix is used during terrain's render-to-texture stage only.
         * If the render-to-texture stage is active, this matrix will be present
         * and should be used, otherwise this matrix will be null.
         * The matrix should be float32 in order to avoid slow WebGL calls in Chrome.
         */
        terrainRttPosMatrix32f: mat4 | null;
        constructor(overscaledZ: number, wrap: number, z: number, x: number, y: number);
        clone(): OverscaledTileID;
        equals(id: OverscaledTileID): boolean;
        scaledTo(targetZ: number): OverscaledTileID;
        calculateScaledKey(targetZ: number, withWrap: boolean): string;
        isChildOf(parent: OverscaledTileID): boolean;
        children(sourceMaxZoom: number): OverscaledTileID[];
        isLessThan(rhs: OverscaledTileID): boolean;
        wrapped(): OverscaledTileID;
        unwrapTo(wrap: number): OverscaledTileID;
        overscaleFactor(): number;
        toUnwrapped(): UnwrappedTileID;
        toString(): string;
        getTilePoint(coord: MercatorCoordinate): Point;
    }
    /**
     * Makes optional keys required and add the the undefined type.
     *
     * ```
     * interface Test {
     *  foo: number;
     *  bar?: number;
     *  baz: number | undefined;
     * }
     *
     * Complete<Test> {
     *  foo: number;
     *  bar: number | undefined;
     *  baz: number | undefined;
     * }
     *
     * ```
     *
     * See https://medium.com/terria/typescript-transforming-optional-properties-to-required-properties-that-may-be-undefined-7482cb4e1585
     */
    type Complete<T> = {
        [P in keyof Required<T>]: Pick<T, P> extends Required<Pick<T, P>> ? T[P] : T[P] | undefined;
    };
    /**
     * A type of MapLibre resource.
     */
    const enum ResourceType {
        Glyphs = "Glyphs",
        Image = "Image",
        Source = "Source",
        SpriteImage = "SpriteImage",
        SpriteJSON = "SpriteJSON",
        Style = "Style",
        Tile = "Tile",
        Unknown = "Unknown"
    }
    /**
     * This function is used to tranform a request.
     * It is used just before executing the relevant request.
     */
    type RequestTransformFunction = (url: string, resourceType?: ResourceType) => RequestParameters | undefined;
    class RequestManager {
        _transformRequestFn: RequestTransformFunction;
        constructor(transformRequestFn?: RequestTransformFunction);
        transformRequest(url: string, type: ResourceType): RequestParameters;
        setTransformRequest(transformRequest: RequestTransformFunction): void;
    }
    /**
     * A listener method used as a callback to events
     */
    type Listener = (a: any) => any;
    type Listeners = {
        [_: string]: Array<Listener>;
    };
    /**
     * The event class
     */
    class Event {
        readonly type: string;
        constructor(type: string, data?: any);
    }
    interface ErrorLike {
        message: string;
    }
    /**
     * An error event
     */
    class ErrorEvent extends Event {
        error: ErrorLike;
        constructor(error: ErrorLike, data?: any);
    }
    /**
     * Methods mixed in to other classes for event capabilities.
     *
     * @group Event Related
     */
    class Evented {
        _listeners: Listeners;
        _oneTimeListeners: Listeners;
        _eventedParent: Evented;
        _eventedParentData: any | (() => any);
        /**
         * Adds a listener to a specified event type.
         *
         * @param type - The event type to add a listen for.
         * @param listener - The function to be called when the event is fired.
         * The listener function is called with the data object passed to `fire`,
         * extended with `target` and `type` properties.
         */
        on(type: string, listener: Listener): this;
        /**
         * Removes a previously registered event listener.
         *
         * @param type - The event type to remove listeners for.
         * @param listener - The listener function to remove.
         */
        off(type: string, listener: Listener): this;
        /**
         * Adds a listener that will be called only once to a specified event type.
         *
         * The listener will be called first time the event fires after the listener is registered.
         *
         * @param type - The event type to listen for.
         * @param listener - The function to be called when the event is fired the first time.
         * @returns `this` or a promise if a listener is not provided
         */
        once(type: string, listener?: Listener): this | Promise<any>;
        fire(event: Event | string, properties?: any): this;
        /**
         * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
         *
         * @param type - The event type
         * @returns `true` if there is at least one registered listener for specified event type, `false` otherwise
         */
        listens(type: string): boolean;
        /**
         * Bubble all events fired by this instance of Evented to this parent instance of Evented.
         */
        setEventedParent(parent?: Evented | null, data?: any | (() => any)): this;
    }
    type RasterSourceSpecification = {
        type: "raster";
        url?: string;
        tiles?: Array<string>;
        bounds?: [
            number,
            number,
            number,
            number
        ];
        minzoom?: number;
        maxzoom?: number;
        tileSize?: number;
        scheme?: "xyz" | "tms";
        attribution?: string;
        volatile?: boolean;
    };
    type SourceSpecification = RasterSourceSpecification;
    type BackgroundLayerSpecification = {
        id: string;
        type: "background";
        metadata?: unknown;
        minzoom?: number;
        maxzoom?: number;
        layout?: {
            visibility?: "visible" | "none";
        };
        paint?: {
            "background-color"?: string;
            "background-opacity"?: number;
        };
    };
    type RasterLayerSpecification = {
        id: string;
        type: "raster";
        metadata?: unknown;
        source: string;
        "source-layer"?: string;
        minzoom?: number;
        maxzoom?: number;
        layout?: {
            visibility?: "visible" | "none";
        };
        paint?: {
            "raster-opacity"?: number;
        };
    };
    type TransitionSpecification = {
        duration?: number;
        delay?: number;
    };
    type LayerSpecification = RasterLayerSpecification | BackgroundLayerSpecification;
    type StyleSpecification = {
        version: 8;
        name?: string;
        metadata?: unknown;
        center?: Array<number>;
        centerAltitude?: number;
        zoom?: number;
        bearing?: number;
        pitch?: number;
        roll?: number;
        sources: {
            [_: string]: SourceSpecification;
        };
        glyphs?: string;
        transition?: TransitionSpecification;
        layers: Array<LayerSpecification>;
    };
    /**
     * Operations that can be performed by the diff.
     * Below are the operations and their arguments, the arguments should be aligned with the style methods in maplibre-gl-js.
     */
    type DiffOperationsMap = {
        setStyle: [
            StyleSpecification
        ];
        addLayer: [
            LayerSpecification,
            string | null
        ];
        removeLayer: [
            string
        ];
        setPaintProperty: [
            string,
            string,
            unknown,
            string | null
        ];
        setLayoutProperty: [
            string,
            string,
            unknown,
            string | null
        ];
        setFilter: [
            string,
            unknown
        ];
        addSource: [
            string,
            SourceSpecification
        ];
        removeSource: [
            string
        ];
        setGeoJSONSourceData: [
            string,
            unknown
        ];
        setLayerZoomRange: [
            string,
            number,
            number
        ];
        setLayerProperty: [
            string,
            string,
            unknown
        ];
        setCenter: [
            number[]
        ];
        setCenterAltitude: [
            number
        ];
        setZoom: [
            number
        ];
        setBearing: [
            number
        ];
        setPitch: [
            number
        ];
        setRoll: [
            number
        ];
        setGlyphs: [
            string
        ];
        setTransition: [
            TransitionSpecification
        ];
    };
    type DiffOperations = keyof DiffOperationsMap;
    type DiffCommand<T extends DiffOperations> = {
        command: T;
        args: DiffOperationsMap[T];
    };
    class ZoomHistory {
        lastZoom: number;
        lastFloorZoom: number;
        lastIntegerZoom: number;
        lastIntegerZoomTime: number;
        first: boolean;
        constructor();
        update(z: number, now: number): boolean;
    }
    type CrossfadeParameters = {
        fromScale: number;
        toScale: number;
        t: number;
    };
    class EvaluationParameters {
        zoom: number;
        now: number;
        fadeDuration: number;
        zoomHistory: ZoomHistory;
        transition: TransitionSpecification;
        constructor(zoom: number, options?: any);
        crossFadingFactor(): number;
        getCrossfadeParameters(): CrossfadeParameters;
    }
    /**
     * This type contains all data necessary to project a tile to screen in MapLibre's shader system.
     * Contains data used for both mercator and globe projection.
     */
    type ProjectionData = {
        /**
         * The main projection matrix. For mercator projection, it usually projects in-tile coordinates 0..EXTENT to screen,
         * for globe projection, it projects a unit sphere planet to screen.
         * Uniform name: `u_projection_matrix`.
         */
        mainMatrix: mat4;
        /**
         * The extent of current tile in the mercator square.
         * Used by globe projection.
         * First two components are X and Y offset, last two are X and Y scale.
         * Uniform name: `u_projection_tile_mercator_coords`.
         *
         * Conversion from in-tile coordinates in range 0..EXTENT is done as follows:
         * @example
         * ```
         * vec2 mercator_coords = u_projection_tile_mercator_coords.xy + in_tile.xy * u_projection_tile_mercator_coords.zw;
         * ```
         */
        tileMercatorCoords: [
            number,
            number,
            number,
            number
        ];
        /**
         * The plane equation for a plane that intersects the planet's horizon.
         * Assumes the planet to be a unit sphere.
         * Used by globe projection for clipping.
         * Uniform name: `u_projection_clipping_plane`.
         */
        clippingPlane: [
            number,
            number,
            number,
            number
        ];
        /**
         * A value in range 0..1 indicating interpolation between mercator (0) and globe (1) projections.
         * Used by globe projection to hide projection transition at high zooms.
         * Uniform name: `u_projection_transition`.
         */
        projectionTransition: number;
        /**
         * Fallback matrix that projects the current tile according to mercator projection.
         * Used by globe projection to fall back to mercator projection in an animated way.
         * Uniform name: `u_projection_fallback_matrix`.
         */
        fallbackMatrix: mat4;
    };
    /**
     * Input arguments exposed by custom render function.
     */
    type CustomRenderMethodInput = {
        /**
         * This value represents the distance from the camera to the far clipping plane.
         * It is used in the calculation of the projection matrix to determine which objects are visible.
         * farZ should be larger than nearZ.
         */
        farZ: number;
        /**
         * This value represents the distance from the camera to the near clipping plane.
         * It is used in the calculation of the projection matrix to determine which objects are visible.
         * nearZ should be smaller than farZ.
         */
        nearZ: number;
        /**
         * Vertical field of view in radians.
         */
        fov: number;
        /**
         * model view projection matrix
         * represents the matrix converting from world space to clip space
         * https://learnopengl.com/Getting-started/Coordinate-Systems
         * **/
        modelViewProjectionMatrix: mat4;
        /**
         * projection matrix
         * represents the matrix converting from view space to clip space
         * https://learnopengl.com/Getting-started/Coordinate-Systems
         */
        projectionMatrix: mat4;
        /**
         * Data required for picking and compiling a custom shader for the current projection.
         */
        shaderData: {
            /**
             * Name of the shader variant that should be used.
             * Depends on current projection.
             * Whenever the other shader properties change, this string changes as well,
             * and can be used as a key with which to cache compiled shaders.
             */
            variantName: string;
            /**
             * The prelude code to add to the vertex shader to access MapLibre's `projectTile` projection function.
             * Depends on current projection.
             * @example
             * ```
             * const vertexSource = `#version 300 es
             * ${shaderData.vertexShaderPrelude}
             * ${shaderData.define}
             * in vec2 a_pos;
             * void main() {
             *     gl_Position = projectTile(a_pos);
             * }`;
             * ```
             */
            vertexShaderPrelude: string;
            /**
             * Defines to add to the shader code.
             * Depends on current projection.
             * @example
             * ```
             * const vertexSource = `#version 300 es
             * ${shaderData.vertexShaderPrelude}
             * ${shaderData.define}
             * in vec2 a_pos;
             * void main() {
             *     gl_Position = projectTile(a_pos);
             *     #ifdef GLOBE
             *     // Do globe-specific things
             *     #endif
             * }`;
             * ```
             */
            define: string;
        };
        /**
         * Uniforms that should be passed to the vertex shader, if MapLibre's projection code is used.
         * For more details of this object's internals, see its doc comments in `src/geo/projection/projection_data.ts`.
         *
         * These uniforms are set so that `projectTile` in shader accepts a vec2 in range 0..1 in web mercator coordinates.
         * Use `map.transform.getProjectionData(tileID)` to get uniforms for a given tile and pass vec2 in tile-local range 0..EXTENT instead.
         *
         * For projection 3D features, use `projectTileFor3D` in the shader.
         *
         * If you just need a projection matrix, use `defaultProjectionData.projectionMatrix`.
         * A projection matrix is sufficient for simple custom layers that also only support mercator projection.
         *
         * Under mercator projection, when these uniforms are used, the shader's `projectTile` function projects spherical mercator
         * coordinates to gl clip space coordinates. The spherical mercator coordinate `[0, 0]` represents the
         * top left corner of the mercator world and `[1, 1]` represents the bottom right corner. When
         * the `renderingMode` is `"3d"`, the z coordinate is conformal. A box with identical x, y, and z
         * lengths in mercator units would be rendered as a cube. {@link MercatorCoordinate.fromLngLat}
         * can be used to project a `LngLat` to a mercator coordinate.
         *
         * Under globe projection, when these uniforms are used, the `elevation` parameter
         * passed to `projectTileFor3D` in the shader is elevation in meters above "sea level",
         * or more accurately for globe, elevation above the surface of the perfect sphere used to render the planet.
         */
        defaultProjectionData: ProjectionData;
    };
    /**
     * @param gl - The map's gl context.
     * @param options - Argument object with render inputs like camera properties.
     */
    type CustomRenderMethod = (gl: WebGLRenderingContext | WebGL2RenderingContext, options: CustomRenderMethodInput) => void;
    /**
     * Interface for custom style layers. This is a specification for
     * implementers to model: it is not an exported method or class.
     *
     * Custom layers allow a user to render directly into the map's GL context using the map's camera.
     * These layers can be added between any regular layers using {@link MapLibreMap#addLayer}.
     *
     * Custom layers must have a unique `id` and must have the `type` of `"custom"`.
     * They must implement `render` and may implement `prerender`, `onAdd` and `onRemove`.
     * They can trigger rendering using {@link MapLibreMap#triggerRepaint}
     * and they should appropriately handle {@link MapContextEvent} with `webglcontextlost` and `webglcontextrestored`.
     *
     * The `renderingMode` property controls whether the layer is treated as a `"2d"` or `"3d"` map layer. Use:
     *
     * - `"renderingMode": "3d"` to use the depth buffer and share it with other layers
     * - `"renderingMode": "2d"` to add a layer with no depth. If you need to use the depth buffer for a `"2d"` layer you must use an offscreen
     *   framebuffer and {@link CustomLayerInterface#prerender}
     *
     * @example
     * Custom layer implemented as ES6 class
     * ```ts
     * class NullIslandLayer {
     *     constructor() {
     *         this.id = 'null-island';
     *         this.type = 'custom';
     *         this.renderingMode = '2d';
     *     }
     *
     *     onAdd(map, gl) {
     *         const vertexSource = `
     *         uniform mat4 u_matrix;
     *         void main() {
     *             gl_Position = u_matrix * vec4(0.5, 0.5, 0.0, 1.0);
     *             gl_PointSize = 20.0;
     *         }`;
     *
     *         const fragmentSource = `
     *         void main() {
     *             fragColor = vec4(1.0, 0.0, 0.0, 1.0);
     *         }`;
     *
     *         const vertexShader = gl.createShader(gl.VERTEX_SHADER);
     *         gl.shaderSource(vertexShader, vertexSource);
     *         gl.compileShader(vertexShader);
     *         const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
     *         gl.shaderSource(fragmentShader, fragmentSource);
     *         gl.compileShader(fragmentShader);
     *
     *         this.program = gl.createProgram();
     *         gl.attachShader(this.program, vertexShader);
     *         gl.attachShader(this.program, fragmentShader);
     *         gl.linkProgram(this.program);
     *     }
     *
     *     render(gl, matrix) {
     *         gl.useProgram(this.program);
     *         gl.uniformMatrix4fv(gl.getUniformLocation(this.program, "u_matrix"), false, matrix);
     *         gl.drawArrays(gl.POINTS, 0, 1);
     *     }
     * }
     *
     * map.on('load', () => {
     *     map.addLayer(new NullIslandLayer());
     * });
     * ```
     */
    interface CustomLayerInterface {
        /**
         * A unique layer id.
         */
        id: string;
        /**
         * The layer's type. Must be `"custom"`.
         */
        type: "custom";
        /**
         * Either `"2d"` or `"3d"`. Defaults to `"2d"`.
         */
        renderingMode?: "2d" | "3d";
        /**
         * Called during a render frame allowing the layer to draw into the GL context.
         *
         * The layer can assume blending and depth state is set to allow the layer to properly
         * blend and clip other layers. The layer cannot make any other assumptions about the
         * current GL state.
         *
         * If the layer needs to render to a texture, it should implement the `prerender` method
         * to do this and only use the `render` method for drawing directly into the main framebuffer.
         *
         * The blend function is set to `gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)`. This expects
         * colors to be provided in premultiplied alpha form where the `r`, `g` and `b` values are already
         * multiplied by the `a` value. If you are unable to provide colors in premultiplied form you
         * may want to change the blend function to
         * `gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)`.
         */
        render: CustomRenderMethod;
        /**
         * Optional method called during a render frame to allow a layer to prepare resources or render into a texture.
         *
         * The layer cannot make any assumptions about the current GL state and must bind a framebuffer before rendering.
         */
        prerender?: CustomRenderMethod;
        /**
         * Optional method called when the layer has been added to the Map with {@link MapLibreMap#addLayer}. This
         * gives the layer a chance to initialize gl resources and register event listeners.
         *
         * @param map - The Map this custom layer was just added to.
         * @param gl - The gl context for the map.
         */
        onAdd?(map: MapLibreMap, gl: WebGLRenderingContext | WebGL2RenderingContext): void;
        /**
         * Optional method called when the layer has been removed from the Map with {@link MapLibreMap#removeLayer}. This
         * gives the layer a chance to clean up gl resources and event listeners.
         *
         * @param map - The Map this custom layer was just added to.
         * @param gl - The gl context for the map.
         */
        onRemove?(map: MapLibreMap, gl: WebGLRenderingContext | WebGL2RenderingContext): void;
    }
    /**
     * Used to group several layers and handle them as one. If you add it to the map,
     * any layers added or removed from the group will be added/removed on the map as
     * well. Extends `Layer`.
     *
     * Mostly used by {@link FeatureGroup} and {@link GeoJSON}.
     *
     * @group Internal Layers
     */
    class LayerGroup extends Layer {
        /**
         * @internal
         */
        _layers: {
            [id: number]: Layer;
        };
        get maplibreMap(): MapLibreMap | undefined;
        constructor(layers?: Layer[], options?: LayerOptions);
        /**
         * Adds the given layer to the group.
         */
        addLayer(layer: Layer): this;
        /**
         * Removes the layer with the given internal ID or the given layer from the group.
         */
        removeLayer(layer: number | Layer): this;
        /**
         * Returns true if the given layer is currently added to the group.
         */
        hasLayer(layer: Layer): boolean;
        /**
         * Removes all the layers from the group.
         */
        clearLayers(): this;
        /**
         * Calls methodName on every layer contained in this group, passing any additional parameters.
         * Has no effect if the layers contained do not implement methodName.
         */
        invoke(methodName: string, ...args: any[]): this;
        /**
         * Iterates over the layers of the group,
         * optionally specifying context of the iterator function.
         */
        eachLayer(method: (layer: Layer) => void, context?: any): this;
        /**
         * Returns the layer with the given internal ID.
         */
        getLayer(id: number): Layer | undefined;
        /**
         * Returns an array of all the layers added to the group.
         */
        getLayers(): Layer[];
        /**
         * Calls setZIndex on every layer contained in this group, passing the z-index.
         */
        setZIndex(zIndex: number): this;
        /**
         * Returns the internal ID for a layer
         */
        getLayerId(layer: Layer): number;
        /**
         * @internal
         */
        onAdd(map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(map: LeafletGlMap): this;
        private _toMultiPoint;
        /**
         * Coordinates values are rounded with {@link formatNum} function with given `precisionDigits`.
         * Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, or a `Feature` containing a `GeometryCollection` or `MultiPoint`).
         */
        toGeoJSON(precisionDigits?: number): geojson.Feature | geojson.FeatureCollection;
        /**
         * @internal
         */
        _addTooltipFocusListeners(tooltipLayer: Layer): void;
        /**
         * @internal
         */
        _setAriaDescribedByTooltipLayer(tooltipLayer: Layer): void;
    }
    /**
     * @deprecated
     * Creates a layer group, optionally given an initial set of layers and an `options` object.
     *
     * @group Factory Functions
     */
    const layerGroup: (layers?: Layer[], options?: LayerOptions) => LayerGroup;
    class LatLng {
        /**
         * Latitude in degrees.
         */
        lat: number;
        /**
         * Longitude in degrees.
         */
        lng: number;
        /**
         * Altitude in meters (optional).
         */
        alt?: number;
        constructor(lat: number, lng: number, alt?: number);
        /**
         * Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
         */
        equals(otherLatLng: LatLngExpression, maxMargin?: number): boolean;
        /**
         * Returns a string representation of the LatLng (for debugging purposes).
         * @param precision - Number of decimal digits to use, defaults to 6, or `false` to skip rounding entirely.
         * @returns A string representation of the LatLng.
         */
        toString(precision?: number | false): string;
        /**
         * Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
         */
        distanceTo(other: LatLngExpression): number;
        /**
         * Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
         */
        wrap(): LatLng;
        clone(): LatLng;
    }
    type LatLngLiteralLon = {
        lat: number;
        lon: number;
        alt?: number;
    };
    type LatLngLiteralLng = {
        lat: number;
        lng: number;
        alt?: number;
    };
    type LatLngLiteral = LatLngLiteralLon | LatLngLiteralLng;
    type LatLngTuple = [
        number,
        number,
        number?
    ];
    type LatLngExpression = LatLng | LatLngLiteral | LatLngTuple;
    /**
     * Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).
     */
    function latLng(latitude: number, longitude: number, altitude?: number): LatLng;
    /**
     * Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.
     */
    function latLng(coords: LatLngTuple): LatLng;
    /**
     * Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.
     * You can also use `lon` in place of `lng` in the object form.
     */
    function latLng(coords: LatLngLiteral): LatLng;
    function latLng(object: LatLng): LatLng;
    function latLng(latOrLatLngExpression: LatLng | LatLngLiteral | LatLngTuple | number, lng?: number, altitude?: number): LatLng;
    type IconBaseOptions = {
        /**
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         */
        popupAnchor?: PointExpression;
        /**
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         */
        tooltipAnchor?: PointExpression;
        /**
         * Size of the icon image in pixels.
         * If a signle number is given, both axes are assumed to be this number.
         */
        iconSize?: PointExpression | number;
        /**
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         */
        iconAnchor?: PointExpression | null;
        /**
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        className?: string;
    };
    abstract class IconBase {
        options: Required<IconBaseOptions>;
        constructor(options: Required<IconBaseOptions>);
        /**
         * Called internally when the icon has to be shown, returns a `<img>` HTML element
         * styled according to the options.
         */
        abstract createIcon(oldIcon?: HTMLElement | null): HTMLElement;
        /**
         * As `createIcon`, but for the shadow beneath it.
         */
        abstract createShadow(oldIcon?: HTMLElement | null): HTMLElement | null;
        protected _setIconStyles(element: HTMLElement, name: IconImgName, sizeOption: PointExpression | number, anchorOption?: PointExpression | null): void;
    }
    type IconOptions = IconBaseOptions & {
        /**
         * The URL to the icon image (absolute or relative to your script path).
         */
        iconUrl: string;
        /**
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         */
        iconRetinaUrl?: string | null;
        /**
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         */
        shadowUrl?: string | null;
        /**
         * The URL to the retina version of the icon's shadow image.
         */
        shadowRetinaUrl?: string | null;
        /**
         * Size of the shadow image in pixels.
         * If a signle number is given, both axes are assumed to be this number.
         */
        shadowSize?: PointExpression | number | null;
        /**
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same as iconAnchor if not specified).
         */
        shadowAnchor?: PointExpression | null;
        /**
         * Whether the crossOrigin attribute will be added to the tiles.
         * If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
         * Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
         */
        crossOrigin?: string | boolean;
        /**
         * `Icon.Default` will try to auto-detect the location of the
         * blue icon images. If you are placing these images in a non-standard
         * way, set this option to point to the right path.
         */
        imagePath?: string | null;
    };
    type IconImgName = "icon" | "shadow";
    /**
     * @class Icon
     *
     * Represents an icon to provide when creating a marker.
     *
     * @example
     *
     * ```js
     * var myIcon = L.icon({
     *     iconUrl: 'my-icon.png',
     *     iconRetinaUrl: 'my-icon@2x.png',
     *     iconSize: [38, 95],
     *     iconAnchor: [22, 94],
     *     popupAnchor: [-3, -76],
     *     shadowUrl: 'my-icon-shadow.png',
     *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
     *     shadowSize: [68, 95],
     *     shadowAnchor: [22, 94]
     * });
     *
     * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
     * ```
     *
     * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
     *
     */
    class Icon extends IconBase {
        static defaultOptions: Required<IconOptions>;
        options: Required<IconOptions>;
        constructor(options?: IconOptions);
        /**
         * Called internally when the icon has to be shown, returns a `<img>` HTML element
         * styled according to the options.
         * @internal
         */
        createIcon(oldIcon?: HTMLElement | null): HTMLElement;
        /**
         * Same as {@link createIcon}, but for the shadow image.
         * @internal
         */
        createShadow(oldIcon?: HTMLElement | null): HTMLElement | null;
        protected _createIcon(name: "icon", oldIcon?: HTMLElement | null): HTMLImageElement;
        protected _createIcon(name: "shadow", oldIcon?: HTMLElement | null): HTMLImageElement | null;
        protected _createImg(src: any, el?: HTMLImageElement): HTMLImageElement;
        protected _getIconUrl(name: IconImgName): string | null;
        private _getIconUrlInternal;
        /**
         * Used by Icon.Default
         */
        protected _getDefaultIconUrl(name: IconImgName): string;
        /**
         * Used by Icon.Default
         */
        protected _stripUrl(path: string): string | null;
        /**
         * Used by Icon.Default
         */
        protected _detectIconPath(): string;
        /**
         * Used by Icon.Default
         */
        protected static getIconDefaultDefaultOptions(): IconOptions;
        /**
         * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
         * no icon is specified. Points to the blue marker image distributed with Leaflet
         * releases.
         *
         * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
         * (which is a set of `Icon options`).
         *
         * If you want to _completely_ replace the default icon, override the
         * `L.Marker.prototype.options.icon` with your own icon instead.
         */
        static Default: typeof Icon;
    }
    type DivIconOptions = IconBaseOptions & {
        /**
         * Custom HTML code to put inside the div element, empty by default. Alternatively,
         * an instance of `HTMLElement`.
         */
        html?: string | HTMLElement | false;
        /**
         * Optional relative position of the background, in pixels.
         */
        bgPos?: PointExpression | null;
    };
    class DivIcon extends IconBase {
        options: Required<DivIconOptions>;
        constructor(options?: DivIconOptions);
        createIcon(oldIcon?: HTMLElement | null): HTMLElement;
        createShadow(_oldIcon?: HTMLElement): HTMLElement | null;
    }
    /**
     * @deprecated
     * Creates an icon instance with the given options.
     *
     * @group Factory Functions
     */
    function icon(options: IconOptions): Icon;
    /**
     * @deprecated
     * Creates a `DivIcon` instance with the given options.
     *
     * @group Factory Functions
     */
    function divIcon(options?: DivIconOptions): DivIcon;
    abstract class Handler {
        protected _map: LeafletGlMap;
        protected _enabled: boolean;
        protected constructor(map: LeafletGlMap);
        /**
         * Enables the handler.
         */
        enable(): this;
        /**
         * Disables the handler.
         */
        disable(): this;
        /**
         * Returns `true` if the handler is enabled.
         */
        enabled(): boolean;
        /**
         * Called when the handler is enabled, should add event hooks.
         */
        protected abstract addHooks(): void;
        /**
         * Called when the handler is disabled, should remove the event hooks added previously.
         */
        protected abstract removeHooks(): void;
    }
    /**
     * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,
     * or an array of numbers in [west, south, east, north] order.
     *
     * @group Geography and Geometry
     *
     * @example
     * ```ts
     * let v1 = new LngLatBounds(
     *   new LngLat(-73.9876, 40.7661),
     *   new LngLat(-73.9397, 40.8002)
     * );
     * let v2 = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])
     * let v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
     * ```
     */
    type LngLatBoundsLike = LngLatBounds | [
        LngLatLike,
        LngLatLike
    ] | [
        number,
        number,
        number,
        number
    ];
    /**
     * A `LngLatBounds` object represents a geographical bounding box,
     * defined by its southwest and northeast points in longitude and latitude.
     *
     * If the longitude bounds difference is over 360°, no longitude bound is applied.
     *
     * If no arguments are provided to the constructor, a `null` bounding box is created.
     *
     * Note that any Mapbox GL method that accepts a `LngLatBounds` object as an argument or option
     * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.
     * This flexible type is documented as {@link LngLatBoundsLike}.
     *
     * @group Geography and Geometry
     *
     * @example
     * ```ts
     * let sw = new LngLat(-73.9876, 40.7661);
     * let ne = new LngLat(-73.9397, 40.8002);
     * let llb = new LngLatBounds(sw, ne);
     * ```
     */
    class LngLatBounds {
        _ne: LngLat;
        _sw: LngLat;
        /**
         * @param sw - The southwest corner of the bounding box.
         * OR array of 4 numbers in the order of  west, south, east, north
         * OR array of 2 LngLatLike: [sw,ne]
         * @param ne - The northeast corner of the bounding box.
         * @example
         * ```ts
         * let sw = new LngLat(-73.9876, 40.7661);
         * let ne = new LngLat(-73.9397, 40.8002);
         * let llb = new LngLatBounds(sw, ne);
         * ```
         * OR
         * ```ts
         * let llb = new LngLatBounds([-73.9876, 40.7661, -73.9397, 40.8002]);
         * ```
         * OR
         * ```ts
         * let llb = new LngLatBounds([sw, ne]);
         * ```
         */
        constructor(sw?: LngLatLike | [
            number,
            number,
            number,
            number
        ] | [
            LngLatLike,
            LngLatLike
        ], ne?: LngLatLike);
        /**
         * Set the northeast corner of the bounding box
         *
         * @param ne - a {@link LngLatLike} object describing the northeast corner of the bounding box.
         */
        setNorthEast(ne: LngLatLike): this;
        /**
         * Set the southwest corner of the bounding box
         *
         * @param sw - a {@link LngLatLike} object describing the southwest corner of the bounding box.
         */
        setSouthWest(sw: LngLatLike): this;
        /**
         * Extend the bounds to include a given LngLatLike or LngLatBoundsLike.
         *
         * @param obj - object to extend to
         */
        extend(obj: LngLatLike | LngLatBoundsLike): this;
        /**
         * Returns the geographical coordinate equidistant from the bounding box's corners.
         *
         * @returns The bounding box's center.
         * @example
         * ```ts
         * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
         * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
         * ```
         */
        getCenter(): LngLat;
        /**
         * Returns the southwest corner of the bounding box.
         *
         * @returns The southwest corner of the bounding box.
         */
        getSouthWest(): LngLat;
        /**
         * Returns the northeast corner of the bounding box.
         *
         * @returns The northeast corner of the bounding box.
         */
        getNorthEast(): LngLat;
        /**
         * Returns the northwest corner of the bounding box.
         *
         * @returns The northwest corner of the bounding box.
         */
        getNorthWest(): LngLat;
        /**
         * Returns the southeast corner of the bounding box.
         *
         * @returns The southeast corner of the bounding box.
         */
        getSouthEast(): LngLat;
        /**
         * Returns the west edge of the bounding box.
         *
         * @returns The west edge of the bounding box.
         */
        getWest(): number;
        /**
         * Returns the south edge of the bounding box.
         *
         * @returns The south edge of the bounding box.
         */
        getSouth(): number;
        /**
         * Returns the east edge of the bounding box.
         *
         * @returns The east edge of the bounding box.
         */
        getEast(): number;
        /**
         * Returns the north edge of the bounding box.
         *
         * @returns The north edge of the bounding box.
         */
        getNorth(): number;
        /**
         * Returns the bounding box represented as an array.
         *
         * @returns The bounding box represented as an array, consisting of the
         * southwest and northeast coordinates of the bounding represented as arrays of numbers.
         * @example
         * ```ts
         * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
         * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
         * ```
         */
        toArray(): [
            number,
            number
        ][];
        /**
         * Return the bounding box represented as a string.
         *
         * @returns The bounding box represents as a string of the format
         * `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.
         * @example
         * ```ts
         * let llb = new LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
         * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
         * ```
         */
        toString(): string;
        /**
         * Check if the bounding box is an empty/`null`-type box.
         *
         * @returns True if bounds have been defined, otherwise false.
         */
        isEmpty(): boolean;
        /**
         * Check if the point is within the bounding box.
         *
         * @param lnglat - geographic point to check against.
         * @returns `true` if the point is within the bounding box.
         * @example
         * ```ts
         * let llb = new LngLatBounds(
         *   new LngLat(-73.9876, 40.7661),
         *   new LngLat(-73.9397, 40.8002)
         * );
         *
         * let ll = new LngLat(-73.9567, 40.7789);
         *
         * console.log(llb.contains(ll)); // = true
         * ```
         */
        contains(lnglat: LngLatLike): boolean;
        /**
         * Converts an array to a `LngLatBounds` object.
         *
         * If a `LngLatBounds` object is passed in, the function returns it unchanged.
         *
         * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.
         *
         * @param input - An array of two coordinates to convert, or a `LngLatBounds` object to return.
         * @returns A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.
         * @example
         * ```ts
         * let arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
         * let llb = LngLatBounds.convert(arr); // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
         * ```
         */
        static convert(input: LngLatBoundsLike | null): LngLatBounds;
        /**
         * Returns a `LngLatBounds` from the coordinates extended by a given `radius`. The returned `LngLatBounds` completely contains the `radius`.
         *
         * @param center - center coordinates of the new bounds.
         * @param radius - Distance in meters from the coordinates to extend the bounds.
         * @returns A new `LngLatBounds` object representing the coordinates extended by the `radius`.
         * @example
         * ```ts
         * let center = new LngLat(-73.9749, 40.7736);
         * LngLatBounds.fromLngLat(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
         * ```
         */
        static fromLngLat(center: LngLat, radius?: number): LngLatBounds;
        /**
         * Adjusts the given bounds to handle the case where the bounds cross the 180th meridian (antimeridian).
         *
         * @returns The adjusted LngLatBounds
         * @example
         * ```ts
         * let bounds = new LngLatBounds([175.813127, -20.157768], [-178. 340903, -15.449124]);
         * let adjustedBounds = bounds.adjustAntiMeridian();
         * // adjustedBounds will be: [[175.813127, -20.157768], [181.659097, -15.449124]]
         * ```
         */
        adjustAntiMeridian(): LngLatBounds;
    }
    class LatLngBounds {
        private _southWest;
        private _northEast;
        constructor(corner1: LatLngExpression, corner2: LatLngExpression);
        constructor(array: LatLngExpression[]);
        constructor(corner1?: LatLngExpression | LatLngExpression[], corner2?: LatLngExpression);
        /**
         * Extend the bounds to contain the given point.
         */
        extend(latlng: LatLngExpression): this;
        /**
         * Extend the bounds to contain the given bounds.
         */
        extend(bounds: LatLngBoundsExpression): this;
        /**
         * Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
         * For example, a ratio of 0.5 extends the bounds by 50% in each direction.
         * Negative values will retract the bounds.
         */
        pad(bufferRatio: number): LatLngBounds;
        /**
         * Returns the center point of the bounds.
         */
        getCenter(): LatLng;
        /**
         * Returns the south-west point of the bounds.
         *
         * NOTE: returns the internal object without cloning, modifying it WILL modify this LatLngBounds instance!
         */
        getSouthWest(): LatLng;
        /**
         * Returns the north-east point of the bounds.
         *
         * NOTE: returns the internal object without cloning, modifying it WILL modify this LatLngBounds instance!
         */
        getNorthEast(): LatLng;
        /**
         * Returns the north-west point of the bounds.
         */
        getNorthWest(): LatLng;
        /**
         * Returns the south-east point of the bounds.
         */
        getSouthEast(): LatLng;
        /**
         * Returns the west longitude of the bounds
         */
        getWest(): number;
        /**
         * Returns the south latitude of the bounds
         */
        getSouth(): number;
        /**
         * Returns the east longitude of the bounds
         */
        getEast(): number;
        /**
         * Returns the north latitude of the bounds
         */
        getNorth(): number;
        /**
         * Returns `true` if the rectangle contains the given one.
         */
        contains(otherBounds: LatLngBoundsExpression): boolean;
        /**
         * Returns `true` if the rectangle contains the given point.
         */
        contains(latlng: LatLngExpression): boolean;
        contains(obj: LatLngBoundsExpression | LatLngExpression): boolean;
        /**
         * Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
         */
        intersects(bounds: LatLngBoundsExpression): boolean;
        /**
         * Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
         */
        overlaps(bounds: LatLngBoundsExpression): boolean;
        /**
         * Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
         */
        toBBoxString(): string;
        /**
         * Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
         */
        equals(otherBounds: LatLngBoundsExpression, maxMargin?: number): boolean;
        /**
         * Returns `true` if the bounds are properly initialized.
         */
        isValid(): boolean;
    }
    type LatLngBoundsExpression = LatLngBounds | LatLngExpression[];
    /**
     * @deprecated
     * Creates a new {@link LatLngBounds} object using an array of points it should contain.
     *
     * @group Factory Functions
     */
    function latLngBounds(points: LatLngExpression[]): LatLngBounds;
    /**
     * @deprecated
     * Creates a new {@link LatLngBounds} object using two corner points.
     *
     * @group Factory Functions
     */
    function latLngBounds(corner1: LatLngExpression, corner2: LatLngExpression): LatLngBounds;
    /**
     * Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
     * and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
     * `('Hello foo, bar')`. You can also specify functions instead of strings for
     * data values — they will be evaluated passing `data` as an argument.
     */
    function template(str: string, data: object): string;
    type MapBounds = [
        [
            number,
            number
        ],
        [
            number,
            number
        ]
    ];
    type LeafletBounds = [
        LatLngExpression,
        LatLngExpression
    ] | LatLngBounds;
    function requestAnimFrame(fn?: Function, context?: any): ReturnType<typeof window.requestAnimationFrame>;
    function create<T extends keyof HTMLElementTagNameMap>(tagName: T, className?: string, container?: HTMLElement): HTMLElementTagNameMap[T];
    function setTransform(el: HTMLElement, offset: Point, scale?: number): void;
    function setPosition(el: HTMLElement, point: Point): void;
    function getPosition(el: HTMLElement): Point;
    type CSSScaleAndBoundingRect = {
        x: number;
        y: number;
        boundingClientRect: DOMRect;
    };
    function getCssRectScale(element: HTMLElement): CSSScaleAndBoundingRect;
    function addClass(el: HTMLElement | SVGElement, name: string): void;
    const DomUtil: {
        create: typeof create;
        setTransform: typeof setTransform;
        setPosition: typeof setPosition;
        getPosition: typeof getPosition;
        addClass: typeof addClass;
    };
    interface IDragHandler {
        enabled(): boolean;
        moved(): boolean;
    }
    /**
     * @internal
     */
    interface IDraggable {
        dragging: IDragHandler;
    }
    type DraggableOptions = {
        /**
         * The max number of pixels a user can shift the mouse pointer during a click
         * for it to be considered a valid click (as opposed to a mouse drag).
         * @default 3
         */
        clickTolerance: number;
    };
    /**
     * A class for making DOM elements draggable (including touch support).
     * Used internally for map and marker dragging. Only works for elements
     * that were positioned with {@link DomUtil.setPosition}.
     *
     * @example
     * ```js
     * var draggable = new L.Draggable(elementToDrag);
     * draggable.enable();
     * ```
     */
    class Draggable extends LeafletEvented {
        static defaultOptions: Required<DraggableOptions>;
        options: Required<DraggableOptions>;
        protected _element: HTMLElement;
        protected _dragStartTarget: HTMLElement;
        protected _preventOutline: boolean;
        protected _enabled: boolean;
        /**
         * @internal
         */
        _moved: boolean;
        protected _moving: boolean;
        protected _startPoint: Point;
        /**
         * @internal
         */
        _startPos: Point;
        /**
         * @internal
         */
        _newPos: Point;
        protected _parentScale: ReturnType<typeof getCssRectScale>;
        protected _lastTarget: HTMLElement | null;
        protected _lastEvent: TouchEvent | MouseEvent;
        protected static _dragging: Draggable | false;
        /**
         * Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
         */
        constructor(element: HTMLElement, dragStartTarget?: HTMLElement, preventOutline?: boolean, options?: DraggableOptions);
        /**
         * Enables the dragging ability.
         */
        enable(): this;
        /**
         * Disables the dragging ability.
         */
        disable(): this;
        protected _onDown(e: TouchEvent | MouseEvent): void;
        protected _onMove(e: TouchEvent | MouseEvent): void;
        protected _updatePosition(): void;
        protected _onUp(): void;
        private isTouchEvent;
        finishDrag(noInertia?: boolean): void;
    }
    class MarkerDrag extends Handler implements IDragHandler {
        protected _marker: Marker;
        protected _draggable: Draggable;
        protected _panRequest: ReturnType<typeof requestAnimFrame>;
        protected _oldLatLng: LatLng | undefined;
        constructor(marker: Marker);
        addHooks(): this;
        removeHooks(): this;
        moved(): boolean;
        private _adjustPan;
        private _onDragStart;
        private _onPreDrag;
        private _onDrag;
        private _onDragEnd;
    }
    type MarkerOptions = InteractiveLayerOptions & {
        /**
         * Icon instance to use for rendering the marker.
         * See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
         * If not specified, a common instance of `L.Icon.Default` is used.
         * @default new Icon.Default()
         */
        icon?: IconBase;
        /**
         * Option inherited from "Interactive layer" abstract class
         * @default true
         */
        interactive?: boolean;
        /**
         * Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
         * @default true
         */
        keyboard?: boolean;
        /**
         * Text for the browser tooltip that appear on marker hover (no tooltip by default).
         * [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
         * @default ''
         */
        title?: string;
        /**
         * Text for the `alt` attribute of the icon image.
         * [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
         * @default 'Marker'
         */
        alt?: string;
        /**
         * By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
         * @default 0
         */
        zIndexOffset?: number;
        /**
         * The opacity of the marker.
         * @default 1.0
         */
        opacity?: number;
        /**
         * If `true`, the marker will get on top of others when you hover the mouse over it.
         * @default false
         */
        riseOnHover?: boolean;
        /**
         * The z-index offset used for the `riseOnHover` feature.
         * @default 250
         */
        riseOffset?: number;
        /**
         * `Map pane` where the markers icon will be added.
         * @default 'markerPane'
         */
        pane?: string;
        /**
         * `Map pane` where the markers shadow will be added.
         * @default 'shadowPane'
         */
        shadowPane?: string;
        /**
         * When `true`, a mouse event on this marker will trigger the same event on the map
         * (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
         * @default false
         */
        bubblingMouseEvents?: boolean;
        /**
         * When `true`, the map will pan whenever the marker is focused (via
         * e.g. pressing `tab` on the keyboard) to ensure the marker is
         * visible within the map's bounds
         *
         * NOTE: default is different from leaflet (where it is true by default),
         * however the actual behaviour of markers is that they do *not* auto-pan on focus.
         *
         * @default false
         */
        autoPanOnFocus?: boolean;
        /**
         * Whether the marker is draggable with mouse/touch or not.
         * @default false
         */
        draggable?: boolean;
        /**
         * Whether to pan the map when dragging this marker near its edge or not.
         * @default false
         */
        autoPan?: boolean;
        /**
         * Distance (in pixels to the left/right and to the top/bottom) of the
         * map edge to start panning the map.
         * @default [50,50]
         */
        autoPanPadding?: PointExpression;
        /**
         * Number of pixels the map should pan by.
         * @default 10
         */
        autoPanSpeed?: number;
    };
    /**
     * Marker is used to display clickable/draggable icons on the map.
     *
     * @group Layers
     *
     * @example
     *
     * ```js
     * L.marker([50.5, 30.5]).addTo(map);
     * ```
     */
    class Marker extends Layer implements IDraggable {
        static defaultOptions: Required<MarkerOptions>;
        options: Required<MarkerOptions>;
        /**
         * @internal
         */
        _latlng: LatLng;
        /**
         * @internal
         */
        _icon: HTMLElement | null;
        /**
         * @internal
         */
        _shadow: HTMLElement | null;
        protected _zIndex: number;
        dragging: MarkerDrag;
        constructor(latlng: LatLngExpression, options?: MarkerOptions);
        /**
         * @internal
         */
        onAdd(_map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(_map: LeafletGlMap): this;
        /**
         * @internal
         */
        getEvents(): LeafletGlEventHandlerFnMap;
        /**
         * Returns the current geographical position of the marker.
         */
        getLatLng(): LatLng;
        /**
         * Changes the marker position to the given point.
         */
        setLatLng(latlng: LatLngExpression): this;
        /**
         * Changes the {@link MarkerOptions.zIndexOffset} of the marker.
         */
        setZIndexOffset(offset: number): this;
        /**
         * Returns the current icon used by the marker
         */
        getIcon(): IconBase;
        /**
         * Changes the marker icon.
         */
        setIcon(icon: IconBase): this;
        /**
         * Changes the opacity of the marker.
         */
        setOpacity(opacity: number): this;
        /**
         * Returns the instance of [`HTMLElement`](https://developer.mozilla.org/docs/Web/API/HTMLElement)
         * used by L.Marker layer.
         */
        getElement(): HTMLElement | null;
        private _update;
        /**
         * @internal
         */
        _addTooltipFocusListeners(tooltipLayer: Layer): void;
        /**
         * @internal
         */
        _setAriaDescribedByTooltipLayer(tooltipLayer: Layer): void;
        /**
         * Returns true if a new HTMLElement was created.
         */
        private _initIcon;
        private _removeIcon;
        private _removeShadow;
        private _setPos;
        private _updateZIndex;
        private _initInteraction;
        private _updateOpacity;
        private _bringToFront;
        private _resetZIndex;
        private _panOnFocus;
        /**
         * @internal
         */
        _getPopupAnchor(): PointExpression;
        /**
         * @internal
         */
        _getTooltipAnchor(): PointExpression;
        toGeoJSON(precisionDigits?: number): geojson.Feature;
    }
    /**
     * @deprecated
     * Instantiates a Marker object given a geographical point and optionally an options object.
     *
     * @group Factory Functions
     */
    function marker(latlng: LatLngExpression, options?: MarkerOptions): Marker;
    class Bounds {
        min: Point;
        max: Point;
        constructor();
        constructor(a: PointExpression[]);
        constructor(a: PointExpression, b: PointExpression);
        constructor(a: BoundsObject);
        constructor(a: Point, b: Point);
        constructor(a: PointExpression[] | PointExpression, b?: PointExpression);
        constructor(a: PointExpression[] | PointExpression | BoundsObject, b?: PointExpression);
        /**
         * Extends the bounds to contain the given point.
         */
        extend(point: PointExpression): this;
        /**
         * Extend the bounds to contain the given bounds
         */
        extend(bounds: BoundsExpression): this;
        extend(obj: BoundsExpression | PointExpression): this;
        /**
         * Returns the center point of the bounds.
         */
        getCenter(round?: boolean): Point;
        /**
         * Returns the bottom-left point of the bounds.
         */
        getBottomLeft(): Point;
        /**
         * Returns the top-right point of the bounds.
         */
        getTopRight(): Point;
        /**
         * Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
         *
         * NOTE: does not clone the returned point, modifying it will modify this Bounds instance!
         */
        getTopLeft(): Point;
        /**
         * Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
         *
         * NOTE: does not clone the returned point, modifying it will modify this Bounds instance!
         */
        getBottomRight(): Point;
        /**
         * Returns the size of the given bounds
         */
        getSize(): Point;
        /**
         * Returns `true` if the rectangle contains the given bounds.
         */
        contains(otherBounds: BoundsExpression): boolean;
        /**
         * Returns `true` if the rectangle contains the given point.
         */
        contains(point: PointExpression): boolean;
        contains(obj: BoundsExpression | PointExpression): boolean;
        /**
         * Returns `true` if the rectangle intersects the given bounds. Two bounds
         * intersect if they have at least one point in common.
         */
        intersects(bounds: BoundsExpression): boolean;
        /**
         * Returns `true` if the rectangle overlaps the given bounds. Two bounds
         * overlap if their intersection is an area.
         */
        overlaps(bounds: BoundsExpression): boolean;
        /**
         * Returns `true` if the bounds are properly initialized.
         */
        isValid(): boolean;
        /**
         * Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
         * For example, a ratio of 0.5 extends the bounds by 50% in each direction.
         * Negative values will retract the bounds.
         */
        pad(bufferRatio: number): Bounds;
        /**
         * Returns `true` if the rectangle is equivalent to the given bounds.
         */
        equals(otherBounds: BoundsExpression): boolean;
    }
    type BoundsObject = {
        min: PointExpression;
        max: PointExpression;
    };
    type BoundsExpression = Bounds | PointExpression[] | BoundsObject;
    type BlanketOverlayOptions = LayerOptions & {
        /**
         * How much to extend the clip area around the map view (relative to its size)
         * e.g. 0.1 would be 10% of map view in each direction.
         */
        padding?: number;
        /**
         * When `false`, the blanket will update its position only when the
         * map state settles (*after* a pan/zoom animation). When `true`,
         * it will update when the map state changes (*during* pan/zoom
         * animations).
         */
        continuous?: boolean;
    };
    abstract class BlanketOverlay extends Layer {
        static defaultOptions: Required<BlanketOverlayOptions>;
        options: Required<BlanketOverlayOptions>;
        _container: HTMLElement | SVGElement | undefined;
        protected _zoom: number | undefined;
        protected _center: LatLng | undefined;
        _bounds: Bounds | undefined;
        constructor(options?: BlanketOverlayOptions);
        /**
         * @internal
         */
        onAdd(_map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(_map: LeafletGlMap): this;
        /**
         * @internal
         */
        getEvents(): LeafletGlEventHandlerFnMap;
        private _onZoom;
        private _updateTransform;
        private _onMoveEnd;
        protected _reset(): void;
        /**
         * Must initialize the HTML element to use as blanket, and store it as
         * `this._container`. The base implementation creates a blank `<div>`
         */
        protected _initContainer(): HTMLElement | SVGSVGElement;
        /**
         * Must destroy the HTML element in `this._container` and free any other
         * resources. The base implementation destroys the element and removes
         * any event handlers attached to it.
         */
        protected _destroyContainer(): void;
        /**
         * The base implementation resizes the container (based on the map's size
         * and taking into account the padding), returning the new size in CSS pixels.
         *
         * Subclass implementations shall reset container parameters and data
         * structures as needed.
         */
        protected _resizeContainer(): Point;
        /**
         * (Optional) Runs on the map's `zoomend` event.
         */
        protected _onZoomEnd?(ev?: LeafletEvent): void;
        /**
         * (Optional) Runs on the map's `viewreset` event.
         */
        protected _onViewReset?(ev?: MouseEvent): void;
        /**
         * Runs whenever the map state settles after changing (at the end of pan/zoom
         * animations, etc). This should trigger the bulk of any rendering logic.
         *
         * If the `continuous` option is set to `true`, then this also runs on
         * any map state change (including *during* pan/zoom animations).
         */
        protected abstract _onSettled(ev?: LeafletEvent): void;
    }
    type CircleMarkerOptions = PathOptions & {
        /**
         * Radius of the circle marker, in pixels.
         * @default 10
         */
        radius?: number;
    };
    /**
     * A circle of a fixed size with radius specified in pixels. Extends `Path`.
     */
    class CircleMarker extends Path {
        static defaultOptions: Required<CircleMarkerOptions>;
        options: Required<CircleMarkerOptions>;
        protected _latlng: LatLng;
        _point: Point;
        _radius: number;
        _pxBounds: Bounds;
        /**
         * @internal
         */
        get _radiusPixels(): number;
        constructor(latlng: LatLngExpression, options?: CircleMarkerOptions);
        /**
         * Sets the position of a circle marker to a new location.
         */
        setLatLng(latlng: LatLngExpression): this;
        /**
         * Returns the current geographical position of the circle marker.
         */
        getLatLng(): LatLng;
        /**
         * Sets the radius of a circle marker. Units are in pixels.
         */
        setRadius(radius: number): this;
        /**
         * Returns the current radius of the circle.
         */
        getRadius(): number;
        setStyle(options: CircleMarkerOptions): this;
        /**
         * @internal
         */
        _project(): void;
        protected _updateBounds(): void;
        /**
         * @internal
         */
        _update(): void;
        private _updatePath;
        /**
         * @internal
         */
        _empty(): boolean;
        _containsPoint(p: Point): boolean;
        toGeoJSON(precisionDigits?: number): geojson.Feature;
    }
    /**
     * @deprecated
     * Instantiates a circle marker object given a geographical point, and an optional options object.
     *
     * @group Factory Functions
     */
    function circleMarker(latlng: LatLngExpression, options?: CircleMarkerOptions): CircleMarker;
    type RendererBaseOptions = BlanketOverlayOptions & {
        padding?: number | undefined;
        tolerance?: number | undefined;
    };
    abstract class RendererBase extends BlanketOverlay {
        static defaultOptions: Required<RendererBaseOptions>;
        protected _layers: {
            [id: number]: Path;
        };
        options: Required<RendererBaseOptions>;
        constructor(options?: RendererBaseOptions);
        /**
         * @internal
         */
        onAdd(map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(map: LeafletGlMap): this;
        protected _onZoomEnd(): void;
        protected _updatePaths(): void;
        protected _onViewReset(): void;
        protected _onSettled(): void;
        protected abstract _update(): void;
        /**
         * @internal
         */
        abstract _initPath(layer: Path): void;
        /**
         * @internal
         */
        abstract _addPath(layer: Path): void;
        /**
         * @internal
         */
        abstract _updatePath(layer: Path): void;
        /**
         * @internal
         */
        abstract _removePath(layer: Path): void;
        /**
         * @internal
         */
        abstract _updateStyle(layer: Path): void;
        /**
         * @internal
         */
        abstract _bringToFront(layer: Path): void;
        /**
         * @internal
         */
        abstract _bringToBack(layer: Path): void;
        /**
         * @internal
         */
        abstract _updatePoly(layer: Polyline, closed?: boolean): void;
        /**
         * @internal
         */
        abstract _updateCircle(layer: CircleMarker): void;
    }
    type PathOptions = InteractiveLayerOptions & {
        /**
         * Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
         * @default true
         */
        stroke?: boolean;
        /**
         * Stroke color.
         * @default '#3388ff'
         */
        color?: string;
        /**
         * Stroke width in pixels.
         * @default 3
         */
        weight?: number;
        /**
         * Stroke opacity
         * @default 1
         */
        opacity?: number;
        /**
         * A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
         * @default 'round'
         */
        lineCap?: CanvasLineCap;
        /**
         * A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
         * @default 'round'
         */
        lineJoin?: CanvasLineJoin;
        /**
         * A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
         * @default null
         */
        dashArray?: string | number[] | null;
        /**
         * A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
         * @default null
         */
        dashOffset?: string | null;
        /**
         * Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
         * @default false (on polygons: true)
         */
        fill?: boolean;
        /**
         * Fill color. Defaults to the value of the [`color`](#path-color) option.
         * @default null
         */
        fillColor?: string | null;
        /**
         * Fill opacity.
         * @default 0.2
         */
        fillOpacity?: number;
        /**
         * A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
         * @default 'evenodd'
         */
        fillRule?: CanvasFillRule;
        /**
         * An optional space-separated list of CSS classes that should be added to the path's SVG element (if using an SVG renderer).
         * @default ''
         */
        className?: string;
        /**
         * An optional renderer object that should be used to render this path.
         * @default null
         */
        renderer?: RendererBase | null;
    };
    type StyleFunction = (feature?: geojson.Feature) => PathOptions;
    abstract class Path extends Layer {
        static defaultOptions: Required<PathOptions>;
        type: "Path";
        options: Required<PathOptions>;
        protected _renderer: RendererBase;
        /**
         * @internal
         */
        _path: SVGPathElement;
        abstract _pxBounds: Bounds;
        constructor(options?: PathOptions);
        /**
         * @internal
         */
        beforeAdd(map: LeafletGlMap): this;
        /**
         * @internal
         */
        onAdd(_map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(_map: LeafletGlMap): this;
        /**
         * Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
         */
        redraw(): this;
        /**
         * Changes the appearance of a Path based on the options in the `Path options` object.
         */
        setStyle(style?: LayerStyle): this;
        /**
         * Brings the layer to the top of all path layers.
         */
        bringToFront(): this;
        /**
         * Brings the layer to the bottom of all path layers.
         */
        bringToBack(): this;
        /**
         * @internal
         */
        abstract _project(): void;
        /**
         * @internal
         */
        abstract _update(): void;
        protected abstract _updateBounds(): void;
        /**
         * @internal
         */
        abstract _containsPoint(p: Point): boolean;
        /**
         * @internal
         */
        _reset(): void;
        protected _clickTolerance(): number;
    }
    type PolylineOptions = PathOptions & {
        /**
         * How much to simplify the polyline on each zoom level. More means
         * better performance and smoother look, and less means more accurate representation.
         * @default 1.0
         */
        smoothFactor?: number;
        /**
         * Disable polyline clipping.
         * @default false
         */
        noClip?: boolean;
    };
    type LatLngExpressionShape = LatLngExpression[] | LatLngExpression[][] | LatLngExpression[][][];
    type LatLngShape = LatLng[] | LatLng[][] | LatLng[][][];
    type LatLngExpressionMultiPolygonShape = LatLngExpression[][] | LatLngExpression[][][];
    class Polyline extends Path {
        static defaultOptions: Required<PolylineOptions>;
        options: Required<PolylineOptions>;
        /**
         * @internal
         */
        _parts: Point[][];
        /**
         * @internal
         */
        _latlngs: LatLng[] | LatLng[][] | LatLng[][][];
        protected _bounds: LatLngBounds;
        protected _rings: Point[][];
        _pxBounds: Bounds;
        protected _rawPxBounds: Bounds;
        constructor(latlngs: LatLngExpressionShape, options?: PolylineOptions);
        /**
         * Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
         */
        getLatLngs(): LatLngShape;
        /**
         * Replaces all the points in the polyline with the given array of geographical points.
         */
        setLatLngs(latlngs: LatLngExpressionShape): this;
        /**
         * Returns `true` if the Polyline has no LatLngs.
         */
        isEmpty(): boolean;
        /**
         * Returns the point closest to `p` on the Polyline.
         * If such a point exists, adds a `distance` member containing the closest points distance to `p`.
         */
        closestLayerPoint(p: Point): Point | undefined;
        /**
         * Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
         */
        getCenter(): LatLng;
        /**
         * Returns the `LatLngBounds` of the path.
         */
        getBounds(): LatLngBounds;
        /**
         * Adds a given point to the polyline. By default, adds to the first ring of
         * the polyline in case of a multi-polyline, but can be overridden by passing
         * a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
         */
        addLatLng(latlng: LatLngExpression, latlngs?: LatLng[]): this;
        protected _setLatLngs(latlngs: LatLngExpressionShape): void;
        protected _defaultShape(): LatLng[];
        /**
         * Recursively convert latlngs input into actual LatLng instances; calculate bounds along the way.
         */
        protected _convertLatLngs(latlngs: LatLngExpression[] | LatLngExpression[][] | LatLngExpression[][][]): LatLng[] | LatLng[][] | LatLng[][][];
        /**
         * @internal
         */
        _project(): void;
        protected _updateBounds(): void;
        /**
         * Recursively turns latlngs into a set of rings with projected coordinates.
         */
        _projectLatlngs(latlngs: LatLng[] | LatLng[][] | LatLng[][][], result: Point[][], projectedBounds: Bounds): void;
        /**
         * Clip polyline by renderer bounds so that we have less to render for performance.
         */
        protected _clipPoints(): void;
        /**
         * Simplify each clipped part of the polyline for performance.
         */
        protected _simplifyPoints(): void;
        /**
         * @internal
         */
        _update(): void;
        protected _updatePath(): void;
        /**
         * @internal
         * Needed by the `Canvas` renderer for interactivity.
         */
        _containsPoint(p: Point, closed?: boolean): boolean;
        /**
         * Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precisionDigits`.
         * Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
         */
        toGeoJSON(precisionDigits?: number): geojson.Feature;
    }
    /**
     * @deprecated
     * Instantiates a polyline object given an array of geographical points and
     * optionally an options object. You can create a `Polyline` object with
     * multiple separate lines (`MultiPolyline`) by passing an array of arrays
     * of geographic points.
     *
     * @group Factory Functions
     */
    function polyline(latlngs: LatLngExpressionShape, options?: PolylineOptions): Polyline;
    type OverlayContentBase = HTMLElement | string;
    type OverlayContent = OverlayContentBase | ((layer: Layer) => OverlayContentBase);
    type DivOverlayOptions = LayerOptions & {
        /**
         * If true, the popup/tooltip will listen to the mouse events.
         * @default false
         */
        interactive?: boolean;
        /**
         * The offset of the overlay position.
         * @default [0,0]
         */
        offset?: PointExpression | undefined;
        /**
         * A custom CSS class name to assign to the overlay.
         * @default ''
         */
        className?: string;
        /**
         * Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
         * passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
         * @default ''
         */
        content?: OverlayContent;
    };
    /**
     * Base model for {@link Popup} and {@link Tooltip}. Inherit from it for custom overlays like plugins.
     *
     * @group Internal Layers
     */
    abstract class DivOverlay extends Layer {
        static defaultOptions: Required<DivOverlayOptions>;
        options: Required<DivOverlayOptions>;
        protected _latlng: LatLng;
        /**
         * @internal
         */
        _source: Layer;
        protected _content: OverlayContent;
        protected _container: HTMLDivElement;
        protected _contentNode: HTMLDivElement;
        protected _containerLeft: number;
        protected _containerBottom: number;
        private _removeTimeout;
        /**
         * @internal
         */
        get containerId(): string | undefined;
        constructor(latlng: LatLngExpression, options?: DivOverlayOptions);
        constructor(options: DivOverlayOptions, source: Layer);
        constructor(optionsOrLatlng: DivOverlayOptions | LatLngExpression, sourceOrOptions?: Layer | DivOverlayOptions);
        /**
         * Adds the overlay to the map.
         * Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
         */
        openOn(map?: LeafletGlMap): this;
        /**
         * Closes the overlay.
         * Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
         * and `layer.closePopup()`/`.closeTooltip()`.
         */
        close(): this;
        /**
         * Opens or closes the overlay bound to layer depending on its current state.
         * Argument may be omitted only for overlay bound to layer.
         * Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
         */
        toggle(layer?: Layer): this;
        /**
         * @internal
         */
        onAdd(map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(map: LeafletGlMap): this;
        /**
         * Returns the geographical point of the overlay.
         */
        getLatLng(): LatLng;
        /**
         * Sets the geographical point where the overlay will open.
         */
        setLatLng(latlng: LatLngExpression): this;
        /**
         * Returns the content of the overlay.
         */
        getContent(): OverlayContent;
        /**
         * Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
         * The function should return a `String` or `HTMLElement` to be used in the overlay.
         */
        setContent(content: OverlayContent): this;
        /**
         * Returns the HTML container of the overlay.
         */
        getElement(): HTMLElement;
        /**
         * @internal
         */
        _addTooltipFocusListeners(tooltipLayer: Layer): void;
        /**
         * @internal
         */
        _setAriaDescribedByTooltipLayer(tooltipLayer: Layer): void;
        /**
         * @internal
         */
        getEvents(): LeafletGlEventHandlerFnMap;
        /**
         * Returns `true` when the overlay is visible on the map.
         */
        isOpen(): boolean;
        /**
         * Brings this overlay in front of other overlays (in the same map pane).
         */
        bringToFront(): this;
        /**
         * Brings this overlay to the back of other overlays (in the same map pane).
         */
        bringToBack(): this;
        /**
         * Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
         */
        private _update;
        private _prepareOpen;
        private _updateContent;
        protected _updatePosition(): void;
        protected _getAnchor(): PointExpression;
        protected abstract _containerWidth: number;
        protected abstract _initLayout(): void;
        protected abstract _updateLayout(): void;
        protected abstract _adjustPan(): void;
    }
    type Direction = "right" | "left" | "top" | "bottom" | "center" | "auto";
    type TooltipOptions = DivOverlayOptions & {
        /**
         * `Map pane` where the tooltip will be added.
         * @default 'tooltipPane'
         */
        pane?: string | undefined;
        /**
         * Optional offset of the tooltip position.
         * @default [0,0]
         */
        offset?: PointExpression | undefined;
        /**
         * Direction where to open the tooltip. Possible values are: `right`, `left`,
         * `top`, `bottom`, `center`, `auto`.
         * `auto` will dynamically switch between `right` and `left` according to the tooltip
         * position on the map.
         * @default 'auto'
         */
        direction?: Direction | undefined;
        /**
         * Whether to open the tooltip permanently or only on mouseover.
         * @default false
         */
        permanent?: boolean | undefined;
        /**
         * If true, the tooltip will follow the mouse instead of being fixed at the feature center.
         * @default false
         */
        sticky?: boolean | undefined;
        /**
         * Tooltip container opacity.
         * @default 0.9
         */
        opacity?: number | undefined;
    };
    /**
     * Used to display small texts on top of map layers.
     *
     * @group Layers
     *
     * @example
     * If you want to just bind a tooltip to marker:
     *
     * ```js
     * marker.bindTooltip("my tooltip text").openTooltip();
     * ```
     * Path overlays like polylines also have a `bindTooltip` method.
     *
     * A tooltip can be also standalone:
     *
     * ```js
     * const tooltip = new Tooltip()
     *     .setLatLng(latlng)
     *     .setContent('Hello world!<br />This is a nice tooltip.')
     *     .addTo(map);
     * ```
     * or
     * ```js
     * const tooltip = new Tooltip(latlng, {content: 'Hello world!<br />This is a nice tooltip.'})
     *     .addTo(map);
     * ```
     *
     *
     * Note about tooltip offset. Leaflet takes two options in consideration
     * for computing tooltip offsetting:
     * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
     *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
     *   move it to the bottom. Negatives will move to the left and top.
     * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
     *   should adapt this value if you use a custom icon.
     */
    class Tooltip extends DivOverlay {
        static defaultOptions: Required<TooltipOptions>;
        options: Required<TooltipOptions>;
        protected _containerWidth: number;
        constructor(latlng: LatLngExpression, options?: TooltipOptions);
        constructor(options: TooltipOptions | undefined, source: Layer);
        constructor(optionsOrLatlng?: TooltipOptions | LatLngExpression, sourceOrOptions?: Layer | TooltipOptions);
        /**
         * @internal
         */
        onAdd(map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(map: LeafletGlMap): this;
        /**
         * @internal
         */
        getEvents(): LeafletGlEventHandlerFnMap;
        protected _initLayout(): void;
        protected _updateLayout(): void;
        protected _adjustPan(): void;
        private _setPosition;
        protected _updatePosition(): void;
        setOpacity(opacity: number): this;
        protected _getAnchor(): Point;
    }
    /**
     * @deprecated
     * Instantiates a `Tooltip` object given `latlng` where the tooltip will open and an optional `options` object that describes its appearance and location.
     *
     * @group Factory Functions
     */
    function tooltip(latlng?: LatLngExpression, options?: TooltipOptions): Tooltip;
    /**
     * @deprecated
     * Instantiates a `Tooltip` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
     *
     * @group Factory Functions
     */
    function tooltip(options?: TooltipOptions, source?: Layer): Tooltip;
    type PopupOptions = DivOverlayOptions & {
        /**
         * `Map pane` where the popup will be added.
         * @default 'popupPane'
         */
        pane?: string;
        /**
         * The offset of the popup position.
         * @default [0,7]
         */
        offset?: PointExpression;
        /**
         * Max width of the popup, in pixels.
         * @default 300
         */
        maxWidth?: number;
        /**
         * Min width of the popup, in pixels.
         * @default 50
         */
        minWidth?: number;
        /**
         * If set, creates a scrollable container of the given height
         * inside a popup if its content exceeds it.
         * The scrollable container can be styled using the
         * `leaflet-popup-scrolled` CSS class selector.
         * @default null
         */
        maxHeight?: number | null;
        /**
         * Set it to `false` if you don't want the map to do panning animation
         * to fit the opened popup.
         * @default true
         */
        autoPan?: boolean;
        /**
         * The margin between the popup and the top left corner of the map
         * view after autopanning was performed.
         * @default undefined
         */
        autoPanPaddingTopLeft?: PointExpression | null;
        /**
         * The margin between the popup and the bottom right corner of the map
         * view after autopanning was performed.
         * @default undefined
         */
        autoPanPaddingBottomRight?: PointExpression | null;
        /**
         * Equivalent of setting both top left and bottom right autopan padding to the same value.
         * @default [5,5]
         */
        autoPanPadding?: PointExpression;
        /**
         * Set it to `true` if you want to prevent users from panning the popup
         * off of the screen while it is open.
         * @default false
         */
        keepInView?: boolean;
        /**
         * Controls the presence of a close button in the popup.
         * @default true
         */
        closeButton?: boolean;
        /**
         * Specifies the 'aria-label' attribute of the close button.
         * @default 'Close popup'
         */
        closeButtonLabel?: string;
        /**
         * Set it to `false` if you want to override the default behavior of
         * the popup closing when another popup is opened.
         * @default true
         */
        autoClose?: boolean;
        /**
         * Set it to `false` if you want to override the default behavior of
         * the ESC key for closing of the popup.
         * @default true
         */
        closeOnEscapeKey?: boolean;
        /**
         * Set it if you want to override the default behavior of the popup closing when user clicks
         * on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
         */
        closeOnClick?: boolean;
        /**
         * A custom CSS class name to assign to the popup.
         * @default '''
         */
        className?: string;
    };
    /**
     * Used to open popups in certain places of the map. Use {@link LeafletGlMap.openPopup} to
     * open popups while making sure that only one popup is open at one time
     * (recommended for usability), or use {@link LeafletGlMap.addLayer} to open as many as you want.
     *
     * @group Layers
     *
     * @example
     *
     * If you want to just bind a popup to marker click and then open it, it's really easy:
     *
     * ```js
     * marker.bindPopup(popupContent).openPopup();
     * ```
     * Path overlays like polylines also have a `bindPopup` method.
     *
     * A popup can be also standalone:
     *
     * ```js
     * var popup = L.popup()
     *     .setLatLng(latlng)
     *     .setContent('<p>Hello world!<br />This is a nice popup.</p>')
     *     .openOn(map);
     * ```
     * or
     * ```js
     * var popup = L.popup(latlng, {content: '<p>Hello world!<br />This is a nice popup.</p>'})
     *     .openOn(map);
     * ```
     */
    class Popup extends DivOverlay {
        static defaultOptions: Required<PopupOptions>;
        options: Required<PopupOptions>;
        protected _wrapper: HTMLDivElement;
        protected _tipContainer: HTMLDivElement;
        protected _tip: HTMLDivElement;
        protected _closeButton: HTMLAnchorElement;
        protected _autopanning: boolean;
        protected _containerWidth: number;
        constructor(latlng: LatLngExpression, options?: PopupOptions);
        constructor(options: PopupOptions, source: Layer);
        constructor(optionsOrLatlng?: PopupOptions | LatLngExpression, sourceOrOptions?: Layer | PopupOptions);
        /**
         * Adds the popup to the map and closes the previous one.
         * Alternative to `map.openPopup(popup)`.
         */
        openOn(map?: LeafletGlMap): this;
        /**
         * @internal
         */
        onAdd(map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(map: LeafletGlMap): this;
        /**
         * @internal
         */
        getEvents(): LeafletGlEventHandlerFnMap;
        protected _initLayout(): void;
        protected _updateLayout(): void;
        protected _adjustPan(): void;
        protected _getAnchor(): Point;
        toGeoJSON(precisionDigits?: number): geojson.Feature;
    }
    /**
     * @deprecated
     * Instantiates a `Popup` object given an optional `options` object
     * that describes its appearance and location and an optional `source` object
     * that is used to tag the popup with a reference to the Layer to which it refers.
     *
     * @group Factory Functions
     */
    function popup(options?: PopupOptions, source?: Layer): Popup;
    /**
     * @deprecated
     * Instantiates a `Popup` object given `latlng` where the popup will open and an optional `options` object that describes its appearance and location.
     *
     * @group Factory Functions
     */
    function popup(latlng?: LatLngExpression, options?: PopupOptions): Popup;
    /**
     * A type describing XYZ coordinates, usually of a tile.
     *
     * @group Tile Management
     */
    type Coords = {
        x: number;
        y: number;
        z: number;
    };
    type LeafletEvent = {
        type: keyof LeafletGlEventHandlerFnMap;
        popup?: any;
        target: LeafletEvented;
        sourceTarget?: LeafletEvented;
        propagatedFrom?: LeafletEvented;
        /**
         * @deprecated The same as propagatedFrom.
         */
        layer?: LeafletEvented;
        _stopped?: boolean;
    };
    type LeafletMouseEvent = LeafletEvent & {
        latlng: LatLng;
        layerPoint: Point;
        containerPoint: Point;
        originalEvent: MouseEvent & {
            target?: HTMLElement;
        };
    };
    type ErrorEventLeaf = LeafletEvent & {
        message: string;
        code: number;
    };
    type LayerEvent = LeafletEvent & {
        layer: Layer;
    };
    type LayersControlEvent = LayerEvent & {
        name: string;
    };
    type GridLayerTileEvent = LeafletEvent & {
        tile: HTMLElement;
        coords: Coords;
    };
    type GridLayerTileErrorEvent = GridLayerTileEvent & {
        error: Error;
    };
    type ResizeEvent = LeafletEvent & {
        oldSize: Point;
        newSize: Point;
    };
    type PopupEvent = LeafletEvent & {
        popup: Popup;
    };
    type TooltipEvent = LeafletEvent & {
        tooltip: Tooltip;
    };
    type DragEndEvent = LeafletEvent & {
        distance: number;
    };
    type LeafletKeyboardEvent = LeafletEvent & {
        originalEvent: KeyboardEvent & {
            target?: HTMLElement;
        };
    };
    type LeafletMoveEvent = LeafletEvent & {
        latlng?: LatLng;
        oldLatLng?: LatLng;
        originalEvent: MouseEvent & {
            target?: HTMLElement;
        };
    };
    type TileCacheEvent = LeafletEvent & {
        coords: Coords;
        tile: any;
    };
    type LeafletEventHandlerFn = (event: LeafletEvent) => void;
    type LayerEventHandlerFn = (event: LayerEvent) => void;
    type LeafletMouseEventHandlerFn = (event: LeafletMouseEvent) => void;
    type LayersControlEventHandlerFn = (event: LayersControlEvent) => void;
    type ResizeEventHandlerFn = (event: ResizeEvent) => void;
    type PopupEventHandlerFn = (event: PopupEvent) => void;
    type TooltipEventHandlerFn = (event: TooltipEvent) => void;
    type ErrorEventHandlerFn = (event: ErrorEventLeaf) => void;
    type LeafletKeyboardEventHandlerFn = (event: LeafletKeyboardEvent) => void;
    type DragEndEventHandlerFn = (event: DragEndEvent) => void;
    type GridLayerTileEventHandlerFn = (event: GridLayerTileEvent) => void;
    type GridLayerTileErrorEventHandlerFn = (event: GridLayerTileErrorEvent) => void;
    type LeafletMoveEventHandlerFn = (event: LeafletMoveEvent) => void;
    type TileCacheEventHandlerFn = (event: TileCacheEvent) => void;
    type LeafletEventHandlerFnMap = {
        baselayerchange?: LayersControlEventHandlerFn | undefined;
        overlayadd?: LayersControlEventHandlerFn | undefined;
        overlayremove?: LayersControlEventHandlerFn | undefined;
        layeradd?: LayerEventHandlerFn | undefined;
        layerremove?: LayerEventHandlerFn | undefined;
        zoomlevelschange?: LeafletEventHandlerFn | undefined;
        unload?: LeafletEventHandlerFn | undefined;
        viewreset?: LeafletEventHandlerFn | undefined;
        load?: LeafletEventHandlerFn | undefined;
        zoomstart?: LeafletEventHandlerFn | undefined;
        movestart?: LeafletEventHandlerFn | undefined;
        zoom?: LeafletEventHandlerFn | undefined;
        move?: LeafletMoveEventHandlerFn | undefined;
        zoomend?: LeafletEventHandlerFn | undefined;
        moveend?: LeafletEventHandlerFn | undefined;
        autopanstart?: LeafletEventHandlerFn | undefined;
        dragstart?: LeafletEventHandlerFn | undefined;
        drag?: LeafletMoveEventHandlerFn | undefined;
        add?: LeafletEventHandlerFn | undefined;
        remove?: LeafletEventHandlerFn | undefined;
        loading?: LeafletEventHandlerFn | undefined;
        error?: LeafletEventHandlerFn | undefined;
        update?: LeafletEventHandlerFn | undefined;
        down?: LeafletEventHandlerFn | undefined;
        predrag?: LeafletEventHandlerFn | undefined;
        resize?: ResizeEventHandlerFn | undefined;
        popupopen?: PopupEventHandlerFn | undefined;
        popupclose?: PopupEventHandlerFn | undefined;
        tooltipopen?: TooltipEventHandlerFn | undefined;
        tooltipclose?: TooltipEventHandlerFn | undefined;
        locationerror?: ErrorEventHandlerFn | undefined;
        click?: LeafletMouseEventHandlerFn | undefined;
        dblclick?: LeafletMouseEventHandlerFn | undefined;
        mousedown?: LeafletMouseEventHandlerFn | undefined;
        mouseup?: LeafletMouseEventHandlerFn | undefined;
        mouseover?: LeafletMouseEventHandlerFn | undefined;
        mouseout?: LeafletMouseEventHandlerFn | undefined;
        mousemove?: LeafletMouseEventHandlerFn | undefined;
        contextmenu?: LeafletMouseEventHandlerFn | undefined;
        preclick?: LeafletMouseEventHandlerFn | undefined;
        keypress?: LeafletKeyboardEventHandlerFn | undefined;
        keydown?: LeafletKeyboardEventHandlerFn | undefined;
        keyup?: LeafletKeyboardEventHandlerFn | undefined;
        dragend?: DragEndEventHandlerFn | undefined;
        tileunload?: GridLayerTileEventHandlerFn | undefined;
        tileloadstart?: GridLayerTileEventHandlerFn | undefined;
        tileload?: GridLayerTileEventHandlerFn | undefined;
        tileabort?: GridLayerTileEventHandlerFn | undefined;
        tileerror?: GridLayerTileErrorEventHandlerFn | undefined;
    };
    type LeafletGlEventHandlerFnMap = LeafletEventHandlerFnMap & {
        contentupdate?: LeafletEventHandlerFn | undefined;
        addpoint?: LeafletPointEventHandlerFn | undefined;
        addline?: LeafletLineEventHandlerFn | undefined;
        loaded?: LeafletEventHandlerFn | undefined;
        addlayer?: LayerEventHandlerFn | undefined;
        tileloaded?: TileCacheEventHandlerFn | undefined;
        beforetiledeleted?: TileCacheEventHandlerFn | undefined;
        alltilesloaded?: LeafletEventHandlerFn | undefined;
    };
    type LeafletGpxEventBase = LeafletEvent & {
        attributes: Record<string, string | null>;
    };
    type LeafletPointEvent = LeafletGpxEventBase & {
        point: Marker;
    };
    type LeafletLineEvent = LeafletGpxEventBase & {
        line: Polyline[];
    };
    type LeafletPointEventHandlerFn = (event: LeafletPointEvent) => void;
    type LeafletLineEventHandlerFn = (event: LeafletLineEvent) => void;
    class LeafletEvented {
        private _events;
        private _firingCount;
        private _eventParents;
        on<T extends keyof LeafletGlEventHandlerFnMap>(type: T, fn: LeafletGlEventHandlerFnMap[T], context?: object): this;
        on(eventMap: LeafletGlEventHandlerFnMap, context?: object): this;
        off<T extends keyof LeafletGlEventHandlerFnMap>(type: T, fn: LeafletGlEventHandlerFnMap[T], context?: object): this;
        off(eventMap: LeafletGlEventHandlerFnMap, context?: object): this;
        off(): this;
        /**
         * attach listener (without syntactic sugar now)
         */
        private _on;
        private _off;
        /**
         * Fires an event of the specified type. You can optionally provide a data
         * object — the first argument of the listener function will contain its
         * properties. The event can optionally be propagated to event parents.
         * The data argument may optionally include the sourceTarget property that is passed to the event.
         */
        fire(type: keyof LeafletGlEventHandlerFnMap, data?: object, propagate?: boolean): this;
        /**
         * Returns `true` if a particular event type has any listeners attached to it.
         * The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
         */
        listens(type: string, propagate?: boolean): boolean;
        listens(type: string, fn: Function, context?: object, propagate?: boolean): boolean;
        listens(type: string, fn: Function | boolean | undefined, context: object | undefined, propagate: boolean): boolean;
        private _listens;
        /**
         * Returns -1 if no such listener exists.
         */
        private _listenerIndex;
        /**
         * Behaves as `on`, except the listener will only get fired once and then removed.
         */
        once<T extends keyof LeafletGlEventHandlerFnMap>(type: T, fn: LeafletGlEventHandlerFnMap[T], context?: object): this;
        once(types: LeafletGlEventHandlerFnMap, context?: object): this;
        /**
         * Adds an event parent - an `Evented` that will receive propagated events.
         */
        addEventParent(obj: LeafletEvented): this;
        /**
         * Removes an event parent, so it will stop receiving propagated events.
         */
        removeEventParent(obj: LeafletEvented): this;
        private _propagateEvent;
    }
    type ImageOverLayerStyle = {
        opacity?: number;
    };
    type ImageOverlayOptions = LayerOptions & {
        /**
         * The opacity of the image overlay.
         * @default 1.0
         */
        opacity?: number;
        /**
         * Text for the `alt` attribute of the image (useful for accessibility).
         * @default ''
         */
        alt?: string;
        interactive?: boolean;
        /**
         * Whether the crossOrigin attribute will be added to the image.
         * If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
         * Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
         * @default undefined
         */
        crossOrigin?: string | false;
        /**
         * URL to the overlay image to show in place of the overlay that failed to load.
         * @default ''
         */
        errorOverlayUrl?: string;
        /**
         * The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
         * @default 1
         */
        zIndex?: number;
        /**
         * A custom class name to assign to the image. Empty by default.
         * @default ''
         */
        className?: string;
        /**
         * Tells the browser whether to decode the image in a synchronous fashion,
         * as per the [`decoding` HTML attribute](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decoding).
         * If the image overlay is flickering when being added/removed, set
         * this option to `'sync'`.
         * @default 'auto'
         */
        decoding?: HTMLImageElement["decoding"];
    };
    /**
     * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
     *
     * @group Layers
     *
     * @example
     *
     * ```js
     * const imageUrl = 'https://maps.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
     *     imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
     * const imageOverlay = imageOverlay(imageUrl, imageBounds).addTo(map);
     * ```
     */
    class ImageOverlay extends Layer {
        static defaultOptions: Required<ImageOverlayOptions>;
        options: Required<ImageOverlayOptions>;
        protected _url: string;
        protected _bounds: LatLngBounds;
        protected _image: HTMLImageElement;
        constructor(url: string, bounds: LatLngBoundsExpression, options?: ImageOverlayOptions);
        /**
         * @internal
         */
        onAdd(_map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(_map: LeafletGlMap): this;
        /**
         * Sets the opacity of the overlay.
         */
        setOpacity(opacity: number): this;
        setStyle(styleOpts: {
            opacity?: number;
        }): this;
        /**
         * Brings the layer to the top of all overlays.
         */
        bringToFront(): this;
        /**
         * Brings the layer to the bottom of all overlays.
         */
        bringToBack(): this;
        /**
         * Changes the URL of the image.
         */
        setUrl(url: string): this;
        /**
         * Update the bounds that this ImageOverlay covers
         */
        setBounds(bounds: LatLngBoundsExpression): this;
        /**
         * @internal
         */
        getEvents(): LeafletGlEventHandlerFnMap;
        /**
         * Changes the {@link ImageOverlayOptions.zIndex} of the image overlay.
         */
        setZIndex(value: number): this;
        /**
         * Get the bounds that this ImageOverlay covers
         */
        getBounds(): LatLngBounds;
        /**
         * Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
         * used by this overlay.
         */
        getElement(): HTMLImageElement;
        /**
         * Returns the center of the ImageOverlay.
         */
        getCenter(): LatLng;
        protected _initImage(source: string | HTMLImageElement): void;
        protected _reset(): void;
        protected _updateOpacity(): void;
        protected _updateZIndex(): void;
        protected _overlayOnError(): void;
    }
    /**
     * @deprecated
     * Instantiates an image overlay object given the URL of the image and the
     * geographical bounds it is tied to.
     *
     * @group Factory Functions
     */
    function imageOverlay(url: string, bounds: LatLngBoundsExpression, options?: ImageOverlayOptions): ImageOverlay;
    type LayerStyle = PopupOptions | StyleFunction | ImageOverLayerStyle | PathOptions;
    type LayerOptions = {
        /**
         * By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
         */
        pane?: string | null;
        /**
         * String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
         */
        attribution?: string | null;
    };
    type InteractiveLayerOptions = LayerOptions & {
        /**
         * When set to false on a Path or Marker instance, then this instance will not be interactive.
         */
        interactive?: boolean;
        /**
         * When true, a mouse event on this layer will trigger the same event on the map (unless `DomEvent.stopPropagation` is used).
         */
        bubblingMouseEvents?: boolean;
    };
    /**
     * The abstract base class of all layers.
     *
     * @group Internal Layers
     */
    abstract class Layer extends LeafletEvented {
        static defaultOptions: Required<LayerOptions>;
        options: Required<LayerOptions>;
        private _map?;
        /**
         * @internal
         * Injected from popup.ts to avoid circular dependency.
         */
        static Popup: any;
        /**
         * @internal
         * Injected from tooltip.ts to avoid circular dependency.
         */
        static Tooltip: any;
        /**
         * @internal
         */
        _popupHandlersAdded: boolean;
        /**
         * @internal
         */
        _popup: Popup | null;
        /**
         * @internal
         */
        _tooltip: Tooltip | null;
        private _tooltipHandlersAdded;
        private _moveEndOpensTooltip;
        /**
         * @internal
         * Used by geojson.
         */
        defaultOptions: Required<LayerOptions>;
        get map(): LeafletGlMap | LayerGroup | undefined;
        /**
         * @internal
         */
        set map(m: LeafletGlMap | LayerGroup | undefined);
        get leafletMap(): LeafletGlMap | undefined;
        constructor(options?: LayerOptions);
        addTo(map: LeafletGlMap | LayerGroup): this;
        /**
         * Removes the layer from the map it is currently active on.
         */
        remove(): this;
        /**
         * Removes the layer from the given map or LayerGroup.
         */
        removeFrom(map: LeafletGlMap): this;
        removeFrom(layerGroup: LayerGroup): this;
        removeFrom(obj: LeafletGlMap | LayerGroup): this;
        /**
         * Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
         */
        getPane(name?: string): HTMLElement | null;
        /**
         * @internal
         */
        addInteractiveTarget(targetEl: HTMLElement | SVGPathElement): this;
        /**
         * @internal
         */
        removeInteractiveTarget(targetEl: HTMLElement | SVGPathElement): this;
        /**
         * Optional styling function for GeoJSNON.
         */
        setStyle?(style: LayerStyle): this;
        /**
         * Optional geojson feature.
         */
        feature?: geojson.Feature | undefined;
        /**
         * Classes deriving from Layer may implement this method.
         * This optional method should return a string containing HTML to be shown on the MapLibre `Attribution control` whenever the layer is visible.
         */
        getAttribution?(): string | null;
        /**
         * @internal
         */
        _layerAdd(e: {
            target: LeafletGlMap;
        }): void;
        /**
         * @internal
         */
        _initOverlay<T extends DivOverlay, O extends DivOverlayOptions>(OverlayClass: {
            new (O: any, Layer: any): T;
        }, old: T | null, content: OverlayContent | T, options?: O): T;
        /**
         * Removes the popup previously bound with {@link bindPopup}.
         */
        unbindPopup(): this;
        /**
         * Binds a popup to the layer with the passed `content` and sets up the
         * necessary event listeners. If a `Function` is passed it will receive
         * the layer as the first argument and should return a `String` or `HTMLElement`.
         */
        bindPopup(content: OverlayContent | Popup, options?: PopupOptions): this;
        /**
         * Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
         */
        openPopup(latlng?: LatLngExpression): this;
        /**
         * Closes the popup bound to this layer if it is open.
         */
        closePopup(): this;
        /**
         * Opens or closes the popup bound to this layer depending on its current state.
         */
        togglePopup(): this;
        /**
         * Returns `true` if the popup bound to this layer is currently open.
         */
        isPopupOpen(): boolean;
        /**
         * Sets the content of the popup bound to this layer.
         */
        setPopupContent(content: OverlayContent): this;
        /**
         * Returns the popup bound to this layer.
         */
        getPopup(): Popup | null;
        /**
         * @internal
         */
        _openPopup(e: LeafletMouseEvent): void;
        /**
         * @internal
         */
        _movePopup(e: any): void;
        /**
         * @internal
         */
        _onKeyPress(e: any): void;
        /**
         * Binds a tooltip to the layer with the passed `content` and sets up the
         * necessary event listeners. If a `Function` is passed it will receive
         * the layer as the first argument and should return a `String` or `HTMLElement`.
         */
        bindTooltip(content: ((layer: Layer) => OverlayContent) | OverlayContent | Tooltip, options?: TooltipOptions): this;
        /**
         * Removes the tooltip previously bound with `bindTooltip`.
         */
        unbindTooltip(): this;
        /**
         * @internal
         */
        _initTooltipInteractions(remove?: boolean): void;
        /**
         * Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
         */
        openTooltip(latlng?: LatLng): this;
        /**
         * Closes the tooltip bound to this layer if it is open.
         */
        closeTooltip(): this;
        /**
         * Opens or closes the tooltip bound to this layer depending on its current state.
         */
        toggleTooltip(): this;
        /**
         * Returns `true` if the tooltip bound to this layer is currently open.
         */
        isTooltipOpen(): boolean;
        /**
         * Sets the content of the tooltip bound to this layer.
         */
        setTooltipContent(content: OverlayContent): this;
        /**
         * Returns the tooltip bound to this layer.
         */
        getTooltip(): Tooltip | null;
        /**
         * @internal
         */
        _addTooltipFocusListeners(_toolTip: Layer): void;
        /**
         * To be overriden in derived classes.
         * @internal
         */
        _setAriaDescribedByOnLayer(layer: Layer): void;
        /**
         * To be overriden in derived classes.
         * @internal
         */
        _setAriaDescribedByTooltipLayer(_tooltipLayer: Layer): void;
        private _openTooltip;
        private _moveTooltip;
        /**
         * @internal
         * Classes deriving from Layer should implement this method.
         * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on {@link LeafletGlMap.addLayer}.
         */
        onAdd?(map: LeafletGlMap): this;
        /**
         * @internal
         * Classes deriving from Layer should implement this method.
         * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in {@link onAdd}. Called on {@link LeafletGlMap.removelayer}.
         */
        onRemove?(map: LeafletGlMap): this;
        /**
         * @internal
         * Classes deriving from Layer may implement this method.
         * This optional method should return an object map of "event type" to "listener",
         * an object like `{ viewreset: this._reset }` for `addEventListener`.
         * The event handlers in this object will be automatically added and removed from the map with your layer.
         */
        getEvents?(): LeafletGlEventHandlerFnMap;
        /**
         * @internal
         * Classes deriving from Layer may implement this method.
         */
        beforeAdd?(map: LeafletGlMap): this;
        /**
         * Optionally implemented by child classes.
         */
        getBounds?(): LatLngBounds;
        /**
         * Optionally implemented by child classes.
         */
        getLatLng?(): LatLng;
        /**
         * Optionally implemented by child classes.
         */
        getCenter?(): LatLng;
        toGeoJSON(_precisionDigits?: number): geojson.Feature | geojson.FeatureCollection;
    }
    type CanvasPaintSpecification = {
        "raster-opacity"?: number;
    };
    type CanvasLayerOptions = LayerOptions & {
        /**
         * Layer ordering bucket id.
         */
        bucketId?: number | null;
        /**
         * The minimum zoom level down to which this layer will be displayed (inclusive).
         * Modifying this property on a layer that was already added to a map will have no effect.
         * @default 0
         */
        minZoom?: number;
        /**
         * The maximum zoom level up to which this layer will be displayed (inclusive).
         * Modifying this property on a layer that was already added to a map will have no effect.
         * @default 18
         */
        maxZoom?: number;
        /**
         * When true, canvas pixels will be 1:1 with MapLibre's internal GL pixels (and 1:1 with physical pixels).
         * Otherwise the canvas scaling ratio will be used.
         */
        forceNativePixelRatio?: boolean;
    };
    class MapLibreCanvasLayer extends StyleLayer {
        type: "canvas";
        canvasLayer: CanvasLayer;
        paint: CanvasPaintSpecification;
        constructor(id: string, canvasLayer: CanvasLayer);
    }
    /**
     * A base class for rendering arbitrary 2D canvas content as a layer.
     * The canvas is automatically copied to a WebGL texture after drawing,
     * allowing it to be composited correctly with other MapLibre WebGL-based layers.
     *
     * @group Layers
     */
    abstract class CanvasLayer extends Layer {
        static defaultOptions: Required<CanvasLayerOptions>;
        options: Required<CanvasLayerOptions>;
        protected _canvas: HTMLCanvasElement;
        private _framePending;
        private _texture;
        private _layerObject;
        private _lastRenderedArea;
        private _lastRenderedZoom;
        /**
         * @internal
         */
        lastTopLeftPixelX?: number;
        /**
         * @internal
         */
        lastTopLeftOffset?: number;
        /**
         * @internal
         */
        get lastRenderedArea(): Bounds;
        /**
         * @internal
         * The value of MapLibre map zoom when the canvas was last rendered.
         */
        get lastRenderedZoom(): number;
        /**
         * @internal
         */
        get texture(): WebGLTexture;
        get opacity(): number;
        set opacity(value: number);
        constructor(options?: CanvasLayerOptions);
        getPixelRatio(): number;
        /**
         * @internal
         */
        onAdd(map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(_map: LeafletGlMap): this;
        /**
         * Called after the constructor runs. Virtual. Optional.
         */
        protected _init(): void;
        /**
         * Called when the canvas needs to be redrawn. Place your rendering code here.
         */
        protected abstract _draw(tileZoom: number): void;
        private _getLayerId;
        private _setEvents;
        private _getGLContext;
        /**
         * Schedules a GL frame render. Once a new frame is rendered, the canvas will be redrawn using `_draw()` and uploaded to a GL texture.
         */
        protected _redraw(): void;
        private _renderFrame;
        protected _resize(): void;
        private _onResize;
        private _onMapRender;
        private _onMoveEnd;
    }
    abstract class StyleLayer extends Evented {
        id: string;
        metadata: unknown;
        type: LayerSpecification["type"] | CustomLayerInterface["type"] | MapLibreCanvasLayer["type"];
        source: string;
        sourceLayer: string;
        minzoom: number;
        maxzoom: number;
        visibility: "visible" | "none" | void;
        _crossfadeParameters: CrossfadeParameters;
        readonly onAdd: (map: MapLibreMap) => void;
        readonly onRemove: (map: MapLibreMap) => void;
        constructor(layer: LayerSpecification | CustomLayerInterface | {
            id: string;
            type: "canvas";
        });
        isHidden(zoom: number): boolean;
        recalculate(parameters: EvaluationParameters): void;
        serialize(): LayerSpecification;
        is3D(): boolean;
        isTileClipped(): boolean;
        hasOffscreenPass(): boolean;
        resize(): void;
    }
    class Color {
        readonly r: number;
        readonly g: number;
        readonly b: number;
        readonly a: number;
        /**
         * @param r Red component premultiplied by `alpha` 0..1
         * @param g Green component premultiplied by `alpha` 0..1
         * @param b Blue component premultiplied by `alpha` 0..1
         * @param [alpha=1] Alpha component 0..1
         * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
         * been multiplied by alpha. If `true` nothing happens if `false` then they will
         * be multiplied automatically.
         */
        constructor(r: number, g: number, b: number, alpha?: number, premultiplied?: boolean);
        static black: Color;
        static white: Color;
        static transparent: Color;
        static red: Color;
        /**
         * Parses CSS color strings and converts colors to sRGB color space if needed.
         * Officially supported color formats:
         * - keyword, e.g. 'aquamarine' or 'steelblue'
         * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
         * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
         * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
         *
         * @param input CSS color string to parse.
         * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
         */
        static parse(input: Color | string | undefined | null): Color | undefined;
        /**
         * Used in color interpolation and by 'to-rgba' expression.
         *
         * @returns Gien color, with reversed alpha blending, in sRGB color space.
         */
        get rgb(): RGBColor;
        /**
         * Lazy getter pattern. When getter is called for the first time lazy value
         * is calculated and then overwrites getter function in given object instance.
         *
         * @example:
         * const redColor = Color.parse('red');
         * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
         * // the value of red in HCL space and invoke this `overwriteGetter` function
         * // which in turn will set a field with a key 'hcl' in the `redColor` object.
         * // In other words it will override `get hcl()` from its `Color` prototype
         * // with its own property: hcl = [calculated red value in hcl].
         * let y = redColor.hcl; // next call will no longer invoke getter but simply
         * // return the previously calculated value
         * x === y; // true - `x` is exactly the same object as `y`
         *
         * @param getterKey Getter key
         * @param lazyValue Lazily calculated value to be memoized by current instance
         * @private
         */
        private overwriteGetter;
        /**
         * Used by 'to-string' expression.
         *
         * @returns Serialized color in format `rgba(r,g,b,a)`
         * where r,g,b are numbers within 0..255 and alpha is number within 1..0
         *
         * @example
         * var purple = new Color.parse('purple');
         * purple.toString; // = "rgba(128,0,128,1)"
         * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
         * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
         */
        toString(): string;
    }
    /**
     * @param r Red component 0..1
     * @param g Green component 0..1
     * @param b Blue component 0..1
     * @param alpha Alpha component 0..1
     */
    type RGBColor = [
        r: number,
        g: number,
        b: number,
        alpha: number
    ];
    const viewTypes: {
        Int8: Int8ArrayConstructor;
        Uint8: Uint8ArrayConstructor;
        Int16: Int16ArrayConstructor;
        Uint16: Uint16ArrayConstructor;
        Int32: Int32ArrayConstructor;
        Uint32: Uint32ArrayConstructor;
        Float32: Float32ArrayConstructor;
    };
    /**
     * @internal
     * A view type size
     */
    type ViewType = keyof typeof viewTypes;
    /**
     * @internal
     * A struct array member
     */
    type StructArrayMember = {
        name: string;
        type: ViewType;
        components: number;
        offset: number;
    };
    /**
     * An array that can be deserialized
     */
    type SerializedStructArray = {
        length: number;
        arrayBuffer: ArrayBuffer;
    };
    abstract class StructArray {
        capacity: number;
        length: number;
        isTransferred: boolean;
        arrayBuffer: ArrayBuffer;
        uint8: Uint8Array;
        members: Array<StructArrayMember>;
        bytesPerElement: number;
        abstract emplaceBack(...v: number[]): any;
        abstract emplace(i: number, ...v: number[]): any;
        constructor();
        /**
         * Serialize a StructArray instance.  Serializes both the raw data and the
         * metadata needed to reconstruct the StructArray base class during
         * deserialization.
         */
        static serialize(array: StructArray, transferables?: Array<Transferable>): SerializedStructArray;
        static deserialize(input: SerializedStructArray): any;
        /**
         * Resize the array to discard unused capacity.
         */
        _trim(): void;
        /**
         * Resets the length of the array to 0 without de-allocating capacity.
         */
        clear(): void;
        /**
         * Resize the array.
         * If `n` is greater than the current length then additional elements with undefined values are added.
         * If `n` is less than the current length then the array will be reduced to the first `n` elements.
         * @param n - The new size of the array.
         */
        resize(n: number): void;
        /**
         * Indicate a planned increase in size, so that any necessary allocation may
         * be done once, ahead of time.
         * @param n - The expected size of the array.
         */
        reserve(n: number): void;
        /**
         * Create TypedArray views for the current ArrayBuffer.
         */
        _refreshViews(): void;
    }
    class StructArrayLayout3ui6 extends StructArray {
        uint8: Uint8Array;
        uint16: Uint16Array;
        _refreshViews(): void;
        emplaceBack(v0: number, v1: number, v2: number): number;
        emplace(i: number, v0: number, v1: number, v2: number): number;
    }
    class StructArrayLayout2ui4 extends StructArray {
        uint8: Uint8Array;
        uint16: Uint16Array;
        _refreshViews(): void;
        emplaceBack(v0: number, v1: number): number;
        emplace(i: number, v0: number, v1: number): number;
    }
    class StructArrayLayout1ui2 extends StructArray {
        uint8: Uint8Array;
        uint16: Uint16Array;
        _refreshViews(): void;
        emplaceBack(v0: number): number;
        emplace(i: number, v0: number): number;
    }
    class TriangleIndexArray extends StructArrayLayout3ui6 {
    }
    class LineIndexArray extends StructArrayLayout2ui4 {
    }
    class LineStripIndexArray extends StructArrayLayout1ui2 {
    }
    class IndexBuffer {
        context: Context;
        buffer: WebGLBuffer;
        dynamicDraw: boolean;
        constructor(context: Context, array: TriangleIndexArray | LineIndexArray | LineStripIndexArray, dynamicDraw?: boolean);
        bind(): void;
        updateData(array: StructArray): void;
        destroy(): void;
    }
    type PreparedShader = {
        fragmentSource: string;
        vertexSource: string;
        staticAttributes: Array<string>;
        staticUniforms: Array<string>;
    };
    class VertexArrayObject {
        context: Context;
        boundProgram: Program<any>;
        boundLayoutVertexBuffer: VertexBuffer;
        boundIndexBuffer: IndexBuffer;
        boundVertexOffset: number;
        vao: any;
        constructor();
        bind(context: Context, program: Program<any>, layoutVertexBuffer: VertexBuffer, indexBuffer?: IndexBuffer | null, vertexOffset?: number | null): void;
        freshBind(program: Program<any>, layoutVertexBuffer: VertexBuffer, indexBuffer?: IndexBuffer | null, vertexOffset?: number | null): void;
        destroy(): void;
    }
    /**
     * @internal
     * A single segment of a vector
     */
    type Segment = {
        sortKey?: number;
        vertexOffset: number;
        primitiveOffset: number;
        vertexLength: number;
        primitiveLength: number;
        vaos: {
            [_: string]: VertexArrayObject;
        };
    };
    class SegmentVector {
        static MAX_VERTEX_ARRAY_LENGTH: number;
        segments: Array<Segment>;
        private _forceNewSegmentOnNextPrepare;
        constructor(segments?: Array<Segment>);
        /**
         * Returns the last segment if `numVertices` fits into it.
         * If there are no segments yet or `numVertices` doesn't fit into the last one, creates a new empty segment and returns it.
         */
        prepareSegment(numVertices: number, layoutVertexArray: StructArray, indexArray: StructArray, sortKey?: number): Segment;
        /**
         * Creates a new empty segment and returns it.
         */
        createNewSegment(layoutVertexArray: StructArray, indexArray: StructArray, sortKey?: number): Segment;
        /**
         * Returns the last segment, or creates a new segments if there are no segments yet.
         */
        getOrCreateLatestSegment(layoutVertexArray: StructArray, indexArray: StructArray, sortKey?: number): Segment;
        /**
         * Causes the next call to {@link prepareSegment} to always return a new segment,
         * not reusing the current segment even if the new geometry would fit it.
         */
        forceNewSegmentOnNextPrepare(): void;
        get(): Segment[];
        destroy(): void;
        static simpleSegment(vertexOffset: number, primitiveOffset: number, vertexLength: number, primitiveLength: number): SegmentVector;
    }
    type BlendFuncConstant = WebGLRenderingContextBase["ZERO"] | WebGLRenderingContextBase["ONE"] | WebGLRenderingContextBase["SRC_COLOR"] | WebGLRenderingContextBase["ONE_MINUS_SRC_COLOR"] | WebGLRenderingContextBase["DST_COLOR"] | WebGLRenderingContextBase["ONE_MINUS_DST_COLOR"] | WebGLRenderingContextBase["SRC_ALPHA"] | WebGLRenderingContextBase["ONE_MINUS_SRC_ALPHA"] | WebGLRenderingContextBase["DST_ALPHA"] | WebGLRenderingContextBase["ONE_MINUS_DST_ALPHA"] | WebGLRenderingContextBase["CONSTANT_COLOR"] | WebGLRenderingContextBase["ONE_MINUS_CONSTANT_COLOR"] | WebGLRenderingContextBase["CONSTANT_ALPHA"] | WebGLRenderingContextBase["ONE_MINUS_CONSTANT_ALPHA"] | WebGLRenderingContextBase["BLEND_COLOR"];
    type BlendFuncType = [
        BlendFuncConstant,
        BlendFuncConstant
    ];
    type BlendEquationType = WebGLRenderingContextBase["FUNC_ADD"] | WebGLRenderingContextBase["FUNC_SUBTRACT"] | WebGLRenderingContextBase["FUNC_REVERSE_SUBTRACT"];
    type ColorMaskType = [
        boolean,
        boolean,
        boolean,
        boolean
    ];
    type CompareFuncType = WebGLRenderingContextBase["NEVER"] | WebGLRenderingContextBase["LESS"] | WebGLRenderingContextBase["EQUAL"] | WebGLRenderingContextBase["LEQUAL"] | WebGLRenderingContextBase["GREATER"] | WebGLRenderingContextBase["NOTEQUAL"] | WebGLRenderingContextBase["GEQUAL"] | WebGLRenderingContextBase["ALWAYS"];
    type DepthMaskType = boolean;
    type DepthRangeType = [
        number,
        number
    ];
    type DepthFuncType = CompareFuncType;
    type StencilFuncType = {
        func: CompareFuncType;
        ref: number;
        mask: number;
    };
    type StencilOpConstant = WebGLRenderingContextBase["KEEP"] | WebGLRenderingContextBase["ZERO"] | WebGLRenderingContextBase["REPLACE"] | WebGLRenderingContextBase["INCR"] | WebGLRenderingContextBase["INCR_WRAP"] | WebGLRenderingContextBase["DECR"] | WebGLRenderingContextBase["DECR_WRAP"] | WebGLRenderingContextBase["INVERT"];
    type StencilOpType = [
        StencilOpConstant,
        StencilOpConstant,
        StencilOpConstant
    ];
    type TextureUnitType = number;
    type ViewportType = [
        number,
        number,
        number,
        number
    ];
    type StencilTestGL = {
        func: WebGLRenderingContextBase["NEVER"];
        mask: 0;
    } | {
        func: WebGLRenderingContextBase["LESS"];
        mask: number;
    } | {
        func: WebGLRenderingContextBase["EQUAL"];
        mask: number;
    } | {
        func: WebGLRenderingContextBase["LEQUAL"];
        mask: number;
    } | {
        func: WebGLRenderingContextBase["GREATER"];
        mask: number;
    } | {
        func: WebGLRenderingContextBase["NOTEQUAL"];
        mask: number;
    } | {
        func: WebGLRenderingContextBase["GEQUAL"];
        mask: number;
    } | {
        func: WebGLRenderingContextBase["ALWAYS"];
        mask: 0;
    };
    type CullFaceModeType = WebGLRenderingContextBase["FRONT"] | WebGLRenderingContextBase["BACK"] | WebGLRenderingContextBase["FRONT_AND_BACK"];
    type FrontFaceType = WebGLRenderingContextBase["CW"] | WebGLRenderingContextBase["CCW"];
    class DepthMode {
        func: DepthFuncType;
        mask: DepthMaskType;
        range: DepthRangeType;
        static ReadOnly: boolean;
        static ReadWrite: boolean;
        constructor(depthFunc: DepthFuncType, depthMask: DepthMaskType, depthRange: DepthRangeType);
        static disabled: Readonly<DepthMode>;
    }
    class StencilMode {
        test: StencilTestGL;
        ref: number;
        mask: number;
        fail: StencilOpConstant;
        depthFail: StencilOpConstant;
        pass: StencilOpConstant;
        constructor(test: StencilTestGL, ref: number, mask: number, fail: StencilOpConstant, depthFail: StencilOpConstant, pass: StencilOpConstant);
        static disabled: Readonly<StencilMode>;
    }
    class ColorMode {
        blendFunction: BlendFuncType;
        blendColor: Color;
        mask: ColorMaskType;
        constructor(blendFunction: BlendFuncType, blendColor: Color, mask: ColorMaskType);
        static Replace: BlendFuncType;
        static disabled: Readonly<ColorMode>;
        static unblended: Readonly<ColorMode>;
        static alphaBlended: Readonly<ColorMode>;
    }
    class CullFaceMode {
        enable: boolean;
        mode: CullFaceModeType;
        frontFace: FrontFaceType;
        constructor(enable: boolean, mode: CullFaceModeType, frontFace: FrontFaceType);
        static disabled: Readonly<CullFaceMode>;
        /**
         * The standard GL cull mode. Culls backfacing triangles when counterclockwise vertex order is used.
         * Use for 3D geometry such as terrain.
         */
        static backCCW: Readonly<CullFaceMode>;
        /**
         * Opposite of {@link backCCW}. Culls front-facing triangles when counterclockwise vertex order is used.
         */
        static frontCCW: Readonly<CullFaceMode>;
    }
    type $ObjMap<T extends {}, F extends (v: any) => any> = {
        [K in keyof T]: F extends (v: T[K]) => infer R ? R : never;
    };
    type UniformValues<Us extends {}> = $ObjMap<Us, <V>(u: Uniform<V>) => V>;
    type UniformLocations = {
        [_: string]: WebGLUniformLocation;
    };
    abstract class Uniform<T> {
        gl: WebGLRenderingContext | WebGL2RenderingContext;
        location: WebGLUniformLocation;
        current: T;
        constructor(context: Context, location: WebGLUniformLocation);
        abstract set(v: T): void;
    }
    class Uniform1f extends Uniform<number> {
        constructor(context: Context, location: WebGLUniformLocation);
        set(v: number): void;
    }
    class Uniform4f extends Uniform<vec4> {
        constructor(context: Context, location: WebGLUniformLocation);
        set(v: vec4): void;
    }
    class UniformMatrix4f extends Uniform<mat4> {
        constructor(context: Context, location: WebGLUniformLocation);
        set(v: mat4): void;
    }
    /**
     * @internal
     * A uniform bindings
     */
    type UniformBindings = {
        [_: string]: Uniform<any>;
    };
    type ProjectionPreludeUniformsType = {
        u_projection_matrix: UniformMatrix4f;
        u_projection_tile_mercator_coords: Uniform4f;
        u_projection_clipping_plane: Uniform4f;
        u_projection_transition: Uniform1f;
        u_projection_fallback_matrix: UniformMatrix4f;
    };
    type DrawMode = WebGLRenderingContextBase["LINES"] | WebGLRenderingContextBase["TRIANGLES"] | WebGL2RenderingContext["LINE_STRIP"];
    class Program<Us extends UniformBindings> {
        program: WebGLProgram;
        attributes: {
            [_: string]: number;
        };
        numAttributes: number;
        fixedUniforms: Us;
        projectionUniforms: ProjectionPreludeUniformsType;
        failedToCreate: boolean;
        constructor(context: Context, source: PreparedShader, fixedUniforms: (b: Context, a: UniformLocations) => Us, projectionPrelude: PreparedShader, projectionDefine: string);
        draw(context: Context, drawMode: DrawMode, depthMode: Readonly<DepthMode>, stencilMode: Readonly<StencilMode>, colorMode: Readonly<ColorMode>, cullFaceMode: Readonly<CullFaceMode>, uniformValues: UniformValues<Us>, projectionData: ProjectionData, layerID: string, layoutVertexBuffer: VertexBuffer, indexBuffer: IndexBuffer, segments: SegmentVector): void;
    }
    class VertexBuffer {
        length: number;
        attributes: ReadonlyArray<StructArrayMember>;
        itemSize: number;
        dynamicDraw: boolean;
        context: Context;
        buffer: WebGLBuffer;
        /**
         * @param dynamicDraw - Whether this buffer will be repeatedly updated.
         */
        constructor(context: Context, array: StructArray, attributes: ReadonlyArray<StructArrayMember>, dynamicDraw?: boolean);
        bind(): void;
        updateData(array: StructArray): void;
        enableAttributes(gl: WebGLRenderingContext | WebGL2RenderingContext, program: Program<any>): void;
        /**
         * Set the attribute pointers in a WebGL context
         * @param gl - The WebGL context
         * @param program - The active WebGL program
         * @param vertexOffset - Index of the starting vertex of the segment
         */
        setVertexAttribPointers(gl: WebGLRenderingContext | WebGL2RenderingContext, program: Program<any>, vertexOffset?: number | null): void;
        /**
         * Destroy the GL buffer bound to the given WebGL context
         */
        destroy(): void;
    }
    type ClearArgs = {
        color?: Color;
        depth?: number;
        stencil?: number;
    };
    class Context {
        gl: WebGLRenderingContext | WebGL2RenderingContext;
        currentNumAttributes: number;
        maxTextureSize: number;
        clearColor: ClearColor;
        clearDepth: ClearDepth;
        clearStencil: ClearStencil;
        colorMask: ColorMask;
        depthMask: DepthMask;
        stencilMask: StencilMask;
        stencilFunc: StencilFunc;
        stencilOp: StencilOp;
        stencilTest: StencilTest;
        depthRange: DepthRange;
        depthTest: DepthTest;
        depthFunc: DepthFunc;
        blend: Blend;
        blendFunc: BlendFunc;
        blendColor: BlendColor;
        blendEquation: BlendEquation;
        cullFace: CullFace;
        cullFaceSide: CullFaceSide;
        frontFace: FrontFace;
        program: ProgramValue;
        activeTexture: ActiveTextureUnit;
        viewport: Viewport;
        bindFramebuffer: BindFramebuffer;
        bindRenderbuffer: BindRenderbuffer;
        bindTexture: BindTexture;
        bindVertexBuffer: BindVertexBuffer;
        bindElementBuffer: BindElementBuffer;
        bindVertexArray: BindVertexArray;
        pixelStoreUnpack: PixelStoreUnpack;
        pixelStoreUnpackPremultiplyAlpha: PixelStoreUnpackPremultiplyAlpha;
        pixelStoreUnpackFlipY: PixelStoreUnpackFlipY;
        extTextureFilterAnisotropic: EXT_texture_filter_anisotropic | null;
        extTextureFilterAnisotropicMax?: GLfloat;
        HALF_FLOAT?: GLenum;
        RGBA16F?: GLenum;
        RGB16F?: GLenum;
        get isWebGL2(): boolean;
        private _isWebGL2;
        constructor(gl: WebGLRenderingContext | WebGL2RenderingContext);
        setDefault(): void;
        setDirty(): void;
        createIndexBuffer(array: TriangleIndexArray | LineIndexArray | LineStripIndexArray, dynamicDraw?: boolean): IndexBuffer;
        createVertexBuffer(array: StructArray, attributes: ReadonlyArray<StructArrayMember>, dynamicDraw?: boolean): VertexBuffer;
        createRenderbuffer(storageFormat: number, width: number, height: number): WebGLRenderbuffer;
        createFramebuffer(width: number, height: number, hasDepth: boolean, hasStencil: boolean): Framebuffer;
        clear({ color, depth, stencil }: ClearArgs): void;
        setCullFace(cullFaceMode: Readonly<CullFaceMode>): void;
        setDepthMode(depthMode: Readonly<DepthMode>): void;
        setStencilMode(stencilMode: Readonly<StencilMode>): void;
        setColorMode(colorMode: Readonly<ColorMode>): void;
        createVertexArray(): WebGLVertexArrayObject | undefined;
        deleteVertexArray(x: WebGLVertexArrayObject | undefined): void;
        unbindVAO(): void;
    }
    interface IValue<T> {
        current: T;
        default: T;
        dirty: boolean;
        get(): T;
        setDefault(): void;
        set(value: T): void;
    }
    class BaseValue<T> implements IValue<T> {
        gl: WebGLRenderingContext | WebGL2RenderingContext;
        current: T;
        default: T;
        dirty: boolean;
        constructor(context: Context);
        get(): T;
        set(value: T): void;
        getDefault(): T;
        setDefault(): void;
    }
    class ClearColor extends BaseValue<Color> {
        getDefault(): Color;
        set(v: Color): void;
    }
    class ClearDepth extends BaseValue<number> {
        getDefault(): number;
        set(v: number): void;
    }
    class ClearStencil extends BaseValue<number> {
        getDefault(): number;
        set(v: number): void;
    }
    class ColorMask extends BaseValue<ColorMaskType> {
        getDefault(): ColorMaskType;
        set(v: ColorMaskType): void;
    }
    class DepthMask extends BaseValue<DepthMaskType> {
        getDefault(): DepthMaskType;
        set(v: DepthMaskType): void;
    }
    class StencilMask extends BaseValue<number> {
        getDefault(): number;
        set(v: number): void;
    }
    class StencilFunc extends BaseValue<StencilFuncType> {
        getDefault(): StencilFuncType;
        set(v: StencilFuncType): void;
    }
    class StencilOp extends BaseValue<StencilOpType> {
        getDefault(): StencilOpType;
        set(v: StencilOpType): void;
    }
    class StencilTest extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    class DepthRange extends BaseValue<DepthRangeType> {
        getDefault(): DepthRangeType;
        set(v: DepthRangeType): void;
    }
    class DepthTest extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    class DepthFunc extends BaseValue<DepthFuncType> {
        getDefault(): DepthFuncType;
        set(v: DepthFuncType): void;
    }
    class Blend extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    class BlendFunc extends BaseValue<BlendFuncType> {
        getDefault(): BlendFuncType;
        set(v: BlendFuncType): void;
    }
    class BlendColor extends BaseValue<Color> {
        getDefault(): Color;
        set(v: Color): void;
    }
    class BlendEquation extends BaseValue<BlendEquationType> {
        getDefault(): BlendEquationType;
        set(v: BlendEquationType): void;
    }
    class CullFace extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    class CullFaceSide extends BaseValue<CullFaceModeType> {
        getDefault(): CullFaceModeType;
        set(v: CullFaceModeType): void;
    }
    class FrontFace extends BaseValue<FrontFaceType> {
        getDefault(): FrontFaceType;
        set(v: FrontFaceType): void;
    }
    class ProgramValue extends BaseValue<WebGLProgram> {
        getDefault(): WebGLProgram;
        set(v?: WebGLProgram | null): void;
    }
    class ActiveTextureUnit extends BaseValue<TextureUnitType> {
        getDefault(): TextureUnitType;
        set(v: TextureUnitType): void;
    }
    class Viewport extends BaseValue<ViewportType> {
        getDefault(): ViewportType;
        set(v: ViewportType): void;
    }
    class BindFramebuffer extends BaseValue<WebGLFramebuffer> {
        getDefault(): WebGLFramebuffer;
        set(v?: WebGLFramebuffer | null): void;
    }
    class BindRenderbuffer extends BaseValue<WebGLRenderbuffer> {
        getDefault(): WebGLRenderbuffer;
        set(v?: WebGLRenderbuffer | null): void;
    }
    class BindTexture extends BaseValue<WebGLTexture> {
        getDefault(): WebGLTexture;
        set(v?: WebGLTexture | null): void;
    }
    class BindVertexBuffer extends BaseValue<WebGLBuffer> {
        getDefault(): WebGLBuffer;
        set(v?: WebGLBuffer | null): void;
    }
    class BindElementBuffer extends BaseValue<WebGLBuffer> {
        getDefault(): WebGLBuffer;
        set(v?: WebGLBuffer | null): void;
    }
    class BindVertexArray extends BaseValue<WebGLVertexArrayObject | null> {
        getDefault(): WebGLVertexArrayObject | null;
        set(v: WebGLVertexArrayObject | null): void;
    }
    class PixelStoreUnpack extends BaseValue<number> {
        getDefault(): number;
        set(v: number): void;
    }
    class PixelStoreUnpackPremultiplyAlpha extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    class PixelStoreUnpackFlipY extends BaseValue<boolean> {
        getDefault(): boolean;
        set(v: boolean): void;
    }
    class FramebufferAttachment<T> extends BaseValue<T> {
        parent: WebGLFramebuffer;
        context: Context;
        constructor(context: Context, parent: WebGLFramebuffer);
        getDefault(): any;
    }
    class ColorAttachment extends FramebufferAttachment<WebGLTexture> {
        setDirty(): void;
        set(v?: WebGLTexture | null): void;
    }
    class DepthAttachment extends FramebufferAttachment<WebGLRenderbuffer> {
        set(v?: WebGLRenderbuffer | null): void;
    }
    class Framebuffer {
        context: Context;
        width: number;
        height: number;
        framebuffer: WebGLFramebuffer;
        colorAttachment: ColorAttachment;
        depthAttachment: DepthAttachment;
        constructor(context: Context, width: number, height: number, hasDepth: boolean, hasStencil: boolean);
        destroy(): void;
    }
    type Size = {
        width: number;
        height: number;
    };
    type Point2D = {
        x: number;
        y: number;
    };
    class AlphaImage {
        width: number;
        height: number;
        data: Uint8Array;
        constructor(size: Size, data?: Uint8Array | Uint8ClampedArray);
        resize(size: Size): void;
        clone(): AlphaImage;
        static copy(srcImg: AlphaImage, dstImg: AlphaImage, srcPt: Point2D, dstPt: Point2D, size: Size): void;
    }
    class RGBAImage {
        width: number;
        height: number;
        /**
         * data must be a Uint8Array instead of Uint8ClampedArray because texImage2D does not support Uint8ClampedArray in all browsers.
         */
        data: Uint8Array;
        constructor(size: Size, data?: Uint8Array | Uint8ClampedArray);
        resize(size: Size): void;
        replace(data: Uint8Array | Uint8ClampedArray, copy?: boolean): void;
        clone(): RGBAImage;
        static copy(srcImg: RGBAImage | ImageData, dstImg: RGBAImage, srcPt: Point2D, dstPt: Point2D, size: Size): void;
    }
    type TextureFormatWebGL2 = WebGL2RenderingContextBase["RG8"] | WebGL2RenderingContextBase["R8"];
    type TextureFormat = WebGLRenderingContextBase["RGBA"] | WebGLRenderingContextBase["RGB"] | WebGLRenderingContextBase["ALPHA"] | WebGLRenderingContextBase["LUMINANCE"] | TextureFormatWebGL2;
    type TextureFilter = WebGLRenderingContextBase["LINEAR"] | WebGLRenderingContextBase["LINEAR_MIPMAP_NEAREST"] | WebGLRenderingContextBase["NEAREST"];
    type TextureWrap = WebGLRenderingContextBase["REPEAT"] | WebGLRenderingContextBase["CLAMP_TO_EDGE"] | WebGLRenderingContextBase["MIRRORED_REPEAT"];
    type EmptyImage = {
        width: number;
        height: number;
        data: null;
    };
    type DataTextureImage = RGBAImage | AlphaImage | EmptyImage;
    type TextureImage = TexImageSource | DataTextureImage;
    class Texture {
        context: Context;
        size: [
            number,
            number
        ];
        texture: WebGLTexture;
        format: TextureFormat;
        filter: TextureFilter;
        wrap: TextureWrap;
        useMipmap: boolean;
        constructor(context: Context, image: TextureImage, format: TextureFormat, options?: {
            premultiply?: boolean;
            useMipmap?: boolean;
        } | null);
        /**
         * Updates texture content, can also change texture format if necessary
         */
        update(image: TextureImage, options?: {
            premultiply?: boolean;
            useMipmap?: boolean;
            format?: TextureFormat;
        } | null, position?: {
            x: number;
            y: number;
        }): void;
        bind(filter: TextureFilter, wrap: TextureWrap, minFilter?: TextureFilter | null): void;
        restoreSettings(): void;
        isSizePowerOfTwo(): boolean;
        destroy(): void;
        /**
         * Method for accessing texture format by its internal format for cases, when these two are not the same
         *  - specifically for special WebGL2 formats
         */
        textureFormatFromInternalFormat(internalFormat: TextureFormat): number;
    }
    /**
     * The tile's state, can be:
     *
     * - `loading` Tile data is in the process of loading.
     * - `loaded` Tile data has been loaded. Tile can be rendered.
     * - `reloading` Tile data has been loaded and is being updated. Tile can be rendered.
     * - `unloaded` Tile data has been deleted.
     * - `errored` Tile data was not loaded because of an error.
     * - `expired` Tile data was previously loaded, but has expired per its HTTP headers and is in the process of refreshing.
     */
    type TileState = "loading" | "loaded" | "reloading" | "unloaded" | "errored" | "expired";
    /**
     * A tile object is the combination of a Coordinate, which defines
     * its place, as well as a unique ID and data tracking for its content
     */
    class Tile {
        tileID: OverscaledTileID;
        uid: number;
        uses: number;
        tileSize: number;
        latestRawTileData: ArrayBuffer;
        expirationTime: any;
        expiredRequestCount: number;
        state: TileState;
        timeAdded: number;
        fadeEndTime: number;
        redoWhenDone: boolean;
        showCollisionBoxes: boolean;
        placementSource: any;
        neighboringTiles: any;
        aborted: boolean;
        abortController: AbortController;
        texture: Texture;
        fbo: Framebuffer;
        refreshedUponExpiration: boolean;
        reloadPromise: {
            resolve: () => void;
            reject: () => void;
        };
        resourceTiming: Array<PerformanceResourceTiming>;
        queryPadding: number;
        dependencies: any;
        /**
         * @param tileID - the tile ID
         * @param size - The tile size
         */
        constructor(tileID: OverscaledTileID, size: number);
        registerFadeDuration(duration: number): void;
        wasRequested(): boolean;
        hasData(): boolean;
        setExpiryData(data: ExpiryData): void;
        getExpiryTimeout(): number;
        setDependencies(namespace: string, dependencies: Array<string>): void;
        hasDependency(namespaces: Array<string>, keys: Array<string>): boolean;
    }
    /**
     * The `Source` interface must be implemented by each source type, including "core" types (`vector`, `raster`,
     * `video`, etc.) and all custom, third-party types.
     *
     * **Event** `data` - Fired with `{dataType: 'source', sourceDataType: 'metadata'}` to indicate that any necessary metadata
     * has been loaded so that it's okay to call `loadTile`; and with `{dataType: 'source', sourceDataType: 'content'}`
     * to indicate that the source data has changed, so that any current caches should be flushed.
     *
     * @group Sources
     */
    interface Source {
        readonly type: string;
        /**
         * The id for the source. Must not be used by any existing source.
         */
        id: string;
        /**
         * The minimum zoom level for the source.
         */
        minzoom: number;
        /**
         * The maximum zoom level for the source.
         */
        maxzoom: number;
        /**
         * The tile size for the source.
         */
        tileSize: number;
        /**
         * The attribution for the source.
         */
        attribution?: string;
        /**
         * `true` if zoom levels are rounded to the nearest integer in the source data, `false` if they are floor-ed to the nearest integer.
         */
        roundZoom?: boolean;
        /**
         * `false` if tiles can be drawn outside their boundaries, `true` if they cannot.
         */
        isTileClipped?: boolean;
        tileID?: CanonicalTileID;
        /**
         * `true` if tiles should be sent back to the worker for each overzoomed zoom level, `false` if not.
         */
        reparseOverscaled?: boolean;
        vectorLayerIds?: Array<string>;
        /**
         * True if the source has transition, false otherwise.
         */
        hasTransition(): boolean;
        /**
         * True if the source is loaded, false otherwise.
         */
        loaded(): boolean;
        /**
         * An ability to fire an event to all the listeners, see {@link Evented}
         * @param event - The event to fire
         */
        fire(event: Event): unknown;
        /**
         * This method is called when the source is added to the map.
         * @param map - The map instance
         */
        onAdd?(map: MapLibreMap): void;
        /**
         * This method is called when the source is removed from the map.
         * @param map - The map instance
         */
        onRemove?(map: MapLibreMap): void;
        /**
         * This method does the heavy lifting of loading a tile.
         * In most cases it will defer the work to the relevant worker source.
         * @param tile - The tile to load
         */
        loadTile(tile: Tile): Promise<void>;
        /**
         * True is the tile is part of the source, false otherwise.
         * @param tileID - The tile ID
         */
        hasTile?(tileID: OverscaledTileID): boolean;
        /**
         * Allows to abort a tile loading.
         * @param tile - The tile to abort
         */
        abortTile?(tile: Tile): Promise<void>;
        /**
         * Allows to unload a tile.
         * @param tile - The tile to unload
         */
        unloadTile?(tile: Tile): Promise<void>;
        /**
         * @returns A plain (stringifiable) JS object representing the current state of the source.
         * Creating a source using the returned object as the `options` should result in a Source that is
         * equivalent to this one.
         */
        serialize(): any;
        /**
         * Allows to execute a prepare step before the source is used.
         */
        prepare?(): void;
    }
    /**
     * A general definition of a {@link Source} class for factory usage
     */
    type SourceClass = {
        new (id: string, specification: RasterSourceSpecification, eventedParent: Evented): Source;
    };
    /**
     * Adds a custom source type, making it available for use with {@link MapLibreMap#addSource}.
     * @param name - The name of the source type; source definition objects use this name in the `{type: ...}` field.
     * @param SourceType - A {@link SourceClass} - which is a constructor for the `Source` interface.
     * @returns a promise that is resolved when the source type is ready or rejected with an error.
     */
    const addSourceType: (name: string, SourceType: SourceClass) => Promise<void>;
    class TileCacheMapLibre {
        max: number;
        data: {
            [key: string]: Array<{
                value: Tile;
                timeout: ReturnType<typeof setTimeout>;
            }>;
        };
        order: Array<string>;
        onRemove: (element: Tile) => void;
        /**
         * @param max - number of permitted values
         * @param onRemove - callback called with items when they expire
         */
        constructor(max: number, onRemove: (element: Tile) => void);
        /**
         * Clear the cache
         *
         * @returns this cache
         */
        reset(): this;
        /**
         * Add a key, value combination to the cache, trimming its size if this pushes
         * it over max length.
         *
         * @param tileID - lookup key for the item
         * @param data - tile data
         *
         * @returns this cache
         */
        add(tileID: OverscaledTileID, data: Tile, expiryTimeout: number | void): this;
        /**
         * Determine whether the value attached to `key` is present
         *
         * @param tileID - the key to be looked-up
         * @returns whether the cache has this value
         */
        has(tileID: OverscaledTileID): boolean;
        /**
         * Get the value attached to a specific key and remove data from cache.
         * If the key is not found, returns `null`
         *
         * @param tileID - the key to look up
         * @returns the tile data, or null if it isn't found
         */
        getAndRemove(tileID: OverscaledTileID): Tile;
        _getAndRemoveByKey(key: string): Tile;
        getByKey(key: string): Tile;
        /**
         * Get the value attached to a specific key without removing data
         * from the cache. If the key is not found, returns `null`
         *
         * @param tileID - the key to look up
         * @returns the tile data, or null if it isn't found
         */
        get(tileID: OverscaledTileID): Tile;
        /**
         * Remove a key/value combination from the cache.
         *
         * @param tileID - the key for the pair to delete
         * @param value - If a value is provided, remove that exact version of the value.
         * @returns this cache
         */
        remove(tileID: OverscaledTileID, value?: {
            value: Tile;
            timeout: ReturnType<typeof setTimeout>;
        }): this;
        /**
         * Change the max size of the cache.
         *
         * @param max - the max size of the cache
         * @returns this cache
         */
        setMaxSize(max: number): TileCacheMapLibre;
        /**
         * Remove entries that do not pass a filter function. Used for removing
         * stale tiles from the cache.
         *
         * @param filterFn - Determines whether the tile is filtered. If the supplied function returns false, the tile will be filtered out.
         */
        filter(filterFn: (tile: Tile) => boolean): void;
    }
    /**
     * An `EdgeInset` object represents screen space padding applied to the edges of the viewport.
     * This shifts the apparent center or the vanishing point of the map. This is useful for adding floating UI elements
     * on top of the map and having the vanishing point shift as UI elements resize.
     *
     * @group Geography and Geometry
     */
    class EdgeInsets {
        /**
         * @defaultValue 0
         */
        top: number;
        /**
         * @defaultValue 0
         */
        bottom: number;
        /**
         * @defaultValue 0
         */
        left: number;
        /**
         * @defaultValue 0
         */
        right: number;
        constructor(top?: number, bottom?: number, left?: number, right?: number);
        /**
         * Interpolates the inset in-place.
         * This maintains the current inset value for any inset not present in `target`.
         * @param start - interpolation start
         * @param target - interpolation target
         * @param t - interpolation step/weight
         * @returns the insets
         */
        interpolate(start: PaddingOptions | EdgeInsets, target: PaddingOptions, t: number): EdgeInsets;
        /**
         * Utility method that computes the new apprent center or vanishing point after applying insets.
         * This is in pixels and with the top left being (0.0) and +y being downwards.
         *
         * @param width - the width
         * @param height - the height
         * @returns the point
         */
        getCenter(width: number, height: number): Point;
        equals(other: PaddingOptions): boolean;
        clone(): EdgeInsets;
        /**
         * Returns the current state as json, useful when you want to have a
         * read-only representation of the inset.
         *
         * @returns state as json
         */
        toJSON(): PaddingOptions;
    }
    /**
     * Options for setting padding on calls to methods such as {@link Map#fitBounds}, {@link Map#fitScreenCoordinates}, and {@link Map#setPadding}. Adjust these options to set the amount of padding in pixels added to the edges of the canvas. Set a uniform padding on all edges or individual values for each edge. All properties of this object must be
     * non-negative integers.
     *
     * @group Geography and Geometry
     *
     * @example
     * ```ts
     * let bbox = [[-79, 43], [-73, 45]];
     * map.fitBounds(bbox, {
     *   padding: {top: 10, bottom:25, left: 15, right: 5}
     * });
     * ```
     *
     * @example
     * ```ts
     * let bbox = [[-79, 43], [-73, 45]];
     * map.fitBounds(bbox, {
     *   padding: 20
     * });
     * ```
     * @see [Fit to the bounds of a LineString](https://maplibre.org/maplibre-gl-js/docs/examples/zoomto-linestring/)
     * @see [Fit a map to a bounding box](https://maplibre.org/maplibre-gl-js/docs/examples/fitbounds/)
     */
    type PaddingOptions = {
        /**
         * Padding in pixels from the top of the map canvas.
         */
        top: number;
        /**
         * Padding in pixels from the bottom of the map canvas.
         */
        bottom: number;
        /**
         * Padding in pixels from the left of the map canvas.
         */
        right: number;
        /**
         * Padding in pixels from the right of the map canvas.
         */
        left: number;
    };
    /**
     * An event from the mouse relevant to a specific layer.
     *
     * @group Event Related
     */
    type MapLayerMouseEvent = MapMouseEvent;
    /**
     * An event from a touch device relevant to a specific layer.
     *
     * @group Event Related
     */
    type MapLayerTouchEvent = MapTouchEvent;
    /**
     * The source event data type
     */
    type MapSourceDataType = "content" | "metadata" | "visibility" | "idle";
    /**
     * `MapLayerEventType` - a mapping between the event name and the event.
     * **Note:** These events are compatible with the optional `layerId` parameter.
     * If `layerId` is included as the second argument in {@link MapLibreMap#on}, the event listener will fire only when the
     * event action contains a visible portion of the specified layer.
     * The following example can be used for all the events.
     *
     * @group Event Related
     * @example
     * ```ts
     * // Initialize the map
     * let map = new Map({ // map options });
     * // Set an event listener for a specific layer
     * map.on('the-event-name', 'poi-label', (e) => {
     *   console.log('An event has occurred on a visible portion of the poi-label layer');
     * });
     * ```
     */
    type MapLayerEventType = {
        /**
         * Fired when a pointing device (usually a mouse) is pressed and released contains a visible portion of the specified layer.
         *
         * @see [Measure distances](https://maplibre.org/maplibre-gl-js/docs/examples/measure/)
         * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
         */
        click: MapLayerMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is pressed and released twice contains a visible portion of the specified layer.
         *
         * **Note:** Under normal conditions, this event will be preceded by two `click` events.
         */
        dblclick: MapLayerMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is pressed while inside a visible portion of the specified layer.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        mousedown: MapLayerMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is released while inside a visible portion of the specified layer.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        mouseup: MapLayerMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is moved while the cursor is inside a visible portion of the specified layer.
         * As you move the cursor across the layer, the event will fire every time the cursor changes position within that layer.
         *
         * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
         * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
         * @see [Display a popup on over](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
         */
        mousemove: MapLayerMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) enters a visible portion of a specified layer from
         * outside that layer or outside the map canvas.
         *
         * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
         * @see [Display a popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
         */
        mouseenter: MapLayerMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) leaves a visible portion of a specified layer, or leaves
         * the map canvas.
         *
         * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
         * @see [Display a popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
         */
        mouseleave: MapLayerMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is moved inside a visible portion of the specified layer.
         *
         * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
         * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
         * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
         */
        mouseover: MapLayerMouseEvent;
        /**
         * Fired when a point device (usually a mouse) leaves the visible portion of the specified layer.
         */
        mouseout: MapLayerMouseEvent;
        /**
         * Fired when the right button of the mouse is clicked or the context menu key is pressed within visible portion of the specified layer.
         */
        contextmenu: MapLayerMouseEvent;
        /**
         * Fired when a [`touchstart`](https://developer.mozilla.org/en-US/docs/Web/Events/touchstart) event occurs within the visible portion of the specified layer.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        touchstart: MapLayerTouchEvent;
        /**
         * Fired when a [`touchend`](https://developer.mozilla.org/en-US/docs/Web/Events/touchend) event occurs within the visible portion of the specified layer.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        touchend: MapLayerTouchEvent;
        /**
         * Fired when a [`touchstart`](https://developer.mozilla.org/en-US/docs/Web/Events/touchstart) event occurs within the visible portion of the specified layer.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        touchcancel: MapLayerTouchEvent;
    };
    /**
     * `MapEventType` - a mapping between the event name and the event value.
     * These events are used with the {@link MapLibreMap#on} method.
     * When using a `layerId` with {@link MapLibreMap#on} method, please refer to {@link MapLayerEventType}.
     * The following example can be used for all the events.
     *
     * @group Event Related
     * @example
     * ```ts
     * // Initialize the map
     * let map = new Map({ // map options });
     * // Set an event listener
     * map.on('the-event-name', () => {
     *   console.log('An event has occurred!');
     * });
     * ```
     */
    type MapEventType = {
        /**
         * Fired when an error occurs. This is GL JS's primary error reporting
         * mechanism. We use an event instead of `throw` to better accommodate
         * asynchronous operations. If no listeners are bound to the `error` event, the
         * error will be printed to the console.
         */
        error: ErrorEvent;
        /**
         * Fired immediately after all necessary resources have been downloaded
         * and the first visually complete rendering of the map has occurred.
         *
         * @see [Draw GeoJSON points](https://maplibre.org/maplibre-gl-js/docs/examples/geojson-markers/)
         * @see [Add live realtime data](https://maplibre.org/maplibre-gl-js/docs/examples/live-geojson/)
         * @see [Animate a point](https://maplibre.org/maplibre-gl-js/docs/examples/animate-point-along-line/)
         */
        load: MapLibreEvent;
        /**
         * Fired after the last frame rendered before the map enters an
         * "idle" state:
         *
         * - No camera transitions are in progress
         * - All currently requested tiles have loaded
         * - All fade/transition animations have completed
         */
        idle: MapLibreEvent;
        /**
         * Fired immediately after the map has been removed with {@link MapLibreMap#remove}.
         */
        remove: MapLibreEvent;
        /**
         * Fired whenever the map is drawn to the screen, as the result of
         *
         * - a change to the map's position, zoom, pitch, or bearing
         * - a change to the map's style
         * - a change to a GeoJSON source
         * - the loading of a vector tile, GeoJSON file, glyph, or sprite
         */
        render: MapLibreEvent;
        /**
         * Fired immediately after the map has been resized.
         */
        resize: MapLibreEvent;
        /**
         * Fired when the WebGL context is lost.
         */
        webglcontextlost: MapContextEvent;
        /**
         * Fired when the WebGL context is restored.
         */
        webglcontextrestored: MapContextEvent;
        /**
         * Fired when any map data (style, source, tile, etc) begins loading or
         * changing asynchronously. All `dataloading` events are followed by a `data`,
         * `dataabort` or `error` event.
         */
        dataloading: MapDataEvent;
        /**
         * Fired when any map data loads or changes. See {@link MapDataEvent} for more information.
         * @see [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
         */
        data: MapDataEvent;
        tiledataloading: MapDataEvent;
        /**
         * Fired when one of the map's sources begins loading or changing asynchronously.
         * All `sourcedataloading` events are followed by a `sourcedata`, `sourcedataabort` or `error` event.
         */
        sourcedataloading: MapSourceDataEvent;
        /**
         * Fired when the map's style begins loading or changing asynchronously.
         * All `styledataloading` events are followed by a `styledata`
         * or `error` event.
         */
        styledataloading: MapStyleDataEvent;
        /**
         * Fired when one of the map's sources loads or changes, including if a tile belonging
         * to a source loads or changes.
         */
        sourcedata: MapSourceDataEvent;
        /**
         * Fired when the map's style loads or changes.
         */
        styledata: MapStyleDataEvent;
        /**
         * Fired when an icon or pattern needed by the style is missing. The missing image can
         * be added with {@link MapLibreMap#addImage} within this event listener callback to prevent the image from
         * being skipped. This event can be used to dynamically generate icons and patterns.
         * @see [Generate and add a missing icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-missing-generated/)
         */
        styleimagemissing: MapStyleImageMissingEvent;
        /**
         * Fired when a request for one of the map's sources' tiles or data is aborted.
         */
        dataabort: MapDataEvent;
        /**
         * Fired when a request for one of the map's sources' data is aborted.
         */
        sourcedataabort: MapSourceDataEvent;
        /**
         * Fired when the user cancels a "box zoom" interaction, or when the bounding box does not meet the minimum size threshold.
         * See {@link BoxZoomHandler}.
         */
        boxzoomcancel: MapLibreZoomEvent;
        /**
         * Fired when a "box zoom" interaction starts. See {@link BoxZoomHandler}.
         */
        boxzoomstart: MapLibreZoomEvent;
        /**
         * Fired when a "box zoom" interaction ends.  See {@link BoxZoomHandler}.
         */
        boxzoomend: MapLibreZoomEvent;
        /**
         * Fired when a [`touchcancel`](https://developer.mozilla.org/en-US/docs/Web/Events/touchcancel) event occurs within the map.
         */
        touchcancel: MapTouchEvent;
        /**
         * Fired when a [`touchmove`](https://developer.mozilla.org/en-US/docs/Web/Events/touchmove) event occurs within the map.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        touchmove: MapTouchEvent;
        /**
         * Fired when a [`touchend`](https://developer.mozilla.org/en-US/docs/Web/Events/touchend) event occurs within the map.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        touchend: MapTouchEvent;
        /**
         * Fired when a [`touchstart`](https://developer.mozilla.org/en-US/docs/Web/Events/touchstart) event occurs within the map.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        touchstart: MapTouchEvent;
        /**
         * Fired when a pointing device (usually a mouse) is pressed and released at the same point on the map.
         *
         * @see [Measure distances](https://maplibre.org/maplibre-gl-js/docs/examples/measure/)
         * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
         */
        click: MapMouseEvent;
        /**
         * Fired when the right button of the mouse is clicked or the context menu key is pressed within the map.
         */
        contextmenu: MapMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is pressed and released twice at the same point on the map in rapid succession.
         *
         * **Note:** Under normal conditions, this event will be preceded by two `click` events.
         */
        dblclick: MapMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is moved while the cursor is inside the map.
         * As you move the cursor across the map, the event will fire every time the cursor changes position within the map.
         *
         * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
         * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
         * @see [Display a popup on over](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
         */
        mousemove: MapMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is released within the map.
         *
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        mouseup: MapMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is pressed within the map.
         *
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        mousedown: MapMouseEvent;
        /**
         * Fired when a point device (usually a mouse) leaves the map's canvas.
         */
        mouseout: MapMouseEvent;
        /**
         * Fired when a pointing device (usually a mouse) is moved within the map.
         * As you move the cursor across a web page containing a map,
         * the event will fire each time it enters the map or any child elements.
         *
         * @see [Get coordinates of the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/mouse-position/)
         * @see [Highlight features under the mouse pointer](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
         * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
         */
        mouseover: MapMouseEvent;
        /**
         * Fired just before the map begins a transition from one
         * view to another, as the result of either user interaction or methods such as {@link MapLibreMap#jumpTo}.
         *
         */
        movestart: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        /**
         * Fired repeatedly during an animated transition from one view to
         * another, as the result of either user interaction or methods such as {@link MapLibreMap#flyTo}.
         *
         * @see [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
         */
        move: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        /**
         * Fired just after the map completes a transition from one
         * view to another, as the result of either user interaction or methods such as {@link MapLibreMap#jumpTo}.
         *
         * @see [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
         */
        moveend: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        /**
         * Fired just before the map begins a transition from one zoom level to another,
         * as the result of either user interaction or methods such as {@link MapLibreMap#flyTo}.
         */
        zoomstart: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        /**
         * Fired repeatedly during an animated transition from one zoom level to another,
         * as the result of either user interaction or methods such as {@link MapLibreMap#flyTo}.
         */
        zoom: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        /**
         * Fired just after the map completes a transition from one zoom level to another,
         * as the result of either user interaction or methods such as {@link MapLibreMap#flyTo}.
         */
        zoomend: MapLibreEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        /**
         * Fired when a "drag to rotate" interaction starts. See {@link DragRotateHandler}.
         */
        rotatestart: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired repeatedly during a "drag to rotate" interaction. See {@link DragRotateHandler}.
         */
        rotate: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired when a "drag to rotate" interaction ends. See {@link DragRotateHandler}.
         */
        rotateend: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired when a "drag to pan" interaction starts. See {@link DragPanHandler}.
         */
        dragstart: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired repeatedly during a "drag to pan" interaction. See {@link DragPanHandler}.
         */
        drag: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired when a "drag to pan" interaction ends. See {@link DragPanHandler}.
         * @see [Create a draggable marker](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-marker/)
         */
        dragend: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired whenever the map's pitch (tilt) begins a change as
         * the result of either user interaction or methods such as {@link MapLibreMap#flyTo} .
         */
        pitchstart: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired repeatedly during the map's pitch (tilt) animation between
         * one state and another as the result of either user interaction
         * or methods such as {@link MapLibreMap#flyTo}.
         */
        pitch: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired immediately after the map's pitch (tilt) finishes changing as
         * the result of either user interaction or methods such as {@link MapLibreMap#flyTo}.
         */
        pitchend: MapLibreEvent<MouseEvent | TouchEvent | undefined>;
        /**
         * Fired when a [`wheel`](https://developer.mozilla.org/en-US/docs/Web/Events/wheel) event occurs within the map.
         */
        wheel: MapWheelEvent;
        /**
         * Fired when terrain is changed
         */
        terrain: MapTerrainEvent;
        /**
         * Fired whenever the cooperativeGestures option prevents a gesture from being handled by the map.
         * This is useful for showing your own UI when this happens.
         */
        cooperativegestureprevented: MapLibreEvent<WheelEvent | TouchEvent> & {
            gestureType: "wheel_zoom" | "touch_pan";
        };
        /**
         * Fired when map's projection is modified in other ways than by map being moved.
         */
        projectiontransition: MapProjectionEvent;
    };
    /**
     * The base event for MapLibre
     *
     * @group Event Related
     */
    type MapLibreEvent<TOrig = unknown> = {
        type: keyof MapEventType | keyof MapLayerEventType;
        target: MapLibreMap;
        originalEvent: TOrig;
    };
    /**
     * The style data event
     *
     * @group Event Related
     */
    type MapStyleDataEvent = MapLibreEvent & {
        dataType: "style";
    };
    /**
     * The source data event interface
     *
     * @group Event Related
     */
    type MapSourceDataEvent = MapLibreEvent & {
        dataType: "source";
        /**
         * True if the event has a `dataType` of `source` and the source has no outstanding network requests.
         */
        isSourceLoaded: boolean;
        /**
         * The [style spec representation of the source](https://maplibre.org/maplibre-style-spec/#sources) if the event has a `dataType` of `source`.
         */
        source: SourceSpecification;
        sourceId: string;
        sourceDataType: MapSourceDataType;
        /**
         * The tile being loaded or changed, if the event has a `dataType` of `source` and
         * the event is related to loading of a tile.
         */
        tile: any;
    };
    /**
     * `MapMouseEvent` is the event type for mouse-related map events.
     *
     * @group Event Related
     *
     * @example
     * ```ts
     * // The `click` event is an example of a `MapMouseEvent`.
     * // Set up an event listener on the map.
     * map.on('click', (e) => {
     *   // The event object (e) contains information like the
     *   // coordinates of the point on the map that was clicked.
     *   console.log('A click event has occurred at ' + e.lngLat);
     * });
     * ```
     */
    class MapMouseEvent extends Event implements MapLibreEvent<MouseEvent> {
        /**
         * The event type
         */
        type: "mousedown" | "mouseup" | "click" | "dblclick" | "mousemove" | "mouseover" | "mouseenter" | "mouseleave" | "mouseout" | "contextmenu";
        /**
         * The `Map` object that fired the event.
         */
        target: MapLibreMap;
        /**
         * The DOM event which caused the map event.
         */
        originalEvent: MouseEvent;
        /**
         * The pixel coordinates of the mouse cursor, relative to the map and measured from the top left corner.
         */
        point: Point;
        /**
         * The geographic location on the map of the mouse cursor.
         */
        lngLat: LngLat;
        /**
         * Prevents subsequent default processing of the event by the map.
         *
         * Calling this method will prevent the following default map behaviors:
         *
         *   * On `mousedown` events, the behavior of {@link DragPanHandler}
         *   * On `mousedown` events, the behavior of {@link DragRotateHandler}
         *   * On `mousedown` events, the behavior of {@link BoxZoomHandler}
         *   * On `dblclick` events, the behavior of {@link DoubleClickZoomHandler}
         *
         */
        preventDefault(): void;
        /**
         * `true` if `preventDefault` has been called.
         */
        get defaultPrevented(): boolean;
        _defaultPrevented: boolean;
        constructor(type: string, map: MapLibreMap, originalEvent: MouseEvent, data?: any);
    }
    /**
     * `MapTouchEvent` is the event type for touch-related map events.
     *
     * @group Event Related
     */
    class MapTouchEvent extends Event implements MapLibreEvent<TouchEvent> {
        /**
         * The event type.
         */
        type: "touchstart" | "touchmove" | "touchend" | "touchcancel";
        /**
         * The `Map` object that fired the event.
         */
        target: MapLibreMap;
        /**
         * The DOM event which caused the map event.
         */
        originalEvent: TouchEvent;
        /**
         * The geographic location on the map of the center of the touch event points.
         */
        lngLat: LngLat;
        /**
         * The pixel coordinates of the center of the touch event points, relative to the map and measured from the top left
         * corner.
         */
        point: Point;
        /**
         * The array of pixel coordinates corresponding to a
         * [touch event's `touches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches) property.
         */
        points: Array<Point>;
        /**
         * The geographical locations on the map corresponding to a
         * [touch event's `touches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches) property.
         */
        lngLats: Array<LngLat>;
        /**
         * Prevents subsequent default processing of the event by the map.
         *
         * Calling this method will prevent the following default map behaviors:
         *
         *   * On `touchstart` events, the behavior of {@link DragPanHandler}
         *   * On `touchstart` events, the behavior of {@link TwoFingersTouchZoomRotateHandler}
         *
         */
        preventDefault(): void;
        /**
         * `true` if `preventDefault` has been called.
         */
        get defaultPrevented(): boolean;
        _defaultPrevented: boolean;
        constructor(type: string, map: MapLibreMap, originalEvent: TouchEvent);
    }
    /**
     * `MapWheelEvent` is the event type for the `wheel` map event.
     *
     * @group Event Related
     */
    class MapWheelEvent extends Event {
        /**
         * The event type.
         */
        type: "wheel";
        /**
         * The `Map` object that fired the event.
         */
        target: MapLibreMap;
        /**
         * The DOM event which caused the map event.
         */
        originalEvent: WheelEvent;
        /**
         * Prevents subsequent default processing of the event by the map.
         *
         * Calling this method will prevent the behavior of {@link ScrollZoomHandler}.
         */
        preventDefault(): void;
        /**
         * `true` if `preventDefault` has been called.
         */
        get defaultPrevented(): boolean;
        _defaultPrevented: boolean;
        /** */
        constructor(type: string, map: MapLibreMap, originalEvent: WheelEvent);
    }
    /**
     * A `MapLibreZoomEvent` is the event type for the boxzoom-related map events emitted by the {@link BoxZoomHandler}.
     *
     * @group Event Related
     */
    type MapLibreZoomEvent = {
        /**
         * The type of boxzoom event. One of `boxzoomstart`, `boxzoomend` or `boxzoomcancel`
         */
        type: "boxzoomstart" | "boxzoomend" | "boxzoomcancel";
        /**
         * The `Map` instance that triggered the event
         */
        target: MapLibreMap;
        /**
         * The DOM event that triggered the boxzoom event. Can be a `MouseEvent` or `KeyboardEvent`
         */
        originalEvent: MouseEvent;
    };
    /**
     * A `MapDataEvent` object is emitted with the `data`
     * and `dataloading` events. Possible values for
     * `dataType`s are:
     *
     * - `'source'`: The non-tile data associated with any source
     * - `'style'`: The [style](https://maplibre.org/maplibre-style-spec/) used by the map
     *
     * Possible values for `sourceDataType`s are:
     *
     * - `'metadata'`: indicates that any necessary source metadata has been loaded (such as TileJSON) and it is ok to start loading tiles
     * - `'content'`: indicates the source data has changed (such as when source.setData() has been called on GeoJSONSource)
     * - `'visibility'`: send when the source becomes used when at least one of its layers becomes visible in style sense (inside the layer's zoom range and with layout.visibility set to 'visible')
     * - `'idle'`: indicates that no new source data has been fetched (but the source has done loading)
     *
     * @group Event Related
     *
     * @example
     * ```ts
     * // The sourcedata event is an example of MapDataEvent.
     * // Set up an event listener on the map.
     * map.on('sourcedata', (e) => {
     *    if (e.isSourceLoaded) {
     *        // Do something when the source has finished loading
     *    }
     * });
     * ```
     */
    type MapDataEvent = {
        /**
         * The event type.
         */
        type: string;
        /**
         * The type of data that has changed. One of `'source'`, `'style'`.
         */
        dataType: string;
        /**
         *  Included if the event has a `dataType` of `source` and the event signals that internal data has been received or changed. Possible values are `metadata`, `content`, `visibility` and `idle`.
         */
        sourceDataType: MapSourceDataType;
    };
    /**
     * The terrain event
     *
     * @group Event Related
     */
    type MapTerrainEvent = {
        type: "terrain";
    };
    /**
     * The map projection event
     *
     * @group Event Related
     */
    type MapProjectionEvent = {
        type: "projectiontransition";
        /**
         * Specifies the name of the new projection.
         * Additionally includes 'globe-mercator' to describe globe that has internally switched to mercator.
         */
        newProjection: "mercator";
    };
    /**
     * An event related to the web gl context
     *
     * @group Event Related
     */
    type MapContextEvent = {
        type: "webglcontextlost" | "webglcontextrestored";
        originalEvent: WebGLContextEvent;
    };
    /**
     * The style image missing event
     *
     * @group Event Related
     *
     * @see [Generate and add a missing icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-missing-generated/)
     */
    type MapStyleImageMissingEvent = MapLibreEvent & {
        type: "styleimagemissing";
        id: string;
    };
    type CoveringZoomOptions = {
        /**
         * Whether to round or floor the target zoom level. If true, the value will be rounded to the closest integer. Otherwise the value will be floored.
         */
        roundZoom?: boolean;
        /**
         * Tile size, expressed in screen pixels.
         */
        tileSize: number;
    };
    type CoveringTilesOptions = CoveringZoomOptions & {
        /**
         * Smallest allowed tile zoom.
         */
        minzoom?: number;
        /**
         * Largest allowed tile zoom.
         */
        maxzoom?: number;
        /**
         * `true` if tiles should be sent back to the worker for each overzoomed zoom level, `false` if not.
         * Fill this option when computing covering tiles for a source.
         * When true, any tile at `maxzoom` level that should be overscaled to a greater zoom will have
         * its zoom set to the overscaled greater zoom. When false, such tiles will have zoom set to `maxzoom`.
         */
        reparseOverscaled?: boolean;
        /**
         * Optional scaling factor for tile AABBs. Can be used to load more tiles around the camera than are actually visible.
         */
        tileBboxScale?: number;
    };
    type TransformUpdateResult = {
        forcePlacementUpdate?: boolean;
        fireProjectionEvent?: MapProjectionEvent;
        forceSourceUpdate?: boolean;
    };
    interface ITransformGetters {
        get tileSize(): number;
        get tileZoom(): number;
        /**
         * How many times "larger" the world is compared to zoom 0. Usually computed as `pow(2, zoom)`.
         * Relevant mostly for mercator projection.
         */
        get scale(): number;
        /**
         * How many units the current world has. Computed by multiplying {@link worldSize} by {@link tileSize}.
         * Relevant mostly for mercator projection.
         */
        get worldSize(): number;
        /**
         * Gets the transform's width in pixels. Use {@link ITransform.resize} to set the transform's size.
         */
        get width(): number;
        /**
         * Gets the transform's height in pixels. Use {@link ITransform.resize} to set the transform's size.
         */
        get height(): number;
        get lngRange(): [
            number,
            number
        ];
        get latRange(): [
            number,
            number
        ];
        get minZoom(): number;
        get maxZoom(): number;
        get zoom(): number;
        get center(): LngLat;
        get minPitch(): number;
        get maxPitch(): number;
        /**
         * Roll in degrees.
         */
        get roll(): number;
        get rollInRadians(): number;
        /**
         * Pitch in degrees.
         */
        get pitch(): number;
        get pitchInRadians(): number;
        /**
         * Bearing in degrees.
         */
        get bearing(): number;
        get bearingInRadians(): number;
        /**
         * Vertical field of view in degrees.
         */
        get fov(): number;
        get fovInRadians(): number;
        get elevation(): number;
        get minElevationForCurrentTile(): number;
        get padding(): PaddingOptions;
        get unmodified(): boolean;
        get renderWorldCopies(): boolean;
    }
    /**
     * @internal
     * All the functions that may mutate a transform.
     */
    interface ITransformMutators {
        clone(): ITransform;
        apply(that: IReadonlyTransform): void;
        /**
         * Sets the transform's minimal allowed zoom level.
         * Automatically constrains the transform's zoom to the new range and recomputes internal matrices if needed.
         */
        setMinZoom(zoom: number): void;
        /**
         * Sets the transform's maximal allowed zoom level.
         * Automatically constrains the transform's zoom to the new range and recomputes internal matrices if needed.
         */
        setMaxZoom(zoom: number): void;
        /**
         * Sets the transform's minimal allowed pitch, in degrees.
         * Automatically constrains the transform's pitch to the new range and recomputes internal matrices if needed.
         */
        setMinPitch(pitch: number): void;
        /**
         * Sets the transform's maximal allowed pitch, in degrees.
         * Automatically constrains the transform's pitch to the new range and recomputes internal matrices if needed.
         */
        setMaxPitch(pitch: number): void;
        setRenderWorldCopies(renderWorldCopies: boolean): void;
        /**
         * Sets the transform's bearing, in degrees.
         * Recomputes internal matrices if needed.
         */
        setBearing(bearing: number): void;
        /**
         * Sets the transform's pitch, in degrees.
         * Recomputes internal matrices if needed.
         */
        setPitch(pitch: number): void;
        /**
         * Sets the transform's roll, in degrees.
         * Recomputes internal matrices if needed.
         */
        setRoll(roll: number): void;
        /**
         * Sets the transform's vertical field of view, in degrees.
         * Recomputes internal matrices if needed.
         */
        setFov(fov: number): void;
        /**
         * Sets the transform's zoom.
         * Automatically constrains the transform's center and zoom and recomputes internal matrices if needed.
         */
        setZoom(zoom: number): void;
        /**
         * Sets the transform's center.
         * Automatically constrains the transform's center and zoom and recomputes internal matrices if needed.
         */
        setCenter(center: LngLat): void;
        setElevation(elevation: number): void;
        setMinElevationForCurrentTile(elevation: number): void;
        setPadding(padding: PaddingOptions): void;
        /**
         * Sets the transform's width and height and recomputes internal matrices.
         */
        resize(width: number, height: number): void;
        /**
         * Helper method to update edge-insets in place
         *
         * @param start - the starting padding
         * @param target - the target padding
         * @param t - the step/weight
         */
        interpolatePadding(start: PaddingOptions, target: PaddingOptions, t: number): void;
        /**
         * Set's the transform's center so that the given point on screen is at the given world coordinates.
         * @param lnglat - Desired world coordinates of the point.
         * @param point - The screen point that should lie at the given coordinates.
         */
        setLocationAtPoint(lnglat: LngLat, point: Point): void;
        /**
         * Sets or clears the map's geographical constraints.
         * @param bounds - A {@link LngLatBounds} object describing the new geographic boundaries of the map.
         */
        setMaxBounds(bounds?: LngLatBounds | null): void;
        /**
         * @internal
         * Signals to the transform that a new frame is starting.
         * The transform might update some of its internal variables and animations based on this.
         */
        newFrameUpdate(): TransformUpdateResult;
        /**
         * @internal
         * Called before rendering to allow the transform implementation
         * to precompute data needed to render the given tiles.
         * Used in mercator transform to precompute tile matrices (posMatrix).
         * @param coords - Array of tile IDs that will be rendered.
         */
        precacheTiles(coords: Array<OverscaledTileID>): void;
    }
    /**
     * @internal
     * A variant of {@link ITransform} without any mutating functions.
     * Note that an instance of {@link IReadonlyTransform} may still be mutated
     * by code that has a reference to in under the {@link ITransform} type.
     */
    interface IReadonlyTransform extends ITransformGetters {
        /**
         * Distance from camera origin to view plane, in pixels.
         * Calculated using vertical fov and viewport height.
         * Center is considered to be in the middle of the viewport.
         */
        get cameraToCenterDistance(): number;
        get modelViewProjectionMatrix(): mat4;
        get projectionMatrix(): mat4;
        /**
         * Inverse of matrix from camera space to clip space.
         */
        get inverseProjectionMatrix(): mat4;
        get pixelsToClipSpaceMatrix(): mat4;
        get clipSpaceToPixelsMatrix(): mat4;
        get pixelsToGLUnits(): [
            number,
            number
        ];
        get centerOffset(): Point;
        /**
         * Gets the transform's width and height in pixels (viewport size). Use {@link resize} to set the transform's size.
         */
        get size(): Point;
        get rotationMatrix(): mat2;
        /**
         * The center of the screen in pixels with the top-left corner being (0,0)
         * and +y axis pointing downwards. This accounts for padding.
         */
        get centerPoint(): Point;
        /**
         * @internal
         */
        get pixelsPerMeter(): number;
        /**
         * @internal
         * Returns the camera's position transformed to be in the same space as 3D features under this transform's projection. Mostly used for globe + fill-extrusion.
         */
        get cameraPosition(): vec3;
        get nearZ(): number;
        get farZ(): number;
        /**
         * Returns if the padding params match
         *
         * @param padding - the padding to check against
         * @returns true if they are equal, false otherwise
         */
        isPaddingEqual(padding: PaddingOptions): boolean;
        /**
         * Return what zoom level of a tile source would most closely cover the tiles displayed by this transform.
         * @param options - The options, most importantly the source's tile size.
         * @returns An integer zoom level at which all tiles will be visible.
         */
        coveringZoomLevel(options: CoveringZoomOptions): number;
        /**
         * @internal
         * Return any "wrapped" copies of a given tile coordinate that are visible
         * in the current view.
         */
        getVisibleUnwrappedCoordinates(tileID: CanonicalTileID): Array<UnwrappedTileID>;
        /**
         * Returns a list of tile coordinates that when rendered cover the entire screen at an optimal detail level.
         * Tiles are ordered by ascending distance from camera.
         * @param options - Additional options - min & max zoom, terrain presence, etc.
         * @returns Array of OverscaledTileID. All OverscaledTileID instances are newly created.
         */
        coveringTiles(options: CoveringTilesOptions): Array<OverscaledTileID>;
        /**
         * @internal
         * Given a LngLat location, return the screen point that corresponds to it.
         * @param lnglat - location
         * @returns screen point
         */
        locationToScreenPoint(lnglat: LngLat): Point;
        /**
         * Given a mercator coordinate, returns its position on screen.
         */
        coordinatePoint(mercator: MercatorCoordinate): Point;
        /**
         * @internal
         * Given a point on screen, return its LngLat location.
         * @param p - screen point
         * @returns lnglat location
         */
        screenPointToLocation(p: Point): LngLat;
        /**
         * @internal
         * Given a point on screen, return its mercator coordinate.
         * @param p - the point
         * @returns lnglat
         */
        screenPointToMercatorCoordinate(p: Point): MercatorCoordinate;
        /**
         * @internal
         * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not
         * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.
         * @returns Returns a {@link LngLatBounds} object describing the map's geographical bounds.
         */
        getBounds(): LngLatBounds;
        /**
         * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.
         * @returns max bounds
         */
        getMaxBounds(): LngLatBounds | null;
        /**
         * @internal
         * Returns whether the specified screen point lies on the map.
         * May return false if, for example, the point is above the map's horizon, or if doesn't lie on the planet's surface if globe is enabled.
         * @param p - The point's coordinates.
         */
        isPointOnMapSurface(p: Point): boolean;
        /**
         * Get center lngLat and zoom to ensure that longitude and latitude bounds are respected and regions beyond the map bounds are not displayed.
         */
        getConstrained(lngLat: LngLat, zoom: number): {
            center: LngLat;
            zoom: number;
        };
        maxPitchScaleFactor(): number;
        /**
         * The camera looks at the map from a 3D (lng, lat, altitude) location. Let's use `cameraLocation`
         * as the name for the location under the camera and on the surface of the earth (lng, lat, 0).
         * `cameraPoint` is the projected position of the `cameraLocation`.
         *
         * This point is useful to us because only fill-extrusions that are between `cameraPoint` and
         * the query point on the surface of the earth can extend and intersect the query.
         *
         * When the map is not pitched the `cameraPoint` is equivalent to the center of the map because
         * the camera is right above the center of the map.
         */
        getCameraPoint(): Point;
        /**
         * The altitude of the camera above the center of the map in meters.
         */
        getCameraAltitude(): number;
        getRayDirectionFromPixel(p: Point): vec3;
        /**
         * When the map is pitched, some of the 3D features that intersect a query will not intersect
         * the query at the surface of the earth. Instead the feature may be closer and only intersect
         * the query because it extrudes into the air.
         * @param queryGeometry - For point queries, the line from the query point to the "camera point",
         * for other geometries, the envelope of the query geometry and the "camera point"
         * @returns a geometry that includes all of the original query as well as all possible ares of the
         * screen where the *base* of a visible extrusion could be.
         *
         */
        getCameraQueryGeometry(queryGeometry: Array<Point>): Array<Point>;
        /**
         * Return the distance to the camera in clip space from a LngLat.
         * This can be compared to the value from the depth buffer (terrain.depthAtPoint)
         * to determine whether a point is occluded.
         * @param lngLat - the point
         * @param elevation - the point's elevation
         * @returns depth value in clip space (between 0 and 1)
         */
        lngLatToCameraDepth(lngLat: LngLat, elevation: number): number;
        /**
         * @internal
         * Calculate the fogMatrix that, given a tile coordinate, would be used to calculate fog on the map.
         * Currently only supported in mercator projection.
         * @param unwrappedTileID - the tile ID
         */
        calculateFogMatrix(unwrappedTileID: UnwrappedTileID): mat4;
        /**
         * @internal
         * True when an animation handled by the transform is in progress,
         * requiring MapLibre to keep rendering new frames.
         */
        isRenderingDirty(): boolean;
        /**
         * @internal
         * Generates a `ProjectionData` instance to be used while rendering the supplied tile.
         * @param overscaledTileID - The ID of the current tile.
         * @param aligned - Set to true if a pixel-aligned matrix should be used, if possible (mostly used for raster tiles under mercator projection).
         */
        getProjectionData(overscaledTileID: OverscaledTileID, aligned?: boolean, ignoreTerrainMatrix?: boolean): ProjectionData;
        /**
         * @internal
         * Returns whether the supplied location is occluded in this projection.
         * For example during globe rendering a location on the backfacing side of the globe is occluded.
         */
        isLocationOccluded(lngLat: LngLat): boolean;
        /**
         * @internal
         */
        getPixelScale(): number;
        /**
         * @internal
         * Allows the projection to adjust the radius of `circle-pitch-alignment: 'map'` circles and heatmap kernels based on the map's latitude.
         * Circle radius and heatmap kernel radius is multiplied by this value.
         */
        getCircleRadiusCorrection(): number;
        /**
         * @internal
         * Allows the projection to adjust the scale of `text-pitch-alignment: 'map'` symbols's collision boxes based on the map's center and the text anchor.
         * Only affects the collision boxes (and click areas), scaling of the rendered text is mostly handled in shaders.
         * @param transform - The map's transform, with only the `center` property, describing the map's longitude and latitude.
         * @param textAnchorX - Text anchor position inside the tile, X axis.
         * @param textAnchorY - Text anchor position inside the tile, Y axis.
         * @param tileID - The tile coordinates.
         */
        getPitchedTextCorrection(textAnchorX: number, textAnchorY: number, tileID: UnwrappedTileID): number;
        /**
         * @internal
         * Returns light direction transformed to be in the same space as 3D features under this projection. Mostly used for globe + fill-extrusion.
         * @param transform - Current map transform.
         * @param dir - The light direction.
         * @returns A new vector with the transformed light direction.
         */
        transformLightDirection(dir: vec3): vec3;
        /**
         * Returns a matrix that will place, rotate and scale a model to display at the given location and altitude
         * while also being projected by the custom layer matrix.
         * This function is intended to be called from custom layers.
         * @param location - Location of the model.
         * @param altitude - Altitude of the model. May be undefined.
         */
        getMatrixForModel(location: LngLatLike, altitude?: number): mat4;
        /**
         * Return projection data such that coordinates in mercator projection in range 0..1 will get projected to the map correctly.
         */
        getProjectionDataForCustomLayer(): ProjectionData;
        /**
         * Returns a tile-specific projection matrix. Used for symbol placement fast-path for mercator transform.
         */
        getFastPathSimpleProjectionMatrix(tileID: OverscaledTileID): mat4 | undefined;
    }
    /**
     * @internal
     * The transform stores everything needed to project or otherwise transform points on a map,
     * including most of the map's view state - center, zoom, pitch, etc.
     * A transform is cloneable, which is used when a given map state must be retained for multiple frames, mostly during symbol placement.
     */
    interface ITransform extends IReadonlyTransform, ITransformMutators {
    }
    type TileResult = {
        tile: Tile;
        tileID: OverscaledTileID;
        queryGeometry: Array<Point>;
        cameraQueryGeometry: Array<Point>;
        scale: number;
    };
    type UpdateMode = "auto" | "manual";
    /**
     * @internal
     * `SourceCache` is responsible for
     *
     *  - creating an instance of `Source`
     *  - forwarding events from `Source`
     *  - caching tiles loaded from an instance of `Source`
     *  - loading the tiles needed to render a given viewport
     *  - unloading the cached tiles not needed to render a given viewport
     */
    class SourceCache extends Evented {
        id: string;
        map: MapLibreMap;
        style: Style;
        _source: Source;
        /**
         * @internal
         * signifies that the TileJSON is loaded if applicable.
         * if the source type does not come with a TileJSON, the flag signifies the
         * source data has loaded (i.e geojson has been tiled on the worker and is ready)
         */
        _sourceLoaded: boolean;
        _sourceErrored: boolean;
        _tiles: {
            [_: string]: Tile;
        };
        _prevLng: number;
        _cache: TileCacheMapLibre;
        _timers: {
            [_ in any]: ReturnType<typeof setTimeout>;
        };
        _cacheTimers: {
            [_ in any]: ReturnType<typeof setTimeout>;
        };
        _maxTileCacheSize: number;
        _maxTileCacheZoomLevels: number;
        _paused: boolean;
        _shouldReloadOnResume: boolean;
        _coveredTiles: {
            [_: string]: boolean;
        };
        transform: ITransform;
        used: boolean;
        /**
         * When true, this source will load tiles that cover the map even when the source is set to not be visible.
         */
        alwaysLoadTiles: boolean;
        tileAabbScale: number;
        usedForTerrain: boolean;
        tileSize: number;
        _loadedParentTiles: {
            [_: string]: Tile;
        };
        _loadedSiblingTiles: {
            [_: string]: Tile;
        };
        _didEmitContent: boolean;
        _updated: boolean;
        private _tileCountsByState;
        private _trackedTiles;
        private _allNeededTilesLoaded;
        private _supressTilesLoadedEvent;
        private _updateMode;
        static maxUnderzooming: number;
        static maxOverzooming: number;
        constructor(id: string, options: RasterSourceSpecification);
        get updateMode(): UpdateMode;
        set updateMode(mode: UpdateMode);
        onAdd(map: MapLibreMap): void;
        onRemove(map: MapLibreMap): void;
        /**
         * Return true if no tile data is pending, tiles will not change unless
         * an additional API call is received.
         */
        loaded(): boolean;
        /**
         * When true, all tiles this source wants to load are already either loaded or errored.
         * @returns
         */
        allNeededTilesLoaded(): boolean;
        getSource(): Source;
        pause(): void;
        resume(): void;
        _loadTile(tile: Tile, id: string, state: TileState): Promise<void>;
        _unloadTile(tile: Tile): void;
        _abortTile(tile: Tile): void;
        serialize(): any;
        prepare(): void;
        /**
         * Return all tile ids ordered with z-order, and cast to numbers
         */
        getIds(): Array<string>;
        getRenderableIds(): Array<string>;
        hasRenderableParent(tileID: OverscaledTileID): boolean;
        _isIdRenderable(id: string): boolean;
        reload(): void;
        _reloadTile(id: string, state: TileState): Promise<void>;
        _tileLoaded(tile: Tile, id: string, previousState: TileState): void;
        /**
         * For raster terrain source, backfill DEM to eliminate visible tile boundaries
         */
        _backfillDEM(tile: Tile): void;
        /**
         * Get a specific tile by TileID
         */
        getTile(tileID: OverscaledTileID): Tile;
        /**
         * Get a specific tile by id
         */
        getTileByID(id: string): Tile;
        /**
         * For a given set of tiles, retain children that are loaded and have a zoom
         * between `zoom` (exclusive) and `maxCoveringZoom` (inclusive)
         */
        _retainLoadedChildren(idealTiles: {
            [_ in any]: OverscaledTileID;
        }, zoom: number, maxCoveringZoom: number, retain: {
            [_ in any]: OverscaledTileID;
        }): void;
        /**
         * Find a loaded parent of the given tile (up to minCoveringZoom)
         */
        findLoadedParent(tileID: OverscaledTileID, minCoveringZoom: number): Tile;
        /**
         * Find a loaded sibling of the given tile
         */
        findLoadedSibling(tileID: OverscaledTileID): Tile;
        _getLoadedTile(tileID: OverscaledTileID): Tile;
        /**
         * Resizes the tile cache based on the current viewport's size
         * or the maxTileCacheSize option passed during map creation
         *
         * Larger viewports use more tiles and need larger caches. Larger viewports
         * are more likely to be found on devices with more memory and on pages where
         * the map is more important.
         */
        updateCacheSize(transform: IReadonlyTransform): void;
        handleWrapJump(lng: number): void;
        _updateCoveredAndRetainedTiles(retain: {
            [_: string]: OverscaledTileID;
        }, minCoveringZoom: number, maxCoveringZoom: number, zoom: number): void;
        /**
         * Removes tiles that are outside the viewport and adds new tiles that
         * are inside the viewport.
         */
        update(transform: ITransform): void;
        _updateRetainedTiles(idealTileIDs: Array<OverscaledTileID>, zoom: number): {
            [_: string]: OverscaledTileID;
        };
        _updateLoadedParentTileCache(): void;
        /**
         * Update the cache of loaded sibling tiles
         *
         * Sibling tiles are tiles that share the same zoom level and
         * x/y position but have different wrap values
         * Maintaining sibling tile cache allows fading from old to new tiles
         * of the same position and zoom level
         */
        _updateLoadedSiblingTileCache(): void;
        /**
         * Add a tile, given its coordinate, to the pyramid.
         */
        _addTile(tileID: OverscaledTileID): Tile;
        _setTileReloadTimer(id: string, tile: Tile): void;
        /**
         * Remove a tile, given its id, from the pyramid
         */
        _removeTile(id: string): void;
        private _tileStateUpdated;
        /** @internal */
        private _dataHandler;
        /**
         * Remove all tiles from this pyramid
         */
        clearTiles(): void;
        /**
         * Search through our current tiles and attempt to find the tiles that
         * cover the given bounds.
         * @param pointQueryGeometry - coordinates of the corners of bounding rectangle
         * @returns result items have `{tile, minX, maxX, minY, maxY}`, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.
         */
        tilesIn(pointQueryGeometry: Array<Point>, maxPitchScaleFactor: number, has3DLayer: boolean): TileResult[];
        getVisibleCoordinates(): Array<OverscaledTileID>;
        hasTransition(): boolean;
        /**
         * Sets the set of keys that the tile depends on. This allows tiles to
         * be reloaded when their dependencies change.
         */
        setDependencies(tileKey: string, namespace: string, dependencies: Array<string>): void;
        /**
         * Reloads all tiles that depend on the given keys.
         */
        reloadTilesForDependencies(namespaces: Array<string>, keys: Array<string>): void;
    }
    class Mesh {
        vertexBuffer: VertexBuffer;
        indexBuffer: IndexBuffer;
        segments: SegmentVector;
        constructor(vertexBuffer: VertexBuffer, indexBuffer: IndexBuffer, segments: SegmentVector);
        destroy(): void;
    }
    /**
     * Defines the granularity of subdivision for circles with `circle-pitch-alignment: 'map'` and for heatmap kernels.
     * More subdivision will cause circles to more closely follow the planet's surface.
     *
     * Possible values: 1, 3, 5, 7.
     * Subdivision of 1 results in a simple quad.
     */
    type CircleGranularity = 1 | 3 | 5 | 7;
    class SubdivisionGranularityExpression {
        /**
         * A tile of zoom level 0 will be subdivided to this granularity level.
         * Each subsequent zoom level will have its granularity halved.
         */
        private readonly _baseZoomGranularity;
        /**
         * No tile will have granularity level smaller than this.
         */
        private readonly _minGranularity;
        constructor(baseZoomGranularity: number, minGranularity: number);
        getGranularityForZoomLevel(zoomLevel: number): number;
    }
    class SubdivisionGranularitySetting {
        /**
         * Granularity settings used for fill and fill-extrusion layers (for fill, both polygons and their anti-aliasing outlines).
         */
        readonly fill: SubdivisionGranularityExpression;
        /**
         * Granularity used for the line layer.
         */
        readonly line: SubdivisionGranularityExpression;
        /**
         * Granularity used for geometry covering the entire tile: raster tiles, etc.
         */
        readonly tile: SubdivisionGranularityExpression;
        /**
         * Granularity used for stencil masks for tiles.
         */
        readonly stencil: SubdivisionGranularityExpression;
        /**
         * Controls the granularity of `pitch-alignment: map` circles and heatmap kernels.
         * More granular circles will more closely follow the map's surface.
         */
        readonly circle: CircleGranularity;
        constructor(options: {
            /**
             * Granularity settings used for fill and fill-extrusion layers (for fill, both polygons and their anti-aliasing outlines).
             */
            fill: SubdivisionGranularityExpression;
            /**
             * Granularity used for the line layer.
             */
            line: SubdivisionGranularityExpression;
            /**
             * Granularity used for geometry covering the entire tile: stencil masks, raster tiles, etc.
             */
            tile: SubdivisionGranularityExpression;
            /**
             * Granularity used for stencil masks for tiles.
             */
            stencil: SubdivisionGranularityExpression;
            /**
             * Controls the granularity of `pitch-alignment: map` circles and heatmap kernels.
             * More granular circles will more closely follow the map's surface.
             */
            circle: CircleGranularity;
        });
        /**
         * Granularity settings that disable subdivision altogether.
         */
        static readonly noSubdivision: SubdivisionGranularitySetting;
    }
    /**
     * Custom projections are handled both by a class which implements this `Projection` interface,
     * and a class that is derived from the `Transform` base class. What is the difference?
     *
     * The transform-derived class:
     * - should do all the heavy lifting for the projection - implement all the `project*` and `unproject*` functions, etc.
     * - must store the map's state - center, pitch, etc. - this is handled in the `Transform` base class
     * - must be cloneable - it should not create any heavy resources
     *
     * The projection-implementing class:
     * - must provide basic information and data about the projection, which is *independent of the map's state* - name, shader functions, subdivision settings, etc.
     * - must be a "singleton" - no matter how many copies of the matching Transform class exist, the Projection should always exist as a single instance (per Map)
     * - may create heavy resources that should not exist in multiple copies (projection is never cloned) - for example, see the GPU inaccuracy mitigation for globe projection
     * - must be explicitly disposed of after usage using the `destroy` function - this allows the implementing class to free any allocated resources
     */
    /**
     * @internal
     */
    type ProjectionGPUContext = {
        context: Context;
        useProgram: (name: string) => Program<any>;
    };
    /**
     * @internal
     * Specifies the usage for a square tile mesh:
     * - 'stencil' for drawing stencil masks
     * - 'raster' for drawing raster tiles, hillshade, etc.
     */
    type TileMeshUsage = "stencil" | "raster";
    /**
     * An interface the implementations of which are used internally by MapLibre to handle different projections.
     */
    interface Projection {
        /**
         * @internal
         * A short, descriptive name of this projection, such as 'mercator' or 'globe'.
         */
        get name(): "mercator";
        /**
         * @internal
         * True if this projection needs to render subdivided geometry.
         * Optimized rendering paths for non-subdivided geometry might be used throughout MapLibre.
         * The value of this property may change during runtime, for example in globe projection depending on zoom.
         */
        get useSubdivision(): boolean;
        /**
         * Name of the shader projection variant that should be used for this projection.
         * Note that this value may change dynamically, for example when globe projection internally transitions to mercator.
         * Then globe projection might start reporting the mercator shader variant name to make MapLibre use faster mercator shaders.
         */
        get shaderVariantName(): string;
        /**
         * A `#define` macro that is injected into every MapLibre shader that uses this projection.
         * @example
         * `const define = projection.shaderDefine; // '#define GLOBE'`
         */
        get shaderDefine(): string;
        /**
         * @internal
         * A preprocessed prelude code for both vertex and fragment shaders.
         */
        get shaderPreludeCode(): PreparedShader;
        /**
         * Vertex shader code that is injected into every MapLibre vertex shader that uses this projection.
         */
        get vertexShaderPreludeCode(): string;
        /**
         * @internal
         * An object describing how much subdivision should be applied to rendered geometry.
         * The subdivision settings should be a constant for a given projection.
         * Projections that do not require subdivision should return {@link SubdivisionGranularitySetting.noSubdivision}.
         */
        get subdivisionGranularity(): SubdivisionGranularitySetting;
        /**
         * @internal
         * Cleans up any resources the projection created, especially GPU buffers.
         */
        destroy(): void;
        /**
         * @internal
         * True when an animation handled by the projection is in progress,
         * requiring MapLibre to keep rendering new frames.
         */
        isRenderingDirty(): boolean;
        /**
         * @internal
         * Runs any GPU-side tasks this projection required. Called at the beginning of every frame.
         */
        updateGPUdependent(renderContext: ProjectionGPUContext): void;
        /**
         * @internal
         * Returns a subdivided mesh for a given tile ID, covering 0..EXTENT range.
         * @param context - WebGL context.
         * @param tileID - The tile coordinates for which to return a mesh. Meshes for tiles that border the top/bottom mercator edge might include extra geometry for the north/south pole.
         * @param hasBorder - When true, the mesh will also include a small border beyond the 0..EXTENT range.
         * @param allowPoles - When true, the mesh will also include geometry to cover the north (south) pole, if the given tileID borders the mercator range's top (bottom) edge.
         * @param usage - Specify the usage of the tile mesh, as different usages might use different levels of subdivision.
         */
        getMeshFromTileID(context: Context, tileID: CanonicalTileID, hasBorder: boolean, allowPoles: boolean, usage: TileMeshUsage): Mesh;
    }
    type RasterPaintSpecification = {
        "raster-opacity"?: number;
    };
    type CoordsType = Coords;
    type PreRenderRasterTileCallback = (gl: WebGL2RenderingContext | WebGLRenderingContext, program: WebGLProgram, tileCoords: CoordsType, layerId: string) => void;
    type PostRenderRasterTileCallback = (gl: WebGL2RenderingContext | WebGLRenderingContext, tileCoords: CoordsType) => void;
    type CustomTileShaderSpec = {
        pixelTransform: string;
    };
    type RasterLayerCustomShaderSpecification = RasterLayerSpecification & {
        customShader?: CustomTileShaderSpec;
        tileFilter?: TextureFilter;
        preRenderTileCallback?: PreRenderRasterTileCallback;
        postRenderTileCallback?: PostRenderRasterTileCallback;
    };
    class RasterStyleLayer extends StyleLayer {
        paint: RasterPaintSpecification;
        customShaderId?: string;
        /**
         * Optional texture filter mode which overrides default GL.LINEAR
         */
        tileFilter?: TextureFilter;
        /**
         * Callback called right before any custom raster tile is rendered
         */
        preRenderTileCallback?: PreRenderRasterTileCallback;
        /**
         * Callback called right after any custom raster tile is rendered
         */
        postRenderTileCallback?: PostRenderRasterTileCallback;
        constructor(layer: LayerSpecification);
    }
    /**
     * The options object related to the {@link MapLibreMap}'s style related methods
     */
    type StyleOptions = {
        /**
         * If false, style validation will be skipped. Useful in production environment.
         */
        validate?: boolean;
        /**
         * Defines a CSS
         * font-family for locally overriding generation of Chinese, Japanese, and Korean characters.
         * For these characters, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).
         * Set to `false`, to enable font settings from the map's style for these glyph ranges.
         * Forces a full update.
         */
        localIdeographFontFamily?: string | false;
    };
    /**
     * Supporting type to add validation to another style related type
     */
    type StyleSetterOptions = {
        /**
         * Whether to check if the filter conforms to the MapLibre Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.
         */
        validate?: boolean;
    };
    /**
     * Part of {@link MapLibreMap#setStyle} options, transformStyle is a convenience function that allows to modify a style after it is fetched but before it is committed to the map state.
     *
     * This function exposes previous and next styles, it can be commonly used to support a range of functionalities like:
     *
     * - when previous style carries certain 'state' that needs to be carried over to a new style gracefully;
     * - when a desired style is a certain combination of previous and incoming style;
     * - when an incoming style requires modification based on external state.
     *
     * @param previous - The current style.
     * @param next - The next style.
     * @returns resulting style that will to be applied to the map
     *
     * @example
     * ```ts
     * map.setStyle('https://demotiles.maplibre.org/style.json', {
     *   transformStyle: (previousStyle, nextStyle) => ({
     *       ...nextStyle,
     *       sources: {
     *           ...nextStyle.sources,
     *           // copy a source from previous style
     *           'osm': previousStyle.sources.osm
     *       },
     *       layers: [
     *           // background layer
     *           nextStyle.layers[0],
     *           // copy a layer from previous style
     *           previousStyle.layers[0],
     *           // other layers from the next style
     *           ...nextStyle.layers.slice(1).map(layer => {
     *               // hide the layers we don't need from demotiles style
     *               if (layer.id.startsWith('geolines')) {
     *                   layer.layout = {...layer.layout || {}, visibility: 'none'};
     *               // filter out US polygons
     *               } else if (layer.id.startsWith('coastline') || layer.id.startsWith('countries')) {
     *                   layer.filter = ['!=', ['get', 'ADM0_A3'], 'USA'];
     *               }
     *               return layer;
     *           })
     *       ]
     *   })
     * });
     * ```
     */
    type TransformStyleFunction = (previous: StyleSpecification | undefined, next: StyleSpecification) => StyleSpecification;
    /**
     * The options object related to the {@link MapLibreMap}'s style related methods
     */
    type StyleSwapOptions = {
        /**
         * If false, force a 'full' update, removing the current style
         * and building the given one instead of attempting a diff-based update.
         */
        diff?: boolean;
        /**
         * TransformStyleFunction is a convenience function
         * that allows to modify a style after it is fetched but before it is committed to the map state. Refer to {@link TransformStyleFunction}.
         */
        transformStyle?: TransformStyleFunction;
    };
    /**
     * Specifies a layer to be added to a {@link Style}. In addition to a standard {@link LayerSpecification}
     * or a {@link CustomLayerInterface}, a {@link LayerSpecification} with an embedded {@link SourceSpecification} can also be provided.
     */
    type AddLayerObject = LayerSpecification | (Omit<LayerSpecification, "source"> & {
        source: SourceSpecification;
    }) | CustomLayerInterface | RasterLayerCustomShaderSpecification | MapLibreCanvasLayer;
    /**
     * The Style base class
     */
    class Style extends Evented {
        map: MapLibreMap;
        stylesheet: StyleSpecification;
        projection: Projection;
        _frameRequest: AbortController;
        _loadStyleRequest: AbortController;
        _spriteRequest: AbortController;
        _layers: {
            [_: string]: StyleLayer;
        };
        _serializedLayers: {
            [_: string]: LayerSpecification;
        };
        _order: Array<string>;
        sourceCaches: {
            [_: string]: SourceCache;
        };
        zoomHistory: ZoomHistory;
        _loaded: boolean;
        _changed: boolean;
        _updatedSources: {
            [_: string]: "clear" | "reload";
        };
        _updatedLayers: {
            [_: string]: true;
        };
        _removedLayers: {
            [_: string]: StyleLayer;
        };
        _changedImages: {
            [_: string]: true;
        };
        _glyphsDidChange: boolean;
        _layerOrderChanged: boolean;
        _spritesImagesIds: {
            [spriteId: string]: string[];
        };
        z: number;
        constructor(map: MapLibreMap);
        loadURL(url: string, options?: StyleSwapOptions & StyleSetterOptions, previousStyle?: StyleSpecification): void;
        loadJSON(json: StyleSpecification, options?: StyleSetterOptions & StyleSwapOptions, previousStyle?: StyleSpecification): void;
        loadEmpty(): void;
        _load(json: StyleSpecification, options: StyleSwapOptions & StyleSetterOptions, previousStyle?: StyleSpecification): void;
        private _createLayers;
        _validateLayer(layer: StyleLayer): void;
        loaded(): boolean;
        /**
         * @hidden
         * take an array of string IDs, and based on this._layers, generate an array of LayerSpecification
         * @param ids - an array of string IDs, for which serialized layers will be generated. If omitted, all serialized layers will be returned
         * @param returnClose - if true, return a clone of the layer object
         * @returns generated result
         */
        private _serializeByIds;
        /**
         * @hidden
         * Lazy initialization of this._serializedLayers dictionary and return it
         * @returns this._serializedLayers dictionary
         */
        private _serializedAllLayers;
        hasTransitions(): boolean;
        _checkLoaded(): void;
        /**
         * @internal
         * Apply queued style updates in a batch and recalculate zoom-dependent paint properties.
         */
        update(parameters: EvaluationParameters): void;
        _resetUpdates(): void;
        /**
         * Update this style's state to match the given style JSON, performing only
         * the necessary mutations.
         *
         * May throw an Error ('Unimplemented: METHOD') if the mapbox-gl-style-spec
         * diff algorithm produces an operation that is not supported.
         *
         * @returns true if any changes were made; false otherwise
         */
        setState(nextState: StyleSpecification, options?: StyleSwapOptions & StyleSetterOptions): boolean;
        _getOperationsToPerform(diff: DiffCommand<DiffOperations>[]): {
            operations: Function[];
            unimplemented: string[];
        };
        addSource(id: string, source: SourceSpecification, options?: StyleSetterOptions): void;
        /**
         * Remove a source from this stylesheet, given its id.
         * @param id - id of the source to remove
         * @throws if no source is found with the given ID
         */
        removeSource(id: string): this;
        /**
         * Get a source by ID.
         * @param id - ID of the desired source
         * @returns source
         */
        getSource(id: string): Source | undefined;
        /**
         * Add a layer to the map style. The layer will be inserted before the layer with
         * ID `before`, or appended if `before` is omitted.
         * @param layerObject - The style layer to add.
         * @param before - ID of an existing layer to insert before
         * @param options - Style setter options.
         */
        addLayer(layerObject: AddLayerObject, before?: string, options?: StyleSetterOptions): this;
        /**
         * Moves a layer to a different z-position. The layer will be inserted before the layer with
         * ID `before`, or appended if `before` is omitted.
         * @param id - ID of the layer to move
         * @param before - ID of an existing layer to insert before
         */
        moveLayer(id: string, before?: string): void;
        /**
         * Remove the layer with the given id from the style.
         * A {@link ErrorEvent} event will be fired if no such layer exists.
         *
         * @param id - id of the layer to remove
         */
        removeLayer(id: string): void;
        /**
         * Return the style layer object with the given `id`.
         *
         * @param id - id of the desired layer
         * @returns a layer, if one with the given `id` exists
         */
        getLayer(id: string): StyleLayer | undefined;
        /**
         * Return the ids of all layers currently in the style, including custom layers, in order.
         *
         * @returns ids of layers, in order
         */
        getLayersOrder(): string[];
        /**
         * Checks if a specific layer is present within the style.
         *
         * @param id - the id of the desired layer
         * @returns a boolean specifying if the given layer is present
         */
        hasLayer(id: string): boolean;
        setLayerZoomRange(layerId: string, minzoom?: number | null, maxzoom?: number | null): void;
        getTransition(): {
            duration: number;
            delay: number;
        } & TransitionSpecification;
        serialize(): StyleSpecification | undefined;
        _updateLayer(layer: StyleLayer): void;
        _setProjectionInternal(name: "mercator"): void;
        _remove(): void;
        _clearSource(id: string): void;
        _reloadSource(id: string): void;
        _updateSources(transform: ITransform): void;
    }
    type RenderPass = "offscreen" | "opaque" | "translucent";
    type PainterOptions = {
        showTileBoundaries: boolean;
        showPadding: boolean;
        rotating: boolean;
        zooming: boolean;
        moving: boolean;
        fadeDuration: number;
    };
    class Painter {
        context: Context;
        transform: IReadonlyTransform;
        _tileTextures: {
            [_: number]: Array<Texture>;
        };
        numSublayers: number;
        depthEpsilon: number;
        width: number;
        height: number;
        pixelRatio: number;
        debugBuffer: VertexBuffer;
        debugSegments: SegmentVector;
        viewportBuffer: VertexBuffer;
        viewportSegments: SegmentVector;
        quadTriangleIndexBuffer: IndexBuffer;
        tileBorderIndexBuffer: IndexBuffer;
        _tileClippingMaskIDs: {
            [_: string]: number;
        };
        stencilClearMode: StencilMode;
        style: Style;
        options: PainterOptions;
        depthRangeFor3D: DepthRangeType;
        opaquePassCutoff: number;
        renderPass: RenderPass;
        currentLayer: number;
        currentStencilSource: string;
        nextStencilID: number;
        id: string;
        cache: {
            [_: string]: Program<any>;
        };
        debugOverlayTexture: Texture;
        debugOverlayCanvas: HTMLCanvasElement;
        constructor(gl: WebGLRenderingContext | WebGL2RenderingContext, transform: IReadonlyTransform);
        resize(width: number, height: number, pixelRatio: number): void;
        setup(): void;
        clearStencil(): void;
        _renderTileClippingMasks(layer: StyleLayer, tileIDs: Array<OverscaledTileID>, renderToTexture: boolean): void;
        _renderTileMasks(tileStencilRefs: {
            [_: string]: number;
        }, tileIDs: Array<OverscaledTileID>, renderToTexture: boolean, useBorders: boolean): void;
        /**
         * Fills the depth buffer with the geometry of all supplied tiles.
         * Does not change the color buffer or the stencil buffer.
         */
        _renderTilesDepthBuffer(): void;
        stencilModeFor3D(): StencilMode;
        stencilModeForClipping(tileID: OverscaledTileID): StencilMode;
        stencilConfigForOverlap(tileIDs: Array<OverscaledTileID>): [
            {
                [_: number]: Readonly<StencilMode>;
            },
            Array<OverscaledTileID>
        ];
        stencilConfigForOverlapTwoPass(tileIDs: Array<OverscaledTileID>): [
            {
                [_: number]: Readonly<StencilMode>;
            },
            {
                [_: number]: Readonly<StencilMode>;
            },
            Array<OverscaledTileID>
        ];
        colorModeForRenderPass(): Readonly<ColorMode>;
        getDepthModeForSublayer(n: number, mask: DepthMaskType, func?: DepthFuncType | null): Readonly<DepthMode>;
        getDepthModeFor3D(): Readonly<DepthMode>;
        opaquePassEnabledForLayer(): boolean;
        render(style: Style, options: PainterOptions): void;
        renderLayer(painter: Painter, sourceCache: SourceCache, layer: StyleLayer, coords: Array<OverscaledTileID>): void;
        saveTileTexture(texture: Texture): void;
        getTileTexture(size: number): Texture;
        /**
         * Finds the required shader and its variant (base/terrain/globe, etc.) and binds it, compiling a new shader if required.
         * @param name - Name of the desired shader.
         * @param programConfiguration - Configuration of shader's inputs.
         * @param defines - Additional macros to be injected at the beginning of the shader. Expected format is `['#define XYZ']`, etc.
         * @param forceSimpleProjection - Whether to force the use of a shader variant with simple mercator projection vertex shader.
         * False by default. Use true when drawing with a simple projection matrix is desired, eg. when drawing a fullscreen quad.
         * @returns
         */
        useProgram(name: string, forceSimpleProjection?: boolean): Program<any>;
        setCustomLayerDefaults(): void;
        setBaseState(): void;
        initDebugOverlayCanvas(): void;
        destroy(): void;
        overLimit(): boolean;
    }
    /**
     * Adds the map's position to its page's location hash.
     * Passed as an option to the map object.
     *
     * @group Markers and Controls
     */
    class Hash {
        _map: MapLibreMap;
        _hashName: string;
        constructor(hashName?: string | null);
        /**
         * Map element to listen for coordinate changes
         *
         * @param map - The map object
         */
        addTo(map: MapLibreMap): this;
        /**
         * Removes hash
         */
        remove(): this;
        getHashString(mapFeedback?: boolean): string;
        _getCurrentHash: () => any;
        _onHashChange: () => boolean;
        _updateHashUnthrottled: () => void;
        _removeHash: () => void;
        /**
         * Mobile Safari doesn't allow updating the hash more than 100 times per 30 seconds.
         */
        _updateHash: () => ReturnType<typeof setTimeout>;
    }
    interface DragMovementResult {
        bearingDelta?: number;
        pitchDelta?: number;
        rollDelta?: number;
        around?: Point;
        panDelta?: Point;
    }
    interface DragPanResult extends DragMovementResult {
        around: Point;
        panDelta: Point;
    }
    interface DragRotateResult extends DragMovementResult {
        bearingDelta: number;
    }
    interface DragPitchResult extends DragMovementResult {
        pitchDelta: number;
    }
    interface DragRollResult extends DragMovementResult {
        rollDelta: number;
    }
    interface DragMoveHandler<T extends DragMovementResult, E extends Event> extends Handler$1 {
        dragStart: (e: E, point: Point) => void;
        dragMove: (e: E, point: Point) => T | void;
        dragEnd: (e: E) => void;
        getClickTolerance: () => number;
    }
    /**
     * `MousePanHandler` allows the user to pan the map by clicking and dragging
     */
    interface MousePanHandler extends DragMoveHandler<DragPanResult, MouseEvent> {
    }
    /**
     * `MouseRotateHandler` allows the user to rotate the map by clicking and dragging
     */
    interface MouseRotateHandler extends DragMoveHandler<DragRotateResult, MouseEvent> {
    }
    /**
     * `MousePitchHandler` allows the user to zoom the map by pitching
     */
    interface MousePitchHandler extends DragMoveHandler<DragPitchResult, MouseEvent> {
    }
    /**
     * `MouseRollHandler` allows the user to roll the camera by holding `Ctrl`, right-clicking and dragging
     */
    interface MouseRollHandler extends DragMoveHandler<DragRollResult, MouseEvent> {
    }
    class TouchPanHandler implements Handler$1 {
        _enabled: boolean;
        _active: boolean;
        _touches: {
            [k in string | number]: Point;
        };
        _clickTolerance: number;
        _sum: Point;
        _map: MapLibreMap;
        constructor(options: {
            clickTolerance: number;
        }, map: MapLibreMap);
        reset(): void;
        _shouldBePrevented(touchesCount: number): boolean;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            around: Point;
            panDelta: Point;
        };
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            around: Point;
            panDelta: Point;
        };
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchcancel(): void;
        _calculateTransform(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            around: Point;
            panDelta: Point;
        };
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isActive(): boolean;
    }
    /**
     * A {@link DragPanHandler} options object
     */
    type DragPanOptions = {
        /**
         * factor used to scale the drag velocity
         * @defaultValue 0
         */
        linearity?: number;
        /**
         * easing function applied to `map.panTo` when applying the drag.
         * @param t - the easing function
         * @defaultValue bezier(0, 0, 0.3, 1)
         */
        easing?: (t: number) => number;
        /**
         * the maximum value of the drag velocity.
         * @defaultValue 1400
         */
        deceleration?: number;
        /**
         * the rate at which the speed reduces after the pan ends.
         * @defaultValue 2500
         */
        maxSpeed?: number;
    };
    /**
     * The `DragPanHandler` allows the user to pan the map by clicking and dragging
     * the cursor.
     *
     * @group Handlers
     */
    class DragPanHandler {
        _el: HTMLElement;
        _mousePan: MousePanHandler;
        _touchPan: TouchPanHandler;
        _inertiaOptions: DragPanOptions | boolean;
        /** @internal */
        constructor(el: HTMLElement, mousePan: MousePanHandler, touchPan: TouchPanHandler);
        /**
         * Enables the "drag to pan" interaction.
         *
         * @param options - Options object
         * @example
         * ```ts
         *   map.dragPan.enable();
         *   map.dragPan.enable({
         *      linearity: 0.3,
         *      easing: bezier(0, 0, 0.3, 1),
         *      maxSpeed: 1400,
         *      deceleration: 2500,
         *   });
         * ```
         */
        enable(options?: DragPanOptions | boolean): void;
        /**
         * Disables the "drag to pan" interaction.
         *
         * @example
         * ```ts
         * map.dragPan.disable();
         * ```
         */
        disable(): void;
        /**
         * Returns a Boolean indicating whether the "drag to pan" interaction is enabled.
         *
         * @returns `true` if the "drag to pan" interaction is enabled.
         */
        isEnabled(): boolean;
        /**
         * Returns a Boolean indicating whether the "drag to pan" interaction is active, i.e. currently being used.
         *
         * @returns `true` if the "drag to pan" interaction is active.
         */
        isActive(): boolean;
    }
    type TaskID = number;
    type Task = {
        callback: (timeStamp: number) => void;
        id: TaskID;
        cancelled: boolean;
    };
    class TaskQueue {
        _queue: Array<Task>;
        _id: TaskID;
        _cleared: boolean;
        _currentlyRunning: Array<Task> | false;
        constructor();
        add(callback: (timeStamp: number) => void): TaskID;
        remove(id: TaskID): void;
        run(timeStamp?: number): void;
        clear(): void;
    }
    type MapControlsDeltas = {
        panDelta: Point;
        zoomDelta: number;
        bearingDelta: number;
        pitchDelta: number;
        rollDelta: number;
        around: Point;
    };
    type CameraForBoxAndBearingHandlerResult = {
        center: LngLat;
        zoom: number;
        bearing: number;
    };
    type EaseToHandlerOptions = {
        bearing: number;
        pitch: number;
        roll: number;
        padding: PaddingOptions;
        offsetAsPoint: Point;
        around?: LngLat;
        aroundPoint?: Point;
        center?: LngLatLike;
        zoom?: number;
        offset?: PointLike;
    };
    type EaseToHandlerResult = {
        easeFunc: (k: number) => void;
        elevationCenter: LngLat;
        isZooming: boolean;
    };
    type FlyToHandlerOptions = {
        bearing: number;
        pitch: number;
        roll: number;
        padding: PaddingOptions;
        offsetAsPoint: Point;
        center?: LngLatLike;
        locationAtOffset: LngLat;
        zoom?: number;
        minZoom?: number;
    };
    type FlyToHandlerResult = {
        easeFunc: (k: number, scale: number, centerFactor: number, pointAtOffset: Point) => void;
        scaleOfZoom: number;
        scaleOfMinZoom?: number;
        targetCenter: LngLat;
        pixelPathLength: number;
    };
    /**
     * @internal
     * Contains projection-specific functions related to camera controls, easeTo, flyTo, inertia, etc.
     */
    interface ICameraHelper {
        get useGlobeControls(): boolean;
        handlePanInertia(pan: Point, transform: IReadonlyTransform): {
            easingCenter: LngLat;
            easingOffset: Point;
        };
        handleMapControlsRollPitchBearingZoom(deltas: MapControlsDeltas, tr: ITransform): void;
        handleMapControlsPan(deltas: MapControlsDeltas, tr: ITransform, preZoomAroundLoc: LngLat): void;
        cameraForBoxAndBearing(options: CameraForBoundsOptions, padding: PaddingOptions, bounds: LngLatBounds, bearing: number, tr: IReadonlyTransform): CameraForBoxAndBearingHandlerResult;
        handleJumpToCenterZoom(tr: ITransform, options: {
            zoom?: number;
            center?: LngLatLike;
        }): void;
        handleEaseTo(tr: ITransform, options: EaseToHandlerOptions): EaseToHandlerResult;
        handleFlyTo(tr: ITransform, options: FlyToHandlerOptions): FlyToHandlerResult;
    }
    /**
     * A [Point](https://github.com/mapbox/point-geometry) or an array of two numbers representing `x` and `y` screen coordinates in pixels.
     *
     * @group Geography and Geometry
     *
     * @example
     * ```ts
     * let p1 = new Point(-77, 38); // a PointLike which is a Point
     * let p2 = [-77, 38]; // a PointLike which is an array of two numbers
     * ```
     */
    type PointLike = Point | [
        number,
        number
    ];
    /**
     * A helper to allow require of at least one property
     */
    type RequireAtLeastOne<T> = {
        [K in keyof T]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<keyof T, K>>>;
    }[keyof T];
    /**
     * Options common to {@link Map#jumpTo}, {@link Map#easeTo}, and {@link Map#flyTo}, controlling the desired location,
     * zoom, bearing, pitch, and roll of the camera. All properties are optional, and when a property is omitted, the current
     * camera value for that property will remain unchanged.
     *
     * @example
     * Set the map's initial perspective with CameraOptions
     * ```ts
     * let map = new Map({
     *   container: 'map',
     *   style: 'https://demotiles.maplibre.org/style.json',
     *   center: [-73.5804, 45.53483],
     *   pitch: 60,
     *   bearing: -60,
     *   zoom: 10
     * });
     * ```
     * @see [Set pitch and bearing](https://maplibre.org/maplibre-gl-js/docs/examples/set-perspective/)
     * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)
     * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)
     * @see [Display buildings in 3D](https://maplibre.org/maplibre-gl-js/docs/examples/3d-buildings/)
     */
    type CameraOptions = CenterZoomBearing & {
        /**
         * The desired pitch in degrees. The pitch is the angle towards the horizon
         * measured in degrees with a range between 0 and 60 degrees. For example, pitch: 0 provides the appearance
         * of looking straight down at the map, while pitch: 60 tilts the user's perspective towards the horizon.
         * Increasing the pitch value is often used to display 3D objects.
         */
        pitch?: number;
        /**
         * The desired roll in degrees. The roll is the angle about the camera boresight.
         */
        roll?: number;
    };
    /**
     * Holds center, zoom and bearing properties
     */
    type CenterZoomBearing = {
        /**
         * The desired center.
         */
        center?: LngLatLike;
        /**
         * The desired mercator zoom level.
         */
        zoom?: number;
        /**
         * The desired bearing in degrees. The bearing is the compass direction that
         * is "up". For example, `bearing: 90` orients the map so that east is up.
         */
        bearing?: number;
    };
    /**
     * The options object related to the {@link Map#jumpTo} method
     */
    type JumpToOptions = CameraOptions & {
        /**
         * Dimensions in pixels applied on each side of the viewport for shifting the vanishing point.
         */
        padding?: PaddingOptions;
    };
    /**
     * A options object for the {@link Map#cameraForBounds} method
     */
    type CameraForBoundsOptions = CameraOptions & {
        /**
         * The amount of padding in pixels to add to the given bounds.
         */
        padding?: number | RequireAtLeastOne<PaddingOptions>;
        /**
         * The center of the given bounds relative to the map's center, measured in pixels.
         * @defaultValue [0, 0]
         */
        offset?: PointLike;
        /**
         * The maximum zoom level to allow when the camera would transition to the specified bounds.
         */
        maxZoom?: number;
    };
    /**
     * The {@link Map#flyTo} options object
     */
    type FlyToOptions = AnimationOptions & CameraOptions & {
        /**
         * The zooming "curve" that will occur along the
         * flight path. A high value maximizes zooming for an exaggerated animation, while a low
         * value minimizes zooming for an effect closer to {@link Map#easeTo}. 1.42 is the average
         * value selected by participants in the user study discussed in
         * [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of
         * `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A
         * value of 1 would produce a circular motion.
         * @defaultValue 1.42
         */
        curve?: number;
        /**
         * The zero-based zoom level at the peak of the flight path. If
         * `options.curve` is specified, this option is ignored.
         */
        minZoom?: number;
        /**
         * The average speed of the animation defined in relation to
         * `options.curve`. A speed of 1.2 means that the map appears to move along the flight path
         * by 1.2 times `options.curve` screenfuls every second. A _screenful_ is the map's visible span.
         * It does not correspond to a fixed physical distance, but varies by zoom level.
         * @defaultValue 1.2
         */
        speed?: number;
        /**
         * The average speed of the animation measured in screenfuls
         * per second, assuming a linear timing curve. If `options.speed` is specified, this option is ignored.
         */
        screenSpeed?: number;
        /**
         * The animation's maximum duration, measured in milliseconds.
         * If duration exceeds maximum duration, it resets to 0.
         */
        maxDuration?: number;
        /**
         * The amount of padding in pixels to add to the given bounds.
         */
        padding?: number | RequireAtLeastOne<PaddingOptions>;
    };
    type EaseToOptions = AnimationOptions & CameraOptions & {
        delayEndEvents?: number;
        padding?: number | RequireAtLeastOne<PaddingOptions>;
        /**
         * If `zoom` is specified, `around` determines the point around which the zoom is centered.
         */
        around?: LngLatLike;
    };
    /**
     * Options for {@link Map#fitBounds} method
     */
    type FitBoundsOptions = FlyToOptions & {
        /**
         * If `true`, the map transitions using {@link Map#easeTo}. If `false`, the map transitions using {@link Map#flyTo}.
         * See those functions and {@link AnimationOptions} for information about options available.
         * @defaultValue false
         */
        linear?: boolean;
        /**
         * The center of the given bounds relative to the map's center, measured in pixels.
         * @defaultValue [0, 0]
         */
        offset?: PointLike;
        /**
         * The maximum zoom level to allow when the map view transitions to the specified bounds.
         */
        maxZoom?: number;
    };
    /**
     * Options common to map movement methods that involve animation, such as {@link Map#panBy} and
     * {@link Map#easeTo}, controlling the duration and easing function of the animation. All properties
     * are optional.
     *
     */
    type AnimationOptions = {
        /**
         * The animation's duration, measured in milliseconds.
         */
        duration?: number;
        /**
         * A function taking a time in the range 0..1 and returning a number where 0 is
         * the initial state and 1 is the final state.
         */
        easing?: (_: number) => number;
        /**
         * of the target center relative to real map container center at the end of animation.
         */
        offset?: PointLike;
        /**
         * If `false`, no animation will occur.
         */
        animate?: boolean;
        /**
         * If `true`, then the animation is considered essential and will not be affected by
         * [`prefers-reduced-motion`](https://developer.mozilla.org/en-US/docs/Web/CSS/\@media/prefers-reduced-motion).
         */
        essential?: boolean;
        /**
         * Default false. Needed in 3D maps to let the camera stay in a constant
         * height based on sea-level. After the animation finished the zoom-level will be recalculated in respect of
         * the distance from the camera to the center-coordinate-altitude.
         */
        freezeElevation?: boolean;
    };
    type ZoomInOutOptions = AnimationOptions & {
        zoomDelta?: number;
    };
    /**
     * A callback hook that allows manipulating the camera and being notified about camera updates before they happen
     */
    type CameraUpdateTransformFunction = (next: {
        center: LngLat;
        zoom: number;
        roll: number;
        pitch: number;
        bearing: number;
        elevation: number;
    }) => {
        center?: LngLat;
        zoom?: number;
        roll?: number;
        pitch?: number;
        bearing?: number;
        elevation?: number;
    };
    abstract class Camera extends Evented {
        transform: ITransform;
        cameraHelper: ICameraHelper;
        handlers: HandlerManager;
        _moving: boolean;
        _zooming: boolean;
        _rotating: boolean;
        _pitching: boolean;
        _rolling: boolean;
        _padding: boolean;
        _bearingSnap: number;
        _easeStart: number;
        _easeOptions: {
            duration?: number;
            easing?: (_: number) => number;
        };
        _easeId: string | void;
        _onEaseFrame: (_: number) => void;
        _onEaseEnd: (easeId?: string) => void;
        _easeFrameId: TaskID;
        /**
         * @internal
         * holds the geographical coordinate of the target
         */
        _elevationCenter: LngLat;
        /**
         * @internal
         * holds the targ altitude value, = center elevation of the target.
         * This value may changes during flight, because new terrain-tiles loads during flight.
         */
        _elevationTarget: number;
        /**
         * @internal
         * holds the start altitude value, = center elevation before animation begins
         * this value will recalculated during flight in respect of changing _elevationTarget values,
         * so the linear interpolation between start and target keeps smooth and without jumps.
         */
        _elevationStart: number;
        /**
         * @internal
         * Saves the current state of the elevation freeze - this is used during map movement to prevent "rocky" camera movement.
         */
        _elevationFreeze: boolean;
        /**
         * @internal
         * Used to track accumulated changes during continuous interaction
         */
        _requestedCameraState?: ITransform;
        /**
         * A callback used to defer camera updates or apply arbitrary constraints.
         * If specified, this Camera instance can be used as a stateless component in React etc.
         */
        transformCameraUpdate: CameraUpdateTransformFunction | null;
        abstract _requestRenderFrame(a: () => void): TaskID;
        abstract _cancelRenderFrame(_: TaskID): void;
        constructor(transform: ITransform, cameraHelper: ICameraHelper, options: {
            bearingSnap: number;
        });
        /**
         * @internal
         * Creates a new specialized transform instance from a projection instance and migrates
         * to this new transform, carrying over all the properties of the old transform (center, pitch, etc.).
         * When the style's projection is changed (or first set), this function should be called.
         */
        migrateProjection(newTransform: ITransform, newCameraHelper: ICameraHelper): void;
        /**
         * Returns the map's geographical centerpoint.
         *
         * @returns The map's geographical centerpoint.
         * @example
         * Return a LngLat object such as `{lng: 0, lat: 0}`
         * ```ts
         * let center = map.getCenter();
         * // access longitude and latitude values directly
         * let {lng, lat} = map.getCenter();
         * ```
         */
        getCenter(): LngLat;
        /**
         * Sets the map's geographical centerpoint. Equivalent to `jumpTo({center: center})`.
         *
         * Triggers the following events: `movestart` and `moveend`.
         *
         * @param center - The centerpoint to set.
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * ```ts
         * map.setCenter([-74, 38]);
         * ```
         */
        setCenter(center: LngLatLike, eventData?: any): this;
        /**
         * Pans the map by the specified offset.
         *
         * Triggers the following events: `movestart` and `moveend`.
         *
         * @param offset - `x` and `y` coordinates by which to pan the map.
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
         */
        panBy(offset: PointLike, options?: AnimationOptions, eventData?: any): this;
        /**
         * Pans the map to the specified location with an animated transition.
         *
         * Triggers the following events: `movestart` and `moveend`.
         *
         * @param lnglat - The location to pan the map to.
         * @param options - Options describing the destination and animation of the transition.
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * ```ts
         * map.panTo([-74, 38]);
         * // Specify that the panTo animation should last 5000 milliseconds.
         * map.panTo([-74, 38], {duration: 5000});
         * ```
         * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)
         */
        panTo(lnglat: LngLatLike, options?: AnimationOptions, eventData?: any): this;
        /**
         * Returns the map's current zoom level.
         *
         * @returns The map's current zoom level.
         * @example
         * ```ts
         * map.getZoom();
         * ```
         */
        getZoom(): number;
        /**
         * Sets the map's zoom level. Equivalent to `jumpTo({zoom: zoom})`.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
         *
         * @param zoom - The zoom level to set (0-20).
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * Zoom to the zoom level 5 without an animated transition
         * ```ts
         * map.setZoom(5);
         * ```
         */
        setZoom(zoom: number, eventData?: any): this;
        /**
         * Zooms the map to the specified zoom level, with an animated transition.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
         *
         * @param zoom - The zoom level to transition to.
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * ```ts
         * // Zoom to the zoom level 5 without an animated transition
         * map.zoomTo(5);
         * // Zoom to the zoom level 8 with an animated transition
         * map.zoomTo(8, {
         *   duration: 2000,
         *   offset: [100, 50]
         * });
         * ```
         */
        zoomTo(zoom: number, options?: AnimationOptions | null, eventData?: any): this;
        /**
         * Increases the map's zoom level by 1.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
         *
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * Zoom the map in one level with a custom animation duration
         * ```ts
         * map.zoomIn({duration: 1000});
         * ```
         */
        zoomIn(options?: ZoomInOutOptions, eventData?: any): this;
        /**
         * Decreases the map's zoom level by 1.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, and `zoomend`.
         *
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * Zoom the map out one level with a custom animation offset
         * ```ts
         * map.zoomOut({offset: [80, 60]});
         * ```
         */
        zoomOut(options?: ZoomInOutOptions, eventData?: any): this;
        /**
         * Returns the map's current bearing. The bearing is the compass direction that is "up"; for example, a bearing
         * of 90° orients the map so that east is up.
         *
         * @returns The map's current bearing.
         * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
         */
        getBearing(): number;
        /**
         * Sets the map's bearing (rotation). The bearing is the compass direction that is "up"; for example, a bearing
         * of 90° orients the map so that east is up.
         *
         * Equivalent to `jumpTo({bearing: bearing})`.
         *
         * Triggers the following events: `movestart`, `moveend`, and `rotate`.
         *
         * @param bearing - The desired bearing.
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * Rotate the map to 90 degrees
         * ```ts
         * map.setBearing(90);
         * ```
         */
        setBearing(bearing: number, eventData?: any): this;
        /**
         * Returns the current padding applied around the map viewport.
         *
         * @returns The current padding around the map viewport.
         */
        getPadding(): PaddingOptions;
        /**
         * Sets the padding in pixels around the viewport.
         *
         * Equivalent to `jumpTo({padding: padding})`.
         *
         * Triggers the following events: `movestart` and `moveend`.
         *
         * @param padding - The desired padding.
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * Sets a left padding of 300px, and a top padding of 50px
         * ```ts
         * map.setPadding({ left: 300, top: 50 });
         * ```
         */
        setPadding(padding: PaddingOptions, eventData?: any): this;
        /**
         * Rotates the map to the specified bearing, with an animated transition. The bearing is the compass direction
         * that is "up"; for example, a bearing of 90° orients the map so that east is up.
         *
         * Triggers the following events: `movestart`, `moveend`, and `rotate`.
         *
         * @param bearing - The desired bearing.
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         */
        rotateTo(bearing: number, options?: AnimationOptions, eventData?: any): this;
        /**
         * Rotates the map so that north is up (0° bearing), with an animated transition.
         *
         * Triggers the following events: `movestart`, `moveend`, and `rotate`.
         *
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         */
        resetNorth(options?: AnimationOptions, eventData?: any): this;
        /**
         * Rotates and pitches the map so that north is up (0° bearing) and pitch and roll are 0°, with an animated transition.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `pitchstart`, `pitch`, `pitchend`, `rollstart`, `roll`, `rollend`, and `rotate`.
         *
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         */
        resetNorthPitch(options?: AnimationOptions, eventData?: any): this;
        /**
         * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it (i.e. within the
         * `bearingSnap` threshold).
         *
         * Triggers the following events: `movestart`, `moveend`, and `rotate`.
         *
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         */
        snapToNorth(options?: AnimationOptions, eventData?: any): this;
        /**
         * Returns the map's current pitch (tilt).
         *
         * @returns The map's current pitch, measured in degrees away from the plane of the screen.
         */
        getPitch(): number;
        /**
         * Sets the map's pitch (tilt). Equivalent to `jumpTo({pitch: pitch})`.
         *
         * Triggers the following events: `movestart`, `moveend`, `pitchstart`, and `pitchend`.
         *
         * @param pitch - The pitch to set, measured in degrees away from the plane of the screen (0-60).
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         */
        setPitch(pitch: number, eventData?: any): this;
        /**
         * Returns the map's current roll angle.
         *
         * @returns The map's current roll, measured in degrees about the camera boresight.
         */
        getRoll(): number;
        /**
         * Sets the map's roll angle. Equivalent to `jumpTo({roll: roll})`.
         *
         * Triggers the following events: `movestart`, `moveend`, `rollstart`, and `rollend`.
         *
         * @param roll - The roll to set, measured in degrees about the camera boresight
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         */
        setRoll(roll: number, eventData?: any): this;
        /**
         * @param bounds - Calculate the center for these bounds in the viewport and use
         * the highest zoom level up to and including `Map#getMaxZoom()` that fits
         * in the viewport. LngLatBounds represent a box that is always axis-aligned with bearing 0.
         * Bounds will be taken in [sw, ne] order. Southwest point will always be to the left of the northeast point.
         * @param options - Options object
         * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.
         * If map is unable to fit, method will warn and return undefined.
         * @example
         * ```ts
         * let bbox = [[-79, 43], [-73, 45]];
         * let newCameraTransform = map.cameraForBounds(bbox, {
         *   padding: {top: 10, bottom:25, left: 15, right: 5}
         * });
         * ```
         */
        cameraForBounds(bounds: LngLatBoundsLike, options?: CameraForBoundsOptions): CenterZoomBearing | undefined;
        /**
         * @internal
         * Calculate the center of these two points in the viewport and use
         * the highest zoom level up to and including `Map#getMaxZoom()` that fits
         * the AABB defined by these points in the viewport at the specified bearing.
         * @param p0 - First point
         * @param p1 - Second point
         * @param bearing - Desired map bearing at end of animation, in degrees
         * @param options - the camera options
         * @returns If map is able to fit to provided bounds, returns `center`, `zoom`, and `bearing`.
         *      If map is unable to fit, method will warn and return undefined.
         * @example
         * ```ts
         * let p0 = [-79, 43];
         * let p1 = [-73, 45];
         * let bearing = 90;
         * let newCameraTransform = map._cameraForBoxAndBearing(p0, p1, bearing, {
         *   padding: {top: 10, bottom:25, left: 15, right: 5}
         * });
         * ```
         */
        _cameraForBoxAndBearing(p0: LngLatLike, p1: LngLatLike, bearing: number, options?: CameraForBoundsOptions): CenterZoomBearing | undefined;
        /**
         * Pans and zooms the map to contain its visible area within the specified geographical bounds.
         * This function will also reset the map's bearing to 0 if bearing is nonzero.
         *
         * Triggers the following events: `movestart` and `moveend`.
         *
         * @param bounds - Center these bounds in the viewport and use the highest
         * zoom level up to and including `Map#getMaxZoom()` that fits them in the viewport.
         * Bounds will be taken in [sw, ne] order. Southwest point will always be to the left of the northeast point.
         * @param options - Options supports all properties from {@link AnimationOptions} and {@link CameraOptions} in addition to the fields below.
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * ```ts
         * let bbox = [[-79, 43], [-73, 45]];
         * map.fitBounds(bbox, {
         *   padding: {top: 10, bottom:25, left: 15, right: 5}
         * });
         * ```
         * @see [Fit a map to a bounding box](https://maplibre.org/maplibre-gl-js/docs/examples/fitbounds/)
         */
        fitBounds(bounds: LngLatBoundsLike, options?: FitBoundsOptions, eventData?: any): this;
        /**
         * Pans, rotates and zooms the map to to fit the box made by points p0 and p1
         * once the map is rotated to the specified bearing. To zoom without rotating,
         * pass in the current map bearing.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend` and `rotate`.
         *
         * @param p0 - First point on screen, in pixel coordinates
         * @param p1 - Second point on screen, in pixel coordinates
         * @param bearing - Desired map bearing at end of animation, in degrees
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * ```ts
         * let p0 = [220, 400];
         * let p1 = [500, 900];
         * map.fitScreenCoordinates(p0, p1, map.getBearing(), {
         *   padding: {top: 10, bottom:25, left: 15, right: 5}
         * });
         * ```
         * @see Used by {@link BoxZoomHandler}
         */
        fitScreenCoordinates(p0: PointLike, p1: PointLike, bearing: number, options?: FitBoundsOptions, eventData?: any): this;
        _fitInternal(calculatedOptions?: CenterZoomBearing, options?: FitBoundsOptions, eventData?: any): this;
        /**
         * Changes any combination of center, zoom, bearing, pitch, and roll, without
         * an animated transition. The map will retain its current values for any
         * details not specified in `options`.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
         * `pitch`, `pitchend`, `rollstart`, `roll`, `rollend` and `rotate`.
         *
         * @param options - Options object
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * ```ts
         * // jump to coordinates at current zoom
         * map.jumpTo({center: [0, 0]});
         * // jump with zoom, pitch, and bearing options
         * map.jumpTo({
         *   center: [0, 0],
         *   zoom: 8,
         *   pitch: 45,
         *   bearing: 90
         * });
         * ```
         * @see [Jump to a series of locations](https://maplibre.org/maplibre-gl-js/docs/examples/jump-to/)
         * @see [Update a feature in realtime](https://maplibre.org/maplibre-gl-js/docs/examples/live-update-feature/)
         */
        jumpTo(options: JumpToOptions, eventData?: any): this;
        /**
         * Calculates pitch, zoom and bearing for looking at `newCenter` with the camera position being `newCenter`
         * and returns them as {@link CameraOptions}.
         * @param from - The camera to look from
         * @param altitudeFrom - The altitude of the camera to look from
         * @param to - The center to look at
         * @param altitudeTo - Optional altitude of the center to look at. If none given the ground height will be used.
         * @returns the calculated camera options
         */
        calculateCameraOptionsFromTo(from: LngLat, altitudeFrom: number, to: LngLat, altitudeTo?: number): CameraOptions;
        /**
         * Changes any combination of `center`, `zoom`, `bearing`, `pitch`, `roll`, and `padding` with an animated transition
         * between old and new values. The map will retain its current values for any
         * details not specified in `options`.
         *
         * Note: The transition will happen instantly if the user has enabled
         * the `reduced motion` accessibility feature enabled in their operating system,
         * unless `options` includes `essential: true`.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
         * `pitch`, `pitchend`, `rollstart`, `roll`, `rollend`, and `rotate`.
         *
         * @param options - Options describing the destination and animation of the transition.
         * Accepts {@link CameraOptions} and {@link AnimationOptions}.
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @see [Navigate the map with game-like controls](https://maplibre.org/maplibre-gl-js/docs/examples/game-controls/)
         */
        easeTo(options: EaseToOptions & {
            easeId?: string;
            noMoveStart?: boolean;
        }, eventData?: any): this;
        _prepareEase(eventData: any, noMoveStart: boolean, currently?: any): void;
        /**
         * @internal
         * Called when the camera is about to be manipulated.
         * If `transformCameraUpdate` is specified or terrain is enabled, a copy of
         * the current transform is created to track the accumulated changes.
         * This underlying transform represents the "desired state" proposed by input handlers / animations / UI controls.
         * It may differ from the state used for rendering (`this.transform`).
         * @returns Transform to apply changes to
         */
        _getTransformForUpdate(): ITransform;
        /**
         * @internal
         * Called after the camera is done being manipulated.
         * @param tr - the requested camera end state
         * If the camera is inside terrain, it gets elevated.
         * Call `transformCameraUpdate` if present, and then apply the "approved" changes.
         */
        _applyUpdatedTransform(tr: ITransform): void;
        _fireMoveEvents(eventData?: any): void;
        _afterEase(eventData?: any, easeId?: string): void;
        /**
         * Changes any combination of center, zoom, bearing, pitch, and roll, animating the transition along a curve that
         * evokes flight. The animation seamlessly incorporates zooming and panning to help
         * the user maintain her bearings even after traversing a great distance.
         *
         * Note: The animation will be skipped, and this will behave equivalently to `jumpTo`
         * if the user has the `reduced motion` accessibility feature enabled in their operating system,
         * unless 'options' includes `essential: true`.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, `zoomstart`, `zoom`, `zoomend`, `pitchstart`,
         * `pitch`, `pitchend`, `rollstart`, `roll`, `rollend`, and `rotate`.
         *
         * @param options - Options describing the destination and animation of the transition.
         * Accepts {@link CameraOptions}, {@link AnimationOptions},
         * and the following additional options.
         * @param eventData - Additional properties to be added to event objects of events triggered by this method.
         * @example
         * ```ts
         * // fly with default options to null island
         * map.flyTo({center: [0, 0], zoom: 9});
         * // using flyTo options
         * map.flyTo({
         *   center: [0, 0],
         *   zoom: 9,
         *   speed: 0.2,
         *   curve: 1,
         *   easing(t) {
         *     return t;
         *   }
         * });
         * ```
         * @see [Fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto/)
         * @see [Slowly fly to a location](https://maplibre.org/maplibre-gl-js/docs/examples/flyto-options/)
         * @see [Fly to a location based on scroll position](https://maplibre.org/maplibre-gl-js/docs/examples/scroll-fly-to/)
         */
        flyTo(options: FlyToOptions, eventData?: any): this;
        isEasing(): boolean;
        /**
         * Stops any animated transition underway.
         */
        stop(): this;
        _stop(allowGestures?: boolean, easeId?: string): this;
        _ease(frame: (_: number) => void, finish: () => void, options: {
            animate?: boolean;
            duration?: number;
            easing?: (_: number) => number;
        }): void;
        _renderFrameCallback: () => void;
        _normalizeBearing(bearing: number, currentBearing: number): number;
    }
    class HandlerInertia {
        _map: MapLibreMap;
        _inertiaBuffer: Array<{
            time: number;
            settings: any;
        }>;
        constructor(map: MapLibreMap);
        clear(): void;
        record(settings: any): void;
        _drainInertiaBuffer(): void;
        _onMoveEnd(panInertiaOptions?: DragPanOptions | boolean): EaseToOptions;
    }
    interface Handler$1 {
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        /**
         * This is used to indicate if the handler is currently active or not.
         * In case a handler is active, it will block other handlers from getting the relevant events.
         * There is an allow list of handlers that can be active at the same time, which is configured when adding a handler.
         */
        isActive(): boolean;
        /**
         * `reset` can be called by the manager at any time and must reset everything to it's original state
         */
        reset(): void;
        readonly touchstart?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
        readonly touchmove?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
        readonly touchmoveWindow?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
        readonly touchend?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
        readonly touchcancel?: (e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>) => HandlerResult | void;
        readonly mousedown?: (e: MouseEvent, point: Point) => HandlerResult | void;
        readonly mousemove?: (e: MouseEvent, point: Point) => HandlerResult | void;
        readonly mousemoveWindow?: (e: MouseEvent, point: Point) => HandlerResult | void;
        readonly mouseup?: (e: MouseEvent, point: Point) => HandlerResult | void;
        readonly mouseupWindow?: (e: MouseEvent, point: Point) => HandlerResult | void;
        readonly dblclick?: (e: MouseEvent, point: Point) => HandlerResult | void;
        readonly contextmenu?: (e: MouseEvent) => HandlerResult | void;
        readonly wheel?: (e: WheelEvent, point: Point) => HandlerResult | void;
        readonly keydown?: (e: KeyboardEvent) => HandlerResult | void;
        readonly keyup?: (e: KeyboardEvent) => HandlerResult | void;
        /**
         * `renderFrame` is the only non-dom event. It is called during render
         * frames and can be used to smooth camera changes (see scroll handler).
         */
        readonly renderFrame?: () => HandlerResult | void;
    }
    /**
     * All handler methods that are called with events can optionally return a `HandlerResult`.
     */
    type HandlerResult = {
        panDelta?: Point;
        zoomDelta?: number;
        bearingDelta?: number;
        pitchDelta?: number;
        rollDelta?: number;
        /**
         * the point to not move when changing the camera
         */
        around?: Point | null;
        /**
         * same as above, except for pinch actions, which are given higher priority
         */
        pinchAround?: Point | null;
        /**
         * A method that can fire a one-off easing by directly changing the map's camera.
         */
        cameraAnimation?: (map: MapLibreMap) => any;
        /**
         * The last three properties are needed by only one handler: scrollzoom.
         * The DOM event to be used as the `originalEvent` on any camera change events.
         */
        originalEvent?: Event;
        /**
         * Makes the manager trigger a frame, allowing the handler to return multiple results over time (see scrollzoom).
         */
        needsRenderFrame?: boolean;
        /**
         * The camera changes won't get recorded for inertial zooming.
         */
        noInertia?: boolean;
    };
    type EventInProgress = {
        handlerName: string;
        originalEvent: Event;
    };
    type EventsInProgress = {
        zoom?: EventInProgress;
        roll?: EventInProgress;
        pitch?: EventInProgress;
        rotate?: EventInProgress;
        drag?: EventInProgress;
    };
    class HandlerManager {
        _map: MapLibreMap;
        _el: HTMLElement;
        _handlers: Array<{
            handlerName: string;
            handler: Handler$1;
            allowed: Array<string>;
        }>;
        _eventsInProgress: EventsInProgress;
        _frameId: number;
        _inertia: HandlerInertia;
        _bearingSnap: number;
        _handlersById: {
            [x: string]: Handler$1;
        };
        _updatingCamera: boolean;
        _changes: Array<[
            HandlerResult,
            EventsInProgress,
            {
                [handlerName: string]: Event;
            }
        ]>;
        _zoom: {
            handlerName: string;
        };
        _previousActiveHandlers: {
            [x: string]: Handler$1;
        };
        _listeners: Array<[
            Window | Document | HTMLElement,
            string,
            ({
                passive?: boolean;
                capture?: boolean;
            } | undefined)
        ]>;
        constructor(map: MapLibreMap, options: CompleteMapOptions);
        destroy(): void;
        _addDefaultHandlers(options: CompleteMapOptions): void;
        _add(handlerName: string, handler: Handler$1, allowed?: Array<string>): void;
        stop(allowEndAnimation: boolean): void;
        isActive(): boolean;
        isZooming(): boolean;
        isRotating(): boolean;
        isMoving(): boolean;
        _blockedByActive(activeHandlers: {
            [x: string]: Handler$1;
        }, allowed: Array<string>, myName: string): boolean;
        handleWindowEvent: (e: {
            type: "mousemove" | "mouseup" | "touchmove";
        }) => void;
        _getMapTouches(touches: TouchList): TouchList;
        handleEvent: (e: Event, eventName?: keyof Handler$1) => void;
        mergeHandlerResult(mergedHandlerResult: HandlerResult, eventsInProgress: EventsInProgress, handlerResult: HandlerResult, name: string, e?: UIEvent): void;
        _applyChanges(): void;
        _updateMapTransform(combinedResult: HandlerResult, combinedEventsInProgress: EventsInProgress, deactivatedHandlers: {
            [handlerName: string]: Event;
        }): void;
        _fireEvents(newEventsInProgress: EventsInProgress, deactivatedHandlers: {
            [handlerName: string]: Event;
        }, allowEndAnimation: boolean): void;
        _fireEvent(type: string, e?: Event): void;
        _requestFrame(): number;
        _triggerRenderFrame(): void;
    }
    /**
     * A position defintion for the control to be placed, can be in one of the corners of the map.
     * When two or more controls are places in the same location they are stacked toward the center of the map.
     */
    type ControlPosition = "top-left" | "top-right" | "bottom-left" | "bottom-right";
    /**
     * Interface for interactive controls added to the map. This is a
     * specification for implementers to model: it is not
     * an exported method or class.
     *
     * Controls must implement `onAdd` and `onRemove`, and must own an
     * element, which is often a `div` element. To use MapLibre GL JS's
     * default control styling, add the `maplibregl-ctrl` class to your control's
     * node.
     *
     * @example
     * ```ts
     * class HelloWorldControl: IControl {
     *     onAdd(map) {
     *         this._map = map;
     *         this._container = document.createElement('div');
     *         this._container.className = 'maplibregl-ctrl';
     *         this._container.textContent = 'Hello, world';
     *         return this._container;
     *     }
     *
     *     onRemove() {
     *         this._container.parentNode.removeChild(this._container);
     *         this._map = undefined;
     *     }
     * }
     * ```
     */
    interface IControl {
        /**
         * Register a control on the map and give it a chance to register event listeners
         * and resources. This method is called by {@link MapLibreMap#addControl}
         * internally.
         *
         * @param map - the Map this control will be added to
         * @returns The control's container element. This should
         * be created by the control and returned by onAdd without being attached
         * to the DOM: the map will insert the control's element into the DOM
         * as necessary.
         */
        onAdd(map: MapLibreMap): HTMLElement;
        /**
         * Unregister a control on the map and give it a chance to detach event listeners
         * and resources. This method is called by {@link MapLibreMap#removeControl}
         * internally.
         *
         * @param map - the Map this control will be removed from
         */
        onRemove(map: MapLibreMap): void;
        /**
         * Optionally provide a default position for this control. If this method
         * is implemented and {@link MapLibreMap#addControl} is called without the `position`
         * parameter, the value returned by getDefaultPosition will be used as the
         * control's position.
         *
         * @returns a control position, one of the values valid in addControl.
         */
        readonly getDefaultPosition?: () => ControlPosition;
    }
    /**
     * The {@link AttributionControl} options object
     */
    type AttributionControlOptions = {
        /**
         * If `true`, the attribution control will always collapse when moving the map. If `false`,
         * force the expanded attribution control. The default is a responsive attribution that collapses when the user moves the map on maps less than 640 pixels wide.
         * **Attribution should not be collapsed if it can comfortably fit on the map. `compact` should only be used to modify default attribution when map size makes it impossible to fit default attribution and when the automatic compact resizing for default settings are not sufficient.**
         */
        compact?: boolean;
        /**
         * Attributions to show in addition to any other attributions.
         */
        customAttribution?: string | Array<string>;
    };
    /**
     * An `AttributionControl` control presents the map's attribution information. By default, the attribution control is expanded (regardless of map width).
     * @group Markers and Controls
     * @example
     * ```ts
     * let map = new Map({attributionControl: false})
     *     .addControl(new AttributionControl({
     *         compact: true
     *     }));
     * ```
     */
    class AttributionControl implements IControl {
        options: AttributionControlOptions;
        _map: MapLibreMap;
        _compact: boolean | undefined;
        _container: HTMLElement;
        _innerContainer: HTMLElement;
        _compactButton: HTMLElement;
        _editLink: HTMLAnchorElement;
        _attribHTML: string;
        styleId: string;
        styleOwner: string;
        /**
         * @param options - the attribution options
         */
        constructor(options?: AttributionControlOptions);
        getDefaultPosition(): ControlPosition;
        /** {@inheritDoc IControl.onAdd} */
        onAdd(map: MapLibreMap): HTMLElement;
        /** {@inheritDoc IControl.onRemove} */
        onRemove(): void;
        _setElementTitle(element: HTMLElement, title: "ToggleAttribution" | "MapFeedback"): void;
        _toggleAttribution: () => void;
        _updateData: (e: MapDataEvent) => void;
        _updateAttributions(): void;
        _updateCompact: () => void;
        _updateCompactMinimize: () => void;
    }
    const defaultLocale: {
        "AttributionControl.ToggleAttribution": string;
        "AttributionControl.MapFeedback": string;
        "FullscreenControl.Enter": string;
        "FullscreenControl.Exit": string;
        "GeolocateControl.FindMyLocation": string;
        "GeolocateControl.LocationNotAvailable": string;
        "LogoControl.Title": string;
        "Map.Title": string;
        "Marker.Title": string;
        "NavigationControl.ResetBearing": string;
        "NavigationControl.ZoomIn": string;
        "NavigationControl.ZoomOut": string;
        "Popup.Close": string;
        "ScaleControl.Feet": string;
        "ScaleControl.Meters": string;
        "ScaleControl.Kilometers": string;
        "ScaleControl.Miles": string;
        "ScaleControl.NauticalMiles": string;
        "TerrainControl.Enable": string;
        "TerrainControl.Disable": string;
        "CooperativeGesturesHandler.WindowsHelpText": string;
        "CooperativeGesturesHandler.MacHelpText": string;
        "CooperativeGesturesHandler.MobileHelpText": string;
    };
    class TransformProvider {
        _map: MapLibreMap;
        constructor(map: MapLibreMap);
        get transform(): IReadonlyTransform;
        get center(): {
            lng: number;
            lat: number;
        };
        get zoom(): number;
        get pitch(): number;
        get bearing(): number;
        unproject(point: PointLike): LngLat;
    }
    /**
     * An options object sent to the enable function of some of the handlers
     */
    type AroundCenterOptions = {
        /**
         * If "center" is passed, map will zoom around the center of map
         */
        around: "center";
    };
    abstract class TwoFingersTouchHandler implements Handler$1 {
        _enabled?: boolean;
        _active?: boolean;
        _firstTwoTouches?: [
            number,
            number
        ];
        _vector?: Point;
        _startVector?: Point;
        _aroundCenter?: boolean;
        /** @internal */
        constructor();
        reset(): void;
        abstract _start(points: [
            Point,
            Point
        ]): void;
        abstract _move(points: [
            Point,
            Point
        ], pinchAround: Point | null, e: TouchEvent): HandlerResult | void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): HandlerResult | void;
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchcancel(): void;
        /**
         * Enables the "drag to pitch" interaction.
         *
         * @example
         * ```ts
         * map.touchPitch.enable();
         * ```
         */
        enable(options?: AroundCenterOptions | boolean | null): void;
        /**
         * Disables the "drag to pitch" interaction.
         *
         * @example
         * ```ts
         * map.touchPitch.disable();
         * ```
         */
        disable(): void;
        /**
         * Returns a Boolean indicating whether the "drag to pitch" interaction is enabled.
         *
         * @returns  `true` if the "drag to pitch" interaction is enabled.
         */
        isEnabled(): boolean;
        /**
         * Returns a Boolean indicating whether the "drag to pitch" interaction is active, i.e. currently being used.
         *
         * @returns `true` if the "drag to pitch" interaction is active.
         */
        isActive(): boolean;
    }
    /**
     * The `TwoFingersTouchHandler`s allows the user to zoom the map two fingers
     *
     * @group Handlers
     */
    class TwoFingersTouchZoomHandler extends TwoFingersTouchHandler {
        _distance?: number;
        _startDistance?: number;
        reset(): void;
        _start(points: [
            Point,
            Point
        ]): void;
        _move(points: [
            Point,
            Point
        ], pinchAround: Point | null): HandlerResult | void;
    }
    /**
     * The `TwoFingersTouchHandler`s allows the user to rotate the map two fingers
     *
     * @group Handlers
     */
    class TwoFingersTouchRotateHandler extends TwoFingersTouchHandler {
        _minDiameter?: number;
        reset(): void;
        _start(points: [
            Point,
            Point
        ]): void;
        _move(points: [
            Point,
            Point
        ], pinchAround: Point | null, _e: TouchEvent): HandlerResult | void;
        _isBelowThreshold(vector: Point): boolean;
    }
    /**
     * The `TwoFingersTouchPitchHandler` allows the user to pitch the map by dragging up and down with two fingers.
     *
     * @group Handlers
     */
    class TwoFingersTouchPitchHandler extends TwoFingersTouchHandler {
        _valid?: boolean;
        _firstMove?: number;
        _lastPoints?: [
            Point,
            Point
        ];
        _map: MapLibreMap;
        _currentTouchCount: number;
        constructor(map: MapLibreMap);
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        _start(points: [
            Point,
            Point
        ]): void;
        _move(points: [
            Point,
            Point
        ], center: Point | null, e: TouchEvent): HandlerResult | void;
        gestureBeginsVertically(vectorA: Point, vectorB: Point, timeStamp: number): boolean | undefined;
    }
    /**
     * The `ScrollZoomHandler` allows the user to zoom the map by scrolling.
     *
     * @group Handlers
     */
    class ScrollZoomHandler implements Handler$1 {
        _map: MapLibreMap;
        _tr: TransformProvider;
        _enabled: boolean;
        _active: boolean;
        _zooming: boolean;
        _aroundCenter: boolean;
        _aroundPoint: Point;
        _type: "wheel" | "trackpad" | null;
        _lastValue: number;
        _timeout: ReturnType<typeof setTimeout>;
        _finishTimeout: ReturnType<typeof setTimeout>;
        _lastWheelEvent: any;
        _lastWheelEventTime: number;
        _lastExpectedZoom: number;
        _startZoom: number;
        _targetZoom: number;
        _delta: number;
        _easing: (a: number) => number;
        _prevEase: {
            start: number;
            duration: number;
            easing: (_: number) => number;
        };
        _frameId: boolean;
        _triggerRenderFrame: () => void;
        _defaultZoomRate: number;
        _wheelZoomRate: number;
        /** @internal */
        constructor(map: MapLibreMap, triggerRenderFrame: () => void);
        /**
         * Set the zoom rate of a trackpad
         * @param zoomRate - 1/100 The rate used to scale trackpad movement to a zoom value.
         * @example
         * Speed up trackpad zoom
         * ```ts
         * map.scrollZoom.setZoomRate(1/25);
         * ```
         */
        setZoomRate(zoomRate: number): void;
        /**
         * Set the zoom rate of a mouse wheel
         * @param wheelZoomRate - 1/450 The rate used to scale mouse wheel movement to a zoom value.
         * @example
         * Slow down zoom of mouse wheel
         * ```ts
         * map.scrollZoom.setWheelZoomRate(1/600);
         * ```
         */
        setWheelZoomRate(wheelZoomRate: number): void;
        /**
         * Returns a Boolean indicating whether the "scroll to zoom" interaction is enabled.
         * @returns `true` if the "scroll to zoom" interaction is enabled.
         */
        isEnabled(): boolean;
        isActive(): boolean;
        isZooming(): boolean;
        /**
         * Enables the "scroll to zoom" interaction.
         *
         * @param options - Options object.
         * @example
         * ```ts
         * map.scrollZoom.enable();
         * map.scrollZoom.enable({ around: 'center' })
         * ```
         */
        enable(options?: AroundCenterOptions | boolean): void;
        /**
         * Disables the "scroll to zoom" interaction.
         *
         * @example
         * ```ts
         * map.scrollZoom.disable();
         * ```
         */
        disable(): void;
        /**
         * Determines whether or not the gesture is blocked due to cooperativeGestures.
         */
        _shouldBePrevented(e: WheelEvent): boolean;
        wheel(e: WheelEvent): void;
        _onTimeout: (initialEvent: MouseEvent) => void;
        _start(e: MouseEvent): void;
        renderFrame(): {
            noInertia: boolean;
            needsRenderFrame: boolean;
            zoomDelta: number;
            around: Point;
            originalEvent: any;
        };
        _smoothOutEasing(duration: number): (t: number) => number;
        reset(): void;
    }
    /**
     * The `BoxZoomHandler` allows the user to zoom the map to fit within a bounding box.
     * The bounding box is defined by clicking and holding `shift` while dragging the cursor.
     *
     * @group Handlers
     */
    class BoxZoomHandler implements Handler$1 {
        _map: MapLibreMap;
        _tr: TransformProvider;
        _el: HTMLElement;
        _container: HTMLElement;
        _enabled: boolean;
        _active: boolean;
        _startPos: Point;
        _lastPos: Point;
        _box: HTMLElement;
        _clickTolerance: number;
        /** @internal */
        constructor(map: MapLibreMap, options: {
            clickTolerance: number;
        });
        /**
         * Returns a Boolean indicating whether the "box zoom" interaction is enabled.
         *
         * @returns `true` if the "box zoom" interaction is enabled.
         */
        isEnabled(): boolean;
        /**
         * Returns a Boolean indicating whether the "box zoom" interaction is active, i.e. currently being used.
         *
         * @returns `true` if the "box zoom" interaction is active.
         */
        isActive(): boolean;
        /**
         * Enables the "box zoom" interaction.
         *
         * @example
         * ```ts
         * map.boxZoom.enable();
         * ```
         */
        enable(): void;
        /**
         * Disables the "box zoom" interaction.
         *
         * @example
         * ```ts
         * map.boxZoom.disable();
         * ```
         */
        disable(): void;
        mousedown(e: MouseEvent, point: Point): void;
        mousemoveWindow(e: MouseEvent, point: Point): void;
        mouseupWindow(e: MouseEvent, point: Point): {
            cameraAnimation: (map: any) => any;
        };
        keydown(e: KeyboardEvent): void;
        reset(): void;
        _fireEvent(type: string, e: any): MapLibreMap;
    }
    /**
     * Options object for `DragRotateHandler`.
     */
    type DragRotateHandlerOptions = {
        /**
         * Control the map pitch in addition to the bearing
         * @defaultValue true
         */
        pitchWithRotate: boolean;
        /**
         * Control the map roll in addition to the bearing
         * @defaultValue false
         */
        rollEnabled: boolean;
    };
    /**
     * The `DragRotateHandler` allows the user to rotate the map by clicking and
     * dragging the cursor while holding the right mouse button or `ctrl` key.
     *
     * @group Handlers
     */
    class DragRotateHandler {
        _mouseRotate: MouseRotateHandler;
        _mousePitch: MousePitchHandler;
        _mouseRoll: MouseRollHandler;
        _pitchWithRotate: boolean;
        _rollEnabled: boolean;
        /** @internal */
        constructor(options: DragRotateHandlerOptions, mouseRotate: MouseRotateHandler, mousePitch: MousePitchHandler, mouseRoll: MouseRollHandler);
        /**
         * Enables the "drag to rotate" interaction.
         *
         * @example
         * ```ts
         * map.dragRotate.enable();
         * ```
         */
        enable(): void;
        /**
         * Disables the "drag to rotate" interaction.
         *
         * @example
         * ```ts
         * map.dragRotate.disable();
         * ```
         */
        disable(): void;
        /**
         * Returns a Boolean indicating whether the "drag to rotate" interaction is enabled.
         *
         * @returns `true` if the "drag to rotate" interaction is enabled.
         */
        isEnabled(): boolean;
        /**
         * Returns a Boolean indicating whether the "drag to rotate" interaction is active, i.e. currently being used.
         *
         * @returns `true` if the "drag to rotate" interaction is active.
         */
        isActive(): boolean;
    }
    /**
     * The {@link CooperativeGesturesHandler} options object for the gesture settings
     */
    type GestureOptions = boolean;
    /**
     * A `CooperativeGestureHandler` is a control that adds cooperative gesture info when user tries to zoom in/out.
     *
     * When the CooperativeGestureHandler blocks a gesture, it will emit a `cooperativegestureprevented` event.
     *
     * @group Handlers
     *
     * @example
     * ```ts
     * const map = new Map({
     *   cooperativeGestures: true
     * });
     * ```
     * @see [Example: cooperative gestures](https://maplibre.org/maplibre-gl-js/docs/examples/cooperative-gestures/)
     **/
    class CooperativeGesturesHandler implements Handler$1 {
        _options: GestureOptions;
        _map: MapLibreMap;
        _container: HTMLElement;
        /**
         * This is the key that will allow to bypass the cooperative gesture protection
         */
        _bypassKey: "metaKey" | "ctrlKey";
        _enabled: boolean;
        constructor(map: MapLibreMap, options: GestureOptions);
        isActive(): boolean;
        reset(): void;
        _setupUI(): void;
        _destroyUI(): void;
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isBypassed(event: MouseEvent | WheelEvent | PointerEvent): boolean;
        notifyGestureBlocked(gestureType: "wheel_zoom" | "touch_pan", originalEvent: Event): void;
    }
    /**
     * The `KeyboardHandler` allows the user to zoom, rotate, and pan the map using
     * the following keyboard shortcuts:
     *
     * - `=` / `+`: Increase the zoom level by 1.
     * - `Shift-=` / `Shift-+`: Increase the zoom level by 2.
     * - `-`: Decrease the zoom level by 1.
     * - `Shift--`: Decrease the zoom level by 2.
     * - Arrow keys: Pan by 100 pixels.
     * - `Shift+⇢`: Increase the rotation by 15 degrees.
     * - `Shift+⇠`: Decrease the rotation by 15 degrees.
     * - `Shift+⇡`: Increase the pitch by 10 degrees.
     * - `Shift+⇣`: Decrease the pitch by 10 degrees.
     *
     * @group Handlers
     */
    class KeyboardHandler implements Handler$1 {
        _tr: TransformProvider;
        _enabled: boolean;
        _active: boolean;
        _panStep: number;
        _bearingStep: number;
        _pitchStep: number;
        _rotationDisabled: boolean;
        /** @internal */
        constructor(map: MapLibreMap);
        reset(): void;
        keydown(e: KeyboardEvent): {
            cameraAnimation: (map: MapLibreMap) => void;
        };
        /**
         * Enables the "keyboard rotate and zoom" interaction.
         *
         * @example
         * ```ts
         * map.keyboard.enable();
         * ```
         */
        enable(): void;
        /**
         * Disables the "keyboard rotate and zoom" interaction.
         *
         * @example
         * ```ts
         * map.keyboard.disable();
         * ```
         */
        disable(): void;
        /**
         * Returns a Boolean indicating whether the "keyboard rotate and zoom"
         * interaction is enabled.
         *
         * @returns `true` if the "keyboard rotate and zoom"
         * interaction is enabled.
         */
        isEnabled(): boolean;
        /**
         * Returns true if the handler is enabled and has detected the start of a
         * zoom/rotate gesture.
         *
         * @returns `true` if the handler is enabled and has detected the
         * start of a zoom/rotate gesture.
         */
        isActive(): boolean;
        /**
         * Disables the "keyboard pan/rotate" interaction, leaving the
         * "keyboard zoom" interaction enabled.
         *
         * @example
         * ```ts
         * map.keyboard.disableRotation();
         * ```
         */
        disableRotation(): void;
        /**
         * Enables the "keyboard pan/rotate" interaction.
         *
         * @example
         * ```ts
         * map.keyboard.enable();
         * map.keyboard.enableRotation();
         * ```
         */
        enableRotation(): void;
    }
    class ClickZoomHandler implements Handler$1 {
        _tr: TransformProvider;
        _enabled: boolean;
        _active: boolean;
        /** @internal */
        constructor(map: MapLibreMap);
        reset(): void;
        dblclick(e: MouseEvent, point: Point): {
            cameraAnimation: (map: MapLibreMap) => void;
        };
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isActive(): boolean;
    }
    class SingleTapRecognizer {
        numTouches: number;
        centroid: Point;
        startTime: number;
        aborted: boolean;
        touches: {
            [k in number | string]: Point;
        };
        constructor(options: {
            numTouches: number;
        });
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): Point;
    }
    class TapRecognizer {
        singleTap: SingleTapRecognizer;
        numTaps: number;
        lastTime: number;
        lastTap: Point;
        count: number;
        constructor(options: {
            numTaps: number;
            numTouches: number;
        });
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): Point;
    }
    class TapZoomHandler implements Handler$1 {
        _tr: TransformProvider;
        _enabled: boolean;
        _active: boolean;
        _zoomIn: TapRecognizer;
        _zoomOut: TapRecognizer;
        constructor(map: MapLibreMap);
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            cameraAnimation: (map: MapLibreMap) => MapLibreMap;
        };
        touchcancel(): void;
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isActive(): boolean;
    }
    /**
     * The `DoubleClickZoomHandler` allows the user to zoom the map at a point by
     * double clicking or double tapping.
     *
     * @group Handlers
     */
    class DoubleClickZoomHandler {
        _clickZoom: ClickZoomHandler;
        _tapZoom: TapZoomHandler;
        /** @internal */
        constructor(clickZoom: ClickZoomHandler, TapZoom: TapZoomHandler);
        /**
         * Enables the "double click to zoom" interaction.
         *
         * @example
         * ```ts
         * map.doubleClickZoom.enable();
         * ```
         */
        enable(): void;
        /**
         * Disables the "double click to zoom" interaction.
         *
         * @example
         * ```ts
         * map.doubleClickZoom.disable();
         * ```
         */
        disable(): void;
        /**
         * Returns a Boolean indicating whether the "double click to zoom" interaction is enabled.
         *
         * @returns `true` if the "double click to zoom" interaction is enabled.
         */
        isEnabled(): boolean;
        /**
         * Returns a Boolean indicating whether the "double click to zoom" interaction is active, i.e. currently being used.
         *
         * @returns `true` if the "double click to zoom" interaction is active.
         */
        isActive(): boolean;
    }
    class TapDragZoomHandler implements Handler$1 {
        _enabled: boolean;
        _active: boolean;
        _swipePoint: Point;
        _swipeTouch: number;
        _tapTime: number;
        _tapPoint: Point;
        _tap: TapRecognizer;
        constructor();
        reset(): void;
        touchstart(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchmove(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): {
            zoomDelta: number;
        };
        touchend(e: TouchEvent, points: Array<Point>, mapTouches: Array<Touch>): void;
        touchcancel(): void;
        enable(): void;
        disable(): void;
        isEnabled(): boolean;
        isActive(): boolean;
    }
    /**
     * The `TwoFingersTouchZoomRotateHandler` allows the user to zoom and rotate the map by
     * pinching on a touchscreen.
     *
     * They can zoom with one finger by double tapping and dragging. On the second tap,
     * hold the finger down and drag up or down to zoom in or out.
     *
     * @group Handlers
     */
    class TwoFingersTouchZoomRotateHandler {
        _el: HTMLElement;
        _touchZoom: TwoFingersTouchZoomHandler;
        _touchRotate: TwoFingersTouchRotateHandler;
        _tapDragZoom: TapDragZoomHandler;
        _rotationDisabled: boolean;
        _enabled: boolean;
        /** @internal */
        constructor(el: HTMLElement, touchZoom: TwoFingersTouchZoomHandler, touchRotate: TwoFingersTouchRotateHandler, tapDragZoom: TapDragZoomHandler);
        /**
         * Enables the "pinch to rotate and zoom" interaction.
         *
         * @param options - Options object.
         *
         * @example
         * ```ts
         * map.touchZoomRotate.enable();
         * map.touchZoomRotate.enable({ around: 'center' });
         * ```
         */
        enable(options?: AroundCenterOptions | boolean | null): void;
        /**
         * Disables the "pinch to rotate and zoom" interaction.
         *
         * @example
         * ```ts
         * map.touchZoomRotate.disable();
         * ```
         */
        disable(): void;
        /**
         * Returns a Boolean indicating whether the "pinch to rotate and zoom" interaction is enabled.
         *
         * @returns `true` if the "pinch to rotate and zoom" interaction is enabled.
         */
        isEnabled(): boolean;
        /**
         * Returns true if the handler is enabled and has detected the start of a zoom/rotate gesture.
         *
         * @returns `true` if the handler is active, `false` otherwise
         */
        isActive(): boolean;
        /**
         * Disables the "pinch to rotate" interaction, leaving the "pinch to zoom"
         * interaction enabled.
         *
         * @example
         * ```ts
         * map.touchZoomRotate.disableRotation();
         * ```
         */
        disableRotation(): void;
        /**
         * Enables the "pinch to rotate" interaction.
         *
         * @example
         * ```ts
         * map.touchZoomRotate.enable();
         * map.touchZoomRotate.enableRotation();
         * ```
         */
        enableRotation(): void;
    }
    class TileBounds {
        /**
         * Coordinate bounds. Longitude is *not* clamped to [-180, 180]!
         */
        bounds: LngLatBounds;
        minzoom: number;
        maxzoom: number;
        constructor(bounds: [
            number,
            number,
            number,
            number
        ], minzoom?: number | null, maxzoom?: number | null);
        validateBounds(bounds: [
            number,
            number,
            number,
            number
        ]): LngLatBoundsLike;
        contains(tileID: CanonicalTileID): boolean;
    }
    type DevicePixelRationFlag = {
        /**
         * When true, the regular tiles are always fetched, even on Retina devices.
         * Otherwise higher resolution tiles may be fetched on high pixel ratio devices, if the tile url contains `{r}`.
         * Negative semantics, since we want device pixel ratio detection and scaling to be enabled by default.
         */
        forceDisableDevicePixelRatioScaling?: boolean;
    };
    type RasterSourceSpecificationWithRetina = RasterSourceSpecification & DevicePixelRationFlag;
    /**
     * A source containing raster tiles (See the [Style Specification](https://maplibre.org/maplibre-style-spec/) for detailed documentation of options.)
     *
     * @group Sources
     *
     * @example
     * ```ts
     * map.addSource('raster-source', {
     *     'type': 'raster',
     *     'tiles': ['https://tiles.stadiamaps.com/tiles/stamen_watercolor/{z}/{x}/{y}.jpg'],
     *     'tileSize': 256,
     * });
     * ```
     *
     * @example
     * ```ts
     * map.addSource('wms-test-source', {
     *      'type': 'raster',
     * // use the tiles option to specify a WMS tile source URL
     *      'tiles': [
     *          'https://img.nj.gov/imagerywms/Natural2015?bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&srs=EPSG:3857&transparent=true&width=256&height=256&layers=Natural2015'
     *      ],
     *      'tileSize': 256
     * });
     * ```
     * @see [Add a raster tile source](https://maplibre.org/maplibre-gl-js/docs/examples/map-tiles/)
     * @see [Add a WMS source](https://maplibre.org/maplibre-gl-js/docs/examples/wms/)
     * @see [Display a satellite map](https://maplibre.org/maplibre-gl-js/docs/examples/satellite-map/)
     */
    class RasterTileSource extends Evented implements Source {
        type: "raster" | "raster-dem";
        id: string;
        minzoom: number;
        maxzoom: number;
        url: string;
        scheme: string;
        tileSize: number;
        bounds: [
            number,
            number,
            number,
            number
        ];
        tileBounds: TileBounds;
        roundZoom: boolean;
        map: MapLibreMap;
        tiles: Array<string>;
        _loaded: boolean;
        _options: RasterSourceSpecification & DevicePixelRationFlag;
        _tileJSONRequest: AbortController;
        _textureFormat: TextureFormat;
        constructor(id: string, options: RasterSourceSpecificationWithRetina, eventedParent: Evented);
        set textureFormat(format: TextureFormat);
        get textureFormat(): TextureFormat;
        load(): Promise<void>;
        loaded(): boolean;
        onAdd(map: MapLibreMap): void;
        onRemove(): void;
        setSourceProperty(callback: Function): void;
        /**
         * Sets the source `tiles` property and re-renders the map.
         *
         * @param tiles - An array of one or more tile source URLs, as in the raster tiles spec (See the [Style Specification](https://maplibre.org/maplibre-style-spec/)
         */
        setTiles(tiles: Array<string>): this;
        /**
         * Sets the source `url` property and re-renders the map.
         *
         * @param url - A URL to a TileJSON resource. Supported protocols are `http:` and `https:`.
         */
        setUrl(url: string): this;
        serialize(): RasterSourceSpecification & DevicePixelRationFlag;
        hasTile(tileID: OverscaledTileID): boolean;
        loadTile(tile: Tile): Promise<void>;
        abortTile(tile: Tile): Promise<void>;
        unloadTile(tile: Tile): Promise<void>;
        hasTransition(): boolean;
    }
    class LayerOrderingRepository {
        private _buckets;
        /**
         * Call when a layer is about to be added to MapLibre.
         * Finds and returns the `beforeId` parameter that should be used when calling `addLayer`.
         * @param layerID - The string ID of the layer to be added.
         * The layer must later also be added to MapLibre using this same string ID.
         * @param bucketID - The numerical ID of the target layer bucket.
         * @returns The indended `beforeId` parameter for MapLibre's `addLayer`
         * that will place this layer at the correct place in the layer order.
         */
        addLayerAndGetBeforeId(layerID: string, bucketID?: number): string | undefined;
        /**
         * Call when a given layer is removed from MapLibre.
         * @param layerId - The string ID of the layer to be removed.
         * Must be the same one that was passed to MapLibre.
         * Does nothing if the specified layerId is not present.
         */
        removeLayer(layerId: string): void;
    }
    /**
     * The {@link MapLibreMap} options object.
     */
    type MapLibreMapOptions = {
        /**
         * If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.
         * For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.
         * An additional string may optionally be provided to indicate a parameter-styled hash,
         * e.g. http://path/to/my/page.html#map=2.59/39.26/53.07/-24.1/60&foo=bar, where foo
         * is a custom parameter and bar is an arbitrary hash distinct from the map hash.
         * @defaultValue false
         */
        hash?: boolean | string;
        /**
         * If `false`, no mouse, touch, or keyboard listeners will be attached to the map, so it will not respond to interaction.
         * @defaultValue true
         */
        interactive?: boolean;
        /**
         * The HTML element in which MapLibre GL JS will render the map, or the element's string `id`. The specified element must have no children.
         */
        container: HTMLElement | string;
        /**
         * The threshold, measured in degrees, that determines when the map's
         * bearing will snap to north. For example, with a `bearingSnap` of 7, if the user rotates
         * the map within 7 degrees of north, the map will automatically snap to exact north.
         * @defaultValue 7
         */
        bearingSnap?: number;
        /**
         * If set, an {@link AttributionControl} will be added to the map with the provided options.
         * To disable the attribution control, pass `false`.
         * Note: showing the logo of MapLibre is not required for using MapLibre.
         * @defaultValue compact: true, customAttribution: "MapLibre ...".
         */
        attributionControl?: false | AttributionControlOptions;
        /**
         * If `true`, the MapLibre logo will be shown.
         */
        maplibreLogo?: boolean;
        /**
         * A string representing the position of the MapLibre wordmark on the map. Valid options are `top-left`,`top-right`, `bottom-left`, or `bottom-right`.
         * @defaultValue 'bottom-left'
         */
        logoPosition?: ControlPosition;
        /**
         * If `true`, map creation will fail if the performance of MapLibre GL JS would be dramatically worse than expected
         * (i.e. a software renderer would be used).
         * @defaultValue false
         */
        failIfMajorPerformanceCaveat?: boolean;
        /**
         * If `true`, the map's canvas can be exported to a PNG using `map.getCanvas().toDataURL()`. This is `false` by default as a performance optimization.
         * @defaultValue false
         */
        preserveDrawingBuffer?: boolean;
        /**
         * If `true`, the gl context will be created with MSAA antialiasing, which can be useful for antialiasing custom layers.
         * Disabled by default as a performance optimization.
         */
        antialias?: boolean;
        /**
         * If `false`, the map won't attempt to re-request tiles once they expire per their HTTP `cacheControl`/`expires` headers.
         * @defaultValue true
         */
        refreshExpiredTiles?: boolean;
        /**
         * If set, the map will be constrained to the given bounds.
         */
        maxBounds?: LngLatBoundsLike;
        /**
         * If `true`, the "scroll to zoom" interaction is enabled. {@link AroundCenterOptions} are passed as options to {@link ScrollZoomHandler#enable}.
         * @defaultValue true
         */
        scrollZoom?: boolean | AroundCenterOptions;
        /**
         * The minimum zoom level of the map (0-24).
         * @defaultValue 0
         */
        minZoom?: number | null;
        /**
         * The maximum zoom level of the map (0-24).
         * @defaultValue 22
         */
        maxZoom?: number | null;
        /**
         * The minimum pitch of the map (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
         * @defaultValue 0
         */
        minPitch?: number | null;
        /**
         * The maximum pitch of the map (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
         * @defaultValue 60
         */
        maxPitch?: number | null;
        /**
         * If `true`, the "box zoom" interaction is enabled (see {@link BoxZoomHandler}).
         * @defaultValue true
         */
        boxZoom?: boolean;
        /**
         * If `true`, the "drag to rotate" interaction is enabled (see {@link DragRotateHandler}).
         * @defaultValue true
         */
        dragRotate?: boolean;
        /**
         * If `true`, the "drag to pan" interaction is enabled. An `Object` value is passed as options to {@link DragPanHandler#enable}.
         * @defaultValue true
         */
        dragPan?: boolean | DragPanOptions;
        /**
         * If `true`, keyboard shortcuts are enabled (see {@link KeyboardHandler}).
         * @defaultValue true
         */
        keyboard?: boolean;
        /**
         * If `true`, the "double click to zoom" interaction is enabled (see {@link DoubleClickZoomHandler}).
         * @defaultValue true
         */
        doubleClickZoom?: boolean;
        /**
         * If `true`, the "pinch to rotate and zoom" interaction is enabled. An `Object` value is passed as options to {@link TwoFingersTouchZoomRotateHandler#enable}.
         * @defaultValue true
         */
        touchZoomRotate?: boolean | AroundCenterOptions;
        /**
         * If `true`, the "drag to pitch" interaction is enabled. An `Object` value is passed as options to {@link TwoFingersTouchPitchHandler#enable}.
         * @defaultValue true
         */
        touchPitch?: boolean | AroundCenterOptions;
        /**
         * If `true` or set to an options object, the map is only accessible on desktop while holding Command/Ctrl and only accessible on mobile with two fingers. Interacting with the map using normal gestures will trigger an informational screen. With this option enabled, "drag to pitch" requires a three-finger gesture. Cooperative gestures are disabled when a map enters fullscreen using {@link FullscreenControl}.
         * @defaultValue false
         */
        cooperativeGestures?: GestureOptions;
        /**
         * If `true`, the map will automatically resize when the browser window resizes.
         * @defaultValue true
         */
        trackResize?: boolean;
        /**
         * The initial geographical centerpoint of the map. If `center` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `[0, 0]` Note: MapLibre GL JS uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.
         * @defaultValue [0, 0]
         */
        center?: LngLatLike;
        /**
         * The initial zoom level of the map. If `zoom` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.
         * @defaultValue 0
         */
        zoom?: number;
        /**
         * The initial bearing (rotation) of the map, measured in degrees counter-clockwise from north. If `bearing` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.
         * @defaultValue 0
         */
        bearing?: number;
        /**
         * The initial pitch (tilt) of the map, measured in degrees away from the plane of the screen (0-85). If `pitch` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`. Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
         * @defaultValue 0
         */
        pitch?: number;
        /**
         * The initial roll angle of the map, measured in degrees counter-clockwise about the camera boresight. If `roll` is not specified in the constructor options, MapLibre GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.
         * @defaultValue 0
         */
        roll?: number;
        /**
         * If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:
         *
         * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire
         * container, there will be blank space beyond 180 and -180 degrees longitude.
         * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the
         * map and the other on the left edge of the map) at every zoom level.
         * @defaultValue true
         */
        renderWorldCopies?: boolean;
        /**
         * The maximum number of tiles stored in the tile cache for a given source. If omitted, the cache will be dynamically sized based on the current viewport which can be set using `maxTileCacheZoomLevels` constructor options.
         * @defaultValue null
         */
        maxTileCacheSize?: number | null;
        /**
         * The maximum number of zoom levels for which to store tiles for a given source. Tile cache dynamic size is calculated by multiplying `maxTileCacheZoomLevels` with the approximate number of tiles in the viewport for a given source.
         * @defaultValue 5
         */
        maxTileCacheZoomLevels?: number;
        /**
         * A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
         * Expected to return an object with a `url` property and optionally `headers` and `credentials` properties.
         * @defaultValue null
         */
        transformRequest?: RequestTransformFunction | null;
        /**
         * A callback run before the map's camera is moved due to user input or animation. The callback can be used to modify the new center, zoom, pitch and bearing.
         * Expected to return an object containing center, zoom, pitch or bearing values to overwrite.
         * @defaultValue null
         */
        transformCameraUpdate?: CameraUpdateTransformFunction | null;
        /**
         * A patch to apply to the default localization table for UI strings, e.g. control tooltips. The `locale` object maps namespaced UI string IDs to translated strings in the target language; see `src/ui/default_locale.js` for an example with all supported string IDs. The object may specify all UI strings (thereby adding support for a new translation) or only a subset of strings (thereby patching the default translation table).
         * @defaultValue null
         */
        locale?: any;
        /**
         * Controls the duration of the fade-in/fade-out animation for label collisions after initial map load, in milliseconds. This setting affects all symbol layers. This setting does not affect the duration of runtime styling transitions or raster tile cross-fading.
         * @defaultValue 300
         */
        fadeDuration?: number;
        /**
         * If `true`, symbols from multiple sources can collide with each other during collision detection. If `false`, collision detection is run separately for the symbols in each source.
         * @defaultValue true
         */
        crossSourceCollisions?: boolean;
        /**
         * If `true`, Resource Timing API information will be collected for requests made by GeoJSON and Vector Tile web workers (this information is normally inaccessible from the main Javascript thread). Information will be returned in a `resourceTiming` property of relevant `data` events.
         * @defaultValue false
         */
        collectResourceTiming?: boolean;
        /**
         * The max number of pixels a user can shift the mouse pointer during a click for it to be considered a valid click (as opposed to a mouse drag).
         * @defaultValue 3
         */
        clickTolerance?: number;
        /**
         * The initial bounds of the map. If `bounds` is specified, it overrides `center` and `zoom` constructor options.
         */
        bounds?: LngLatBoundsLike;
        /**
         * A {@link FitBoundsOptions} options object to use _only_ when fitting the initial `bounds` provided above.
         */
        fitBoundsOptions?: FitBoundsOptions;
        /**
         * Defines a CSS
         * font-family for locally overriding generation of Chinese, Japanese, and Korean characters.
         * For these characters, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).
         * Set to `false`, to enable font settings from the map's style for these glyph ranges.
         * The purpose of this option is to avoid bandwidth-intensive glyph server requests. (See [Use locally generated ideographs](https://maplibre.org/maplibre-gl-js/docs/examples/local-ideographs).)
         * @defaultValue 'sans-serif'
         */
        localIdeographFontFamily?: string | false;
        /**
         * The map's MapLibre style. This must be a JSON object conforming to
         * the schema described in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/),
         * or a URL to such JSON.
         * When the style is not specified, calling {@link MapLibreMap#setStyle} is required to render the map.
         */
        style?: StyleSpecification | string;
        /**
         * If `false`, the map's pitch (tilt) control with "drag to rotate" interaction will be disabled.
         * @defaultValue true
         */
        pitchWithRotate?: boolean;
        /**
         * If `false`, the map's roll control with "drag to rotate" interaction will be disabled.
         * @defaultValue false
         */
        rollEnabled?: boolean;
        /**
         * The pixel ratio.
         * The canvas' `width` attribute will be `container.clientWidth * pixelRatio` and its `height` attribute will be `container.clientHeight * pixelRatio`. Defaults to `devicePixelRatio` if not specified.
         */
        pixelRatio?: number;
        /**
         * If false, style validation will be skipped. Useful in production environment.
         * @defaultValue true
         */
        validateStyle?: boolean;
        /**
         * The canvas' `width` and `height` max size. The values are passed as an array where the first element is max width and the second element is max height.
         * You shouldn't set this above WebGl `MAX_TEXTURE_SIZE`.
         * @defaultValue [4096, 4096].
         */
        maxCanvasSize?: [
            number,
            number
        ];
        /**
         * Determines whether to cancel, or retain, tiles from the current viewport which are still loading but which belong to a farther (smaller) zoom level than the current one.
         * * If `true`, when zooming in, tiles which didn't manage to load for previous zoom levels will become canceled. This might save some computing resources for slower devices, but the map details might appear more abruptly at the end of the zoom.
         * * If `false`, when zooming in, the previous zoom level(s) tiles will progressively appear, giving a smoother map details experience. However, more tiles will be rendered in a short period of time.
         * @defaultValue true
         */
        cancelPendingTileRequestsWhileZooming?: boolean;
        /**
         * When true, WebGL1 will be used even when WebGL2 is available.
         */
        forceWebGL1?: boolean;
    };
    type CompleteMapOptions = Complete<MapLibreMapOptions>;
    type DelegatedListener = {
        layers: string[];
        listener: Listener;
        delegates: {
            [E in keyof MapEventType]?: Delegate<MapEventType[E]>;
        };
    };
    type Delegate<E extends Event = Event> = (e: E) => void;
    /**
     * The `Map` object represents the map on your page. It exposes methods
     * and properties that enable you to programmatically change the map,
     * and fires events as users interact with it.
     *
     * You create a `Map` by specifying a `container` and other options, see {@link MapLibreMapOptions} for the full list.
     * Then MapLibre GL JS initializes the map on the page and returns your `Map` object.
     *
     * @group Main
     *
     * @example
     * ```ts
     * let map = new Map({
     *   container: 'map',
     *   center: [-122.420679, 37.772537],
     *   zoom: 13,
     *   style: style_object,
     *   hash: true,
     *   transformRequest: (url, resourceType)=> {
     *     if(resourceType === 'Source' && url.startsWith('http://myHost')) {
     *       return {
     *        url: url.replace('http', 'https'),
     *        headers: { 'my-custom-header': true},
     *        credentials: 'include'  // Include cookies for cross-origin requests
     *      }
     *     }
     *   }
     * });
     * ```
     * @see [Display a map](https://maplibre.org/maplibre-gl-js/docs/examples/simple-map/)
     */
    class MapLibreMap extends Camera {
        style: Style;
        painter: Painter;
        handlers: HandlerManager;
        _container: HTMLElement;
        _canvasContainer: HTMLElement;
        _controlContainer: HTMLElement;
        _controlPositions: Record<string, HTMLElement>;
        _interactive: boolean;
        _showTileBoundaries: boolean;
        _showCollisionBoxes: boolean;
        _showPadding: boolean;
        _showOverdrawInspector: boolean;
        _repaint: boolean;
        _vertices: boolean;
        _canvas: HTMLCanvasElement;
        _maxTileCacheSize: number | null;
        _maxTileCacheZoomLevels: number;
        _frameRequest: AbortController;
        _styleDirty: boolean;
        _sourcesDirty: boolean;
        _loaded: boolean;
        _idleTriggered: boolean;
        _fullyLoaded: boolean;
        _trackResize: boolean;
        _resizeObserver: ResizeObserver;
        _preserveDrawingBuffer: boolean;
        _failIfMajorPerformanceCaveat: boolean;
        _antialias: boolean;
        _refreshExpiredTiles: boolean;
        _hash: Hash;
        _delegatedListeners: Record<string, DelegatedListener[]>;
        _fadeDuration: number;
        _crossSourceCollisions: boolean;
        _crossFadingFactor: number;
        _collectResourceTiming: boolean;
        _renderTaskQueue: TaskQueue;
        _controls: Array<IControl>;
        _mapId: number;
        _localIdeographFontFamily: string | false;
        _validateStyle: boolean;
        _requestManager: RequestManager;
        _locale: typeof defaultLocale;
        _removed: boolean;
        _clickTolerance: number;
        _overridePixelRatio: number | null | undefined;
        _maxCanvasSize: [
            number,
            number
        ];
        _terrainDataCallback: (e: MapStyleDataEvent | MapSourceDataEvent) => void;
        _forceWebGL1: boolean;
        /**
         * @internal
         * image queue throttling handle. To be used later when clean up
         */
        _imageQueueHandle: number;
        /**
         * The map's {@link ScrollZoomHandler}, which implements zooming in and out with a scroll wheel or trackpad.
         * Find more details and examples using `scrollZoom` in the {@link ScrollZoomHandler} section.
         */
        scrollZoom: ScrollZoomHandler;
        /**
         * The map's {@link BoxZoomHandler}, which implements zooming using a drag gesture with the Shift key pressed.
         * Find more details and examples using `boxZoom` in the {@link BoxZoomHandler} section.
         */
        boxZoom: BoxZoomHandler;
        /**
         * The map's {@link DragRotateHandler}, which implements rotating the map while dragging with the right
         * mouse button or with the Control key pressed. Find more details and examples using `dragRotate`
         * in the {@link DragRotateHandler} section.
         */
        dragRotate: DragRotateHandler;
        /**
         * The map's {@link DragPanHandler}, which implements dragging the map with a mouse or touch gesture.
         * Find more details and examples using `dragPan` in the {@link DragPanHandler} section.
         */
        dragPan: DragPanHandler;
        /**
         * The map's {@link KeyboardHandler}, which allows the user to zoom, rotate, and pan the map using keyboard
         * shortcuts. Find more details and examples using `keyboard` in the {@link KeyboardHandler} section.
         */
        keyboard: KeyboardHandler;
        /**
         * The map's {@link DoubleClickZoomHandler}, which allows the user to zoom by double clicking.
         * Find more details and examples using `doubleClickZoom` in the {@link DoubleClickZoomHandler} section.
         */
        doubleClickZoom: DoubleClickZoomHandler;
        /**
         * The map's {@link TwoFingersTouchZoomRotateHandler}, which allows the user to zoom or rotate the map with touch gestures.
         * Find more details and examples using `touchZoomRotate` in the {@link TwoFingersTouchZoomRotateHandler} section.
         */
        touchZoomRotate: TwoFingersTouchZoomRotateHandler;
        /**
         * The map's {@link TwoFingersTouchPitchHandler}, which allows the user to pitch the map with touch gestures.
         * Find more details and examples using `touchPitch` in the {@link TwoFingersTouchPitchHandler} section.
         */
        touchPitch: TwoFingersTouchPitchHandler;
        /**
         * The map's {@link CooperativeGesturesHandler}, which allows the user to see cooperative gesture info when user tries to zoom in/out.
         * Find more details and examples using `cooperativeGestures` in the {@link CooperativeGesturesHandler} section.
         */
        cooperativeGestures: CooperativeGesturesHandler;
        /**
         * The map's property which determines whether to cancel, or retain, tiles from the current viewport which are still loading but which belong to a farther (smaller) zoom level than the current one.
         * * If `true`, when zooming in, tiles which didn't manage to load for previous zoom levels will become canceled. This might save some computing resources for slower devices, but the map details might appear more abruptly at the end of the zoom.
         * * If `false`, when zooming in, the previous zoom level(s) tiles will progressively appear, giving a smoother map details experience. However, more tiles will be rendered in a short period of time.
         * @defaultValue true
         */
        cancelPendingTileRequestsWhileZooming: boolean;
        /**
         * @internal
         */
        layerOrderingRepo: LayerOrderingRepository;
        constructor(options: MapLibreMapOptions);
        /**
         * @internal
         * Returns a unique number for this map instance which is used for the MapLoadEvent
         * to make sure we only fire one event per instantiated map object.
         * @returns the uniq map ID
         */
        _getMapId(): number;
        /**
         * Adds an {@link IControl} to the map, calling `control.onAdd(this)`.
         *
         * An {@link ErrorEvent} will be fired if the image parameter is invalid.
         *
         * @param control - The {@link IControl} to add.
         * @param position - position on the map to which the control will be added.
         * Valid values are `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`.
         * @example
         * Add zoom and rotation controls to the map.
         * ```ts
         * map.addControl(new NavigationControl());
         * ```
         * @see [Display map navigation controls](https://maplibre.org/maplibre-gl-js/docs/examples/navigation/)
         */
        addControl(control: IControl, position?: ControlPosition): MapLibreMap;
        /**
         * Removes the control from the map.
         *
         * An {@link ErrorEvent} will be fired if the image parameter is invalid.
         *
         * @param control - The {@link IControl} to remove.
         * @example
         * ```ts
         * // Define a new navigation control.
         * let navigation = new NavigationControl();
         * // Add zoom and rotation controls to the map.
         * map.addControl(navigation);
         * // Remove zoom and rotation controls from the map.
         * map.removeControl(navigation);
         * ```
         */
        removeControl(control: IControl): MapLibreMap;
        /**
         * Checks if a control exists on the map.
         *
         * @param control - The {@link IControl} to check.
         * @returns true if map contains control.
         * @example
         * ```ts
         * // Define a new navigation control.
         * let navigation = new NavigationControl();
         * // Add zoom and rotation controls to the map.
         * map.addControl(navigation);
         * // Check that the navigation control exists on the map.
         * map.hasControl(navigation);
         * ```
         */
        hasControl(control: IControl): boolean;
        calculateCameraOptionsFromTo(from: LngLat, altitudeFrom: number, to: LngLat, altitudeTo?: number): CameraOptions;
        /**
         * Resizes the map according to the dimensions of its
         * `container` element.
         *
         * Checks if the map container size changed and updates the map if it has changed.
         * This method must be called after the map's `container` is resized programmatically
         * or when the map is shown after being initially hidden with CSS.
         *
         * Triggers the following events: `movestart`, `move`, `moveend`, and `resize`.
         *
         * @param eventData - Additional properties to be passed to `movestart`, `move`, `resize`, and `moveend`
         * events that get triggered as a result of resize. This can be useful for differentiating the
         * source of an event (for example, user-initiated or programmatically-triggered events).
         * @example
         * Resize the map when the map container is shown after being initially hidden with CSS.
         * ```ts
         * let mapDiv = document.getElementById('map');
         * if (mapDiv.style.visibility === true) map.resize();
         * ```
         */
        resize(eventData?: any): MapLibreMap;
        /**
         * @internal
         * Return the map's pixel ratio eventually scaled down to respect maxCanvasSize.
         * Internally you should use this and not getPixelRatio().
         */
        _getClampedPixelRatio(width: number, height: number): number;
        /**
         * Returns the map's pixel ratio.
         * Note that the pixel ratio actually applied may be lower to respect maxCanvasSize.
         * @returns The pixel ratio.
         */
        getPixelRatio(): number;
        /**
         * Sets the map's pixel ratio. This allows to override `devicePixelRatio`.
         * After this call, the canvas' `width` attribute will be `container.clientWidth * pixelRatio`
         * and its height attribute will be `container.clientHeight * pixelRatio`.
         * Set this to null to disable `devicePixelRatio` override.
         * Note that the pixel ratio actually applied may be lower to respect maxCanvasSize.
         * @param pixelRatio - The pixel ratio.
         */
        setPixelRatio(pixelRatio: number): void;
        /**
         * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not
         * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.
         * @returns The geographical bounds of the map as {@link LngLatBounds}.
         * @example
         * ```ts
         * let bounds = map.getBounds();
         * ```
         */
        getBounds(): LngLatBounds;
        /**
         * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.
         * @returns The map object.
         * @example
         * ```ts
         * let maxBounds = map.getMaxBounds();
         * ```
         */
        getMaxBounds(): LngLatBounds | null;
        /**
         * Sets or clears the map's geographical bounds.
         *
         * Pan and zoom operations are constrained within these bounds.
         * If a pan or zoom is performed that would
         * display regions outside these bounds, the map will
         * instead display a position and zoom level
         * as close as possible to the operation's request while still
         * remaining within the bounds.
         *
         * @param bounds - The maximum bounds to set. If `null` or `undefined` is provided, the function removes the map's maximum bounds.
         * @example
         * Define bounds that conform to the `LngLatBoundsLike` object as set the max bounds.
         * ```ts
         * let bounds = [
         *   [-74.04728, 40.68392], // [west, south]
         *   [-73.91058, 40.87764]  // [east, north]
         * ];
         * map.setMaxBounds(bounds);
         * ```
         */
        setMaxBounds(bounds?: LngLatBoundsLike | null): MapLibreMap;
        /**
         * Sets or clears the map's minimum zoom level.
         * If the map's current zoom level is lower than the new minimum,
         * the map will zoom to the new minimum.
         *
         * It is not always possible to zoom out and reach the set `minZoom`.
         * Other factors such as map height may restrict zooming. For example,
         * if the map is 512px tall it will not be possible to zoom below zoom 0
         * no matter what the `minZoom` is set to.
         *
         * A {@link ErrorEvent} event will be fired if minZoom is out of bounds.
         *
         * @param minZoom - The minimum zoom level to set (-2 - 24).
         * If `null` or `undefined` is provided, the function removes the current minimum zoom (i.e. sets it to -2).
         * @example
         * ```ts
         * map.setMinZoom(12.25);
         * ```
         */
        setMinZoom(minZoom?: number | null): MapLibreMap;
        /**
         * Returns the map's minimum allowable zoom level.
         *
         * @returns minZoom
         * @example
         * ```ts
         * let minZoom = map.getMinZoom();
         * ```
         */
        getMinZoom(): number;
        /**
         * Sets or clears the map's maximum zoom level.
         * If the map's current zoom level is higher than the new maximum,
         * the map will zoom to the new maximum.
         *
         * A {@link ErrorEvent} event will be fired if minZoom is out of bounds.
         *
         * @param maxZoom - The maximum zoom level to set.
         * If `null` or `undefined` is provided, the function removes the current maximum zoom (sets it to 22).
         * @example
         * ```ts
         * map.setMaxZoom(18.75);
         * ```
         */
        setMaxZoom(maxZoom?: number | null): MapLibreMap;
        /**
         * Returns the map's maximum allowable zoom level.
         *
         * @returns The maxZoom
         * @example
         * ```ts
         * let maxZoom = map.getMaxZoom();
         * ```
         */
        getMaxZoom(): number;
        /**
         * Sets or clears the map's minimum pitch.
         * If the map's current pitch is lower than the new minimum,
         * the map will pitch to the new minimum.
         *
         * A {@link ErrorEvent} event will be fired if minPitch is out of bounds.
         *
         * @param minPitch - The minimum pitch to set (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
         * If `null` or `undefined` is provided, the function removes the current minimum pitch (i.e. sets it to 0).
         */
        setMinPitch(minPitch?: number | null): MapLibreMap;
        /**
         * Returns the map's minimum allowable pitch.
         *
         * @returns The minPitch
         */
        getMinPitch(): number;
        /**
         * Sets or clears the map's maximum pitch.
         * If the map's current pitch is higher than the new maximum,
         * the map will pitch to the new maximum.
         *
         * A {@link ErrorEvent} event will be fired if maxPitch is out of bounds.
         *
         * @param maxPitch - The maximum pitch to set (0-85). Values greater than 60 degrees are experimental and may result in rendering issues. If you encounter any, please raise an issue with details in the MapLibre project.
         * If `null` or `undefined` is provided, the function removes the current maximum pitch (sets it to 60).
         */
        setMaxPitch(maxPitch?: number | null): MapLibreMap;
        /**
         * Returns the map's maximum allowable pitch.
         *
         * @returns The maxPitch
         */
        getMaxPitch(): number;
        /**
         * Returns the state of `renderWorldCopies`. If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:
         *
         * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire
         * container, there will be blank space beyond 180 and -180 degrees longitude.
         * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the
         * map and the other on the left edge of the map) at every zoom level.
         * @returns The renderWorldCopies
         * @example
         * ```ts
         * let worldCopiesRendered = map.getRenderWorldCopies();
         * ```
         * @see [Render world copies](https://maplibre.org/maplibre-gl-js/docs/examples/render-world-copies/)
         */
        getRenderWorldCopies(): boolean;
        /**
         * Sets the state of `renderWorldCopies`.
         *
         * @param renderWorldCopies - If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:
         *
         * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire
         * container, there will be blank space beyond 180 and -180 degrees longitude.
         * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the
         * map and the other on the left edge of the map) at every zoom level.
         *
         * `undefined` is treated as `true`, `null` is treated as `false`.
         * @example
         * ```ts
         * map.setRenderWorldCopies(true);
         * ```
         * @see [Render world copies](https://maplibre.org/maplibre-gl-js/docs/examples/render-world-copies/)
         */
        setRenderWorldCopies(renderWorldCopies?: boolean | null): MapLibreMap;
        /**
         * Returns a [Point](https://github.com/mapbox/point-geometry) representing pixel coordinates, relative to the map's `container`,
         * that correspond to the specified geographical location.
         *
         * @param lnglat - The geographical location to project.
         * @returns The [Point](https://github.com/mapbox/point-geometry) corresponding to `lnglat`, relative to the map's `container`.
         * @example
         * ```ts
         * let coordinate = [-122.420679, 37.772537];
         * let point = map.project(coordinate);
         * ```
         */
        project(lnglat: LngLatLike): Point;
        /**
         * Returns a {@link LngLat} representing geographical coordinates that correspond
         * to the specified pixel coordinates.
         *
         * @param point - The pixel coordinates to unproject.
         * @returns The {@link LngLat} corresponding to `point`.
         * @example
         * ```ts
         * map.on('click', (e) => {
         *   // When the map is clicked, get the geographic coordinate.
         *   let coordinate = map.unproject(e.point);
         * });
         * ```
         */
        unproject(point: PointLike): LngLat;
        /**
         * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
         * @returns true if the map is moving.
         * @example
         * ```ts
         * let isMoving = map.isMoving();
         * ```
         */
        isMoving(): boolean;
        /**
         * Returns true if the map is zooming due to a camera animation or user gesture.
         * @returns true if the map is zooming.
         * @example
         * ```ts
         * let isZooming = map.isZooming();
         * ```
         */
        isZooming(): boolean;
        /**
         * Returns true if the map is rotating due to a camera animation or user gesture.
         * @returns true if the map is rotating.
         * @example
         * ```ts
         * map.isRotating();
         * ```
         */
        isRotating(): boolean;
        _saveDelegatedListener(type: keyof MapEventType | string, delegatedListener: DelegatedListener): void;
        _removeDelegatedListener(type: string, layerIds: string[], listener: Listener): void;
        /**
         * @event
         * Adds a listener for events of a specified type, optionally limited to features in a specified style layer(s).
         * See {@link MapEventType} and {@link MapLayerEventType} for a full list of events and their description.
         *
         * | Event                  | Compatible with `layerId` |
         * |------------------------|---------------------------|
         * | `mousedown`            | yes                       |
         * | `mouseup`              | yes                       |
         * | `mouseover`            | yes                       |
         * | `mouseout`             | yes                       |
         * | `mousemove`            | yes                       |
         * | `mouseenter`           | yes (required)            |
         * | `mouseleave`           | yes (required)            |
         * | `click`                | yes                       |
         * | `dblclick`             | yes                       |
         * | `contextmenu`          | yes                       |
         * | `touchstart`           | yes                       |
         * | `touchend`             | yes                       |
         * | `touchcancel`          | yes                       |
         * | `wheel`                |                           |
         * | `resize`               |                           |
         * | `remove`               |                           |
         * | `touchmove`            |                           |
         * | `movestart`            |                           |
         * | `move`                 |                           |
         * | `moveend`              |                           |
         * | `dragstart`            |                           |
         * | `drag`                 |                           |
         * | `dragend`              |                           |
         * | `zoomstart`            |                           |
         * | `zoom`                 |                           |
         * | `zoomend`              |                           |
         * | `rotatestart`          |                           |
         * | `rotate`               |                           |
         * | `rotateend`            |                           |
         * | `pitchstart`           |                           |
         * | `pitch`                |                           |
         * | `pitchend`             |                           |
         * | `boxzoomstart`         |                           |
         * | `boxzoomend`           |                           |
         * | `boxzoomcancel`        |                           |
         * | `webglcontextlost`     |                           |
         * | `webglcontextrestored` |                           |
         * | `load`                 |                           |
         * | `render`               |                           |
         * | `idle`                 |                           |
         * | `error`                |                           |
         * | `data`                 |                           |
         * | `styledata`            |                           |
         * | `sourcedata`           |                           |
         * | `dataloading`          |                           |
         * | `styledataloading`     |                           |
         * | `sourcedataloading`    |                           |
         * | `styleimagemissing`    |                           |
         * | `dataabort`            |                           |
         * | `sourcedataabort`      |                           |
         *
         * @param type - The event type to listen for. Events compatible with the optional `layerId` parameter are triggered
         * when the cursor enters a visible portion of the specified layer from outside that layer or outside the map canvas.
         * @param listener - The function to be called when the event is fired.
         * @example
         * ```ts
         * // Set an event listener that will fire
         * // when the map has finished loading
         * map.on('load', () => {
         *   // Once the map has finished loading,
         *   // add a new layer
         *   map.addLayer({
         *     id: 'points-of-interest',
         *     source: {
         *       type: 'vector',
         *       url: 'https://maplibre.org/maplibre-style-spec/'
         *     },
         *     'source-layer': 'poi_label',
         *     type: 'circle',
         *     paint: {
         *       // MapLibre Style Specification paint properties
         *     },
         *     layout: {
         *       // MapLibre Style Specification layout properties
         *     }
         *   });
         * });
         * ```
         * @example
         * ```ts
         * // Set an event listener that will fire
         * // when a feature on the countries layer of the map is clicked
         * map.on('click', 'countries', (e) => {
         *   new Popup()
         *     .setLngLat(e.lngLat)
         *     .setHTML(`Country name: ${e.features[0].properties.name}`)
         *     .addTo(map);
         * });
         * ```
         * @see [Display popup on click](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-click/)
         * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
         * @see [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
         * @see [Create a draggable marker](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        on(type: keyof MapEventType | string | "style.load", listener: Listener): this;
        /**
         * Adds a listener that will be called only once to a specified event type, optionally limited to features in a specified style layer.
         *
         * @event
         * @param type - The event type to listen for; one of `'mousedown'`, `'mouseup'`, `'click'`, `'dblclick'`,
         * `'mousemove'`, `'mouseenter'`, `'mouseleave'`, `'mouseover'`, `'mouseout'`, `'contextmenu'`, `'touchstart'`,
         * `'touchend'`, or `'touchcancel'`. `mouseenter` and `mouseover` events are triggered when the cursor enters
         * a visible portion of the specified layer from outside that layer or outside the map canvas. `mouseleave`
         * and `mouseout` events are triggered when the cursor leaves a visible portion of the specified layer, or leaves
         * the map canvas.
         * @param listener - The function to be called when the event is fired.
         * @returns `this` if listener is provided, promise otherwise to allow easier usage of async/await
         */
        once(type: keyof MapEventType | string, listener?: Listener): this | Promise<any>;
        /**
         * Removes an event listener for events previously added with `Map#on`.
         *
         * @event
         * @param type - The event type previously used to install the listener.
         * @param layer - The layer ID or listener previously used to install the listener.
         * @param listener - The function previously installed as a listener.
         */
        off<T extends keyof MapLayerEventType>(type: T, layer: string, listener: (ev: MapLayerEventType[T] & Object) => void): this;
        /**
         * Overload of the `off` method that allows to remove an event created with multiple layers.
         * Provide the same layer IDs as to `on` or `once`, when the listener was registered.
         * @event
         * @param type - The type of the event.
         * @param layers - The layer IDs previously used to install the listener.
         * @param listener - The function previously installed as a listener.
         */
        off<T extends keyof MapLayerEventType>(type: T, layers: string[], listener: (ev: MapLayerEventType[T] & Object) => void): this;
        /**
         * Overload of the `off` method that allows to remove an event created without specifying a layer.
         * @event
         * @param type - The type of the event.
         * @param listener - The function previously installed as a listener.
         */
        off<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & Object) => void): this;
        /**
         * Overload of the `off` method that allows to remove an event created without specifying a layer.
         * @event
         * @param type - The type of the event.
         * @param listener - The function previously installed as a listener.
         */
        off(type: keyof MapEventType | string, listener: Listener): this;
        /**
         * Updates the map's MapLibre style object with a new value.
         *
         * If a style is already set when this is used and options.diff is set to true, the map renderer will attempt to compare the given style
         * against the map's current state and perform only the changes necessary to make the map style match the desired state. Changes in sprites
         * (images used for icons and patterns) and glyphs (fonts for label text) **cannot** be diffed. If the sprites or fonts used in the current
         * style and the given style are different in any way, the map renderer will force a full update, removing the current style and building
         * the given one from scratch.
         *
         *
         * @param style - A JSON object conforming to the schema described in the
         * [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/), or a URL to such JSON.
         * @param options - The options object.
         *
         * @example
         * ```ts
         * map.setStyle("https://demotiles.maplibre.org/style.json");
         *
         * map.setStyle('https://demotiles.maplibre.org/style.json', {
         *   transformStyle: (previousStyle, nextStyle) => ({
         *       ...nextStyle,
         *       sources: {
         *           ...nextStyle.sources,
         *           // copy a source from previous style
         *           'osm': previousStyle.sources.osm
         *       },
         *       layers: [
         *           // background layer
         *           nextStyle.layers[0],
         *           // copy a layer from previous style
         *           previousStyle.layers[0],
         *           // other layers from the next style
         *           ...nextStyle.layers.slice(1).map(layer => {
         *               // hide the layers we don't need from demotiles style
         *               if (layer.id.startsWith('geolines')) {
         *                   layer.layout = {...layer.layout || {}, visibility: 'none'};
         *               // filter out US polygons
         *               } else if (layer.id.startsWith('coastline') || layer.id.startsWith('countries')) {
         *                   layer.filter = ['!=', ['get', 'ADM0_A3'], 'USA'];
         *               }
         *               return layer;
         *           })
         *       ]
         *   })
         * });
         * ```
         */
        setStyle(style: StyleSpecification | string | null, options?: StyleSwapOptions & StyleOptions): this;
        /**
         *  Updates the requestManager's transform request with a new function
         *
         * @param transformRequest - A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
         * Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
         *
         * @example
         * ```ts
         * map.setTransformRequest((url: string, resourceType: string) => {});
         * ```
         */
        setTransformRequest(transformRequest: RequestTransformFunction): this;
        _getUIString(key: keyof typeof defaultLocale): string;
        _updateStyle(style: StyleSpecification | string | null, options?: StyleSwapOptions & StyleOptions): this;
        _lazyInitEmptyStyle(): void;
        _diffStyle(style: StyleSpecification | string, options?: StyleSwapOptions & StyleOptions): void;
        _updateDiff(style: StyleSpecification, options?: StyleSwapOptions & StyleOptions): void;
        /**
         * Returns the map's MapLibre style object, a JSON object which can be used to recreate the map's style.
         *
         * @returns The map's style JSON object.
         *
         * @example
         * ```ts
         * let styleJson = map.getStyle();
         * ```
         *
         */
        getStyle(): StyleSpecification;
        /**
         * Returns a Boolean indicating whether the map's style is fully loaded.
         *
         * @returns A Boolean indicating whether the style is fully loaded.
         *
         * @example
         * ```ts
         * let styleLoadStatus = map.isStyleLoaded();
         * ```
         */
        isStyleLoaded(): boolean | void;
        /**
         * Adds a source to the map's style.
         *
         * Events triggered:
         *
         * Triggers the `source.add` event.
         *
         * @param id - The ID of the source to add. Must not conflict with existing sources.
         * @param source - The source object, conforming to the
         * MapLibre Style Specification's [source definition](https://maplibre.org/maplibre-style-spec/sources) or
         * {@link CanvasSourceSpecification}.
         * @example
         * ```ts
         * map.addSource('my-data', {
         *   type: 'vector',
         *   url: 'https://demotiles.maplibre.org/tiles/tiles.json'
         * });
         * ```
         * @example
         * ```ts
         * map.addSource('my-data', {
         *   "type": "geojson",
         *   "data": {
         *     "type": "Feature",
         *     "geometry": {
         *       "type": "Point",
         *       "coordinates": [-77.0323, 38.9131]
         *     },
         *     "properties": {
         *       "title": "Mapbox DC",
         *       "marker-symbol": "monument"
         *     }
         *   }
         * });
         * ```
         * @see GeoJSON source: [Add live realtime data](https://maplibre.org/maplibre-gl-js/docs/examples/live-geojson/)
         */
        addSource(id: string, source: SourceSpecification | RasterSourceSpecificationWithRetina): this;
        /**
         * Returns a Boolean indicating whether the source is loaded. Returns `true` if the source with
         * the given ID in the map's style has no outstanding network requests, otherwise `false`.
         *
         * A {@link ErrorEvent} event will be fired if there is no source wit the specified ID.
         *
         * @param id - The ID of the source to be checked.
         * @returns A Boolean indicating whether the source is loaded.
         * @example
         * ```ts
         * let sourceLoaded = map.isSourceLoaded('bathymetry-data');
         * ```
         */
        isSourceLoaded(id: string): boolean;
        /**
         * Returns a Boolean indicating whether all tiles in the viewport from all sources on
         * the style are loaded.
         *
         * @returns A Boolean indicating whether all tiles are loaded.
         * @example
         * ```ts
         * let tilesLoaded = map.areTilesLoaded();
         * ```
         */
        areTilesLoaded(): boolean;
        /**
         * Removes a source from the map's style.
         *
         * @param id - The ID of the source to remove.
         * @example
         * ```ts
         * map.removeSource('bathymetry-data');
         * ```
         */
        removeSource(id: string): MapLibreMap;
        /**
         * Returns the source with the specified ID in the map's style.
         *
         * This method is often used to update a source using the instance members for the relevant
         * source type as defined in classes that derive from {@link Source}.
         * For example, setting the `data` for a GeoJSON source or updating the `url` and `coordinates`
         * of an image source.
         *
         * @param id - The ID of the source to get.
         * @returns The style source with the specified ID or `undefined` if the ID
         * corresponds to no existing sources.
         * The shape of the object varies by source type.
         * A list of options for each source type is available on the MapLibre Style Specification's
         * [Sources](https://maplibre.org/maplibre-style-spec/sources/) page.
         * @example
         * ```ts
         * let sourceObject = map.getSource('points');
         * ```
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         * @see [Animate a point](https://maplibre.org/maplibre-gl-js/docs/examples/animate-point-along-line/)
         * @see [Add live realtime data](https://maplibre.org/maplibre-gl-js/docs/examples/live-geojson/)
         */
        getSource<TSource extends Source>(id: string): TSource | undefined;
        /**
         * @internal
         * @deprecated
         *
         * **Legacy API! In LeafletGL use {@link addLayerToBucket} instead!**
         *
         * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
         * to the map's style.
         *
         * A layer defines how data from a specified source will be styled. Read more about layer types
         * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
         *
         * @param layer - The layer to add,
         * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
         * less commonly, the {@link CustomLayerInterface} specification. Can also be a layer definition with an embedded source definition.
         * The MapLibre Style Specification's layer definition is appropriate for most layers.
         *
         * @param beforeId - The ID of an existing layer to insert the new layer before,
         * resulting in the new layer appearing visually beneath the existing layer.
         * If this argument is not specified, the layer will be appended to the end of the layers array
         * and appear visually above all other layers.
         *
         * @example
         * Add a circle layer with a vector source
         * ```ts
         * map.addLayer({
         *   id: 'points-of-interest',
         *   source: {
         *     type: 'vector',
         *     url: 'https://demotiles.maplibre.org/tiles/tiles.json'
         *   },
         *   'source-layer': 'poi_label',
         *   type: 'circle',
         *   paint: {
         *     // MapLibre Style Specification paint properties
         *   },
         *   layout: {
         *     // MapLibre Style Specification layout properties
         *   }
         * });
         * ```
         *
         * @example
         * Define a source before using it to create a new layer
         * ```ts
         * map.addSource('state-data', {
         *   type: 'geojson',
         *   data: 'path/to/data.geojson'
         * });
         *
         * map.addLayer({
         *   id: 'states',
         *   // References the GeoJSON source defined above
         *   // and does not require a `source-layer`
         *   source: 'state-data',
         *   type: 'symbol',
         *   layout: {
         *     // Set the label content to the
         *     // feature's `name` property
         *     text-field: ['get', 'name']
         *   }
         * });
         * ```
         *
         * @example
         * Add a new symbol layer before an existing layer
         * ```ts
         * map.addLayer({
         *   id: 'states',
         *   // References a source that's already been defined
         *   source: 'state-data',
         *   type: 'symbol',
         *   layout: {
         *     // Set the label content to the
         *     // feature's `name` property
         *     text-field: ['get', 'name']
         *   }
         * // Add the layer before the existing `cities` layer
         * }, 'cities');
         * ```
         * @see [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/cluster/)
         * @see [Add a vector tile source](https://maplibre.org/maplibre-gl-js/docs/examples/vector-source/)
         * @see [Add a WMS source](https://maplibre.org/maplibre-gl-js/docs/examples/wms/)
         */
        addLayer(layer: AddLayerObject, beforeId?: string): this;
        /**
         * Adds a style layer. Uses the specified layer bucket, ensuring correct ordering of layers.
         * @param layer - Layer to add.
         * @param bucketId - Numerical id of the bucket where the layer will be added. This determines layer ordering.
         */
        addLayerToBucket(layer: AddLayerObject, bucketId?: number): this;
        /**
         * Move a style layer. Uses the specified layer bucket, ensuring correct ordering of layers.
         * @param layer - Layer to move.
         * @param bucketId - Numerical id of the bucket to where the layer will be moved. This determines layer ordering.
         */
        moveLayerToBucket(layerId: string, buckedId: number): this;
        /**
         * Removes the layer with the given ID from the map's style.
         *
         * An {@link ErrorEvent} will be fired if the image parameter is invalid.
         *
         * @param id - The ID of the layer to remove
         *
         * @example
         * If a layer with ID 'state-data' exists, remove it.
         * ```ts
         * if (map.getLayer('state-data')) map.removeLayer('state-data');
         * ```
         */
        removeLayer(id: string): this;
        /**
         * Returns the layer with the specified ID in the map's style.
         *
         * @param id - The ID of the layer to get.
         * @returns The layer with the specified ID, or `undefined`
         * if the ID corresponds to no existing layers.
         *
         * @example
         * ```ts
         * let stateDataLayer = map.getLayer('state-data');
         * ```
         * @see [Filter symbols by toggling a list](https://maplibre.org/maplibre-gl-js/docs/examples/filter-markers/)
         * @see [Filter symbols by text input](https://maplibre.org/maplibre-gl-js/docs/examples/filter-markers-by-input/)
         */
        getLayer(id: string): StyleLayer | undefined;
        /**
         * Return the ids of all layers currently in the style, including custom layers, in order.
         *
         * @returns ids of layers, in order
         *
         * @example
         * ```ts
         * const orderedLayerIds = map.getLayersOrder();
         * ```
         */
        getLayersOrder(): string[];
        /**
         * Sets the zoom extent for the specified style layer. The zoom extent includes the
         * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
         * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
         * at which the layer will be rendered.
         *
         * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
         * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
         * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
         * layer will not be rendered at all zoom levels in the zoom range.
         *
         * @param layerId - The ID of the layer to which the zoom extent will be applied.
         * @param minzoom - The minimum zoom to set (0-24).
         * @param maxzoom - The maximum zoom to set (0-24).
         *
         * @example
         * ```ts
         * map.setLayerZoomRange('my-layer', 2, 5);
         * ```
         */
        setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this;
        /**
         * Returns the map's containing HTML element.
         *
         * @returns The map's container.
         */
        getContainer(): HTMLElement;
        /**
         * Returns the HTML element containing the map's `<canvas>` element.
         *
         * If you want to add non-GL overlays to the map, you should append them to this element.
         *
         * This is the element to which event bindings for map interactivity (such as panning and zooming) are
         * attached. It will receive bubbled events from child elements such as the `<canvas>`, but not from
         * map controls.
         *
         * @returns The container of the map's `<canvas>`.
         * @see [Create a draggable point](https://maplibre.org/maplibre-gl-js/docs/examples/drag-a-point/)
         */
        getCanvasContainer(): HTMLElement;
        /**
         * Returns the map's `<canvas>` element.
         *
         * @returns The map's `<canvas>` element.
         * @see [Measure distances](https://maplibre.org/maplibre-gl-js/docs/examples/measure/)
         * @see [Display a popup on hover](https://maplibre.org/maplibre-gl-js/docs/examples/popup-on-hover/)
         * @see [Center the map on a clicked symbol](https://maplibre.org/maplibre-gl-js/docs/examples/center-on-symbol/)
         */
        getCanvas(): HTMLCanvasElement;
        _containerDimensions(): number[];
        _setupContainer(): void;
        _resizeCanvas(width: number, height: number, pixelRatio: number): void;
        _setupPainter(): void;
        migrateProjection(newTransform: ITransform, newCameraHelper: ICameraHelper): void;
        _contextLost: (event: any) => void;
        _contextRestored: (event: any) => void;
        _onMapScroll: (event: any) => boolean;
        /**
         * Returns a Boolean indicating whether the map is fully loaded.
         *
         * Returns `false` if the style is not yet fully loaded,
         * or if there has been a change to the sources or style that
         * has not yet fully loaded.
         *
         * @returns A Boolean indicating whether the map is fully loaded.
         */
        loaded(): boolean;
        /**
         * @internal
         * Update this map's style and sources, and re-render the map.
         *
         * @param updateStyle - mark the map's style for reprocessing as
         * well as its sources
         */
        _update(updateStyle?: boolean): this;
        /**
         * @internal
         * Request that the given callback be executed during the next render
         * frame.  Schedule a render frame if one is not already scheduled.
         *
         * @returns An id that can be used to cancel the callback
         */
        _requestRenderFrame(callback: () => void): TaskID;
        _cancelRenderFrame(id: TaskID): void;
        /**
         * @internal
         * Call when a (re-)render of the map is required:
         *
         * - The style has changed (`setPaintProperty()`, etc.)
         * - Source data has changed (e.g. tiles have finished loading)
         * - The map has is moving (or just finished moving)
         * - A transition is in progress
         *
         * @param paintStartTimeStamp - The time when the animation frame began executing.
         */
        _render(paintStartTimeStamp: number): this;
        /**
         * Force a synchronous redraw of the map.
         * @example
         * ```ts
         * map.redraw();
         * ```
         */
        redraw(): this;
        /**
         * Clean up and release all internal resources associated with this map.
         *
         * This includes DOM elements, event bindings, web workers, and WebGL resources.
         *
         * Use this method when you are done using the map and wish to ensure that it no
         * longer consumes browser resources. Afterwards, you must not call any other
         * methods on the map.
         */
        remove(): void;
        /**
         * Trigger the rendering of a single frame. Use this method with custom layers to
         * repaint the map when the layer changes. Calling this multiple times before the
         * next frame is rendered will still result in only a single frame being rendered.
         * @example
         * ```ts
         * map.triggerRepaint();
         * ```
         * @see [Add a 3D model](https://maplibre.org/maplibre-gl-js/docs/examples/add-3d-model/)
         * @see [Add an animated icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-animated/)
         */
        triggerRepaint(): void;
        _onWindowOnline: () => void;
        /**
         * Gets and sets a Boolean indicating whether the map will render an outline
         * around each tile and the tile ID. These tile boundaries are useful for
         * debugging.
         *
         * The uncompressed file size of the first vector source is drawn in the top left
         * corner of each tile, next to the tile ID.
         *
         * @example
         * ```ts
         * map.showTileBoundaries = true;
         * ```
         */
        get showTileBoundaries(): boolean;
        set showTileBoundaries(value: boolean);
        /**
         * Gets and sets a Boolean indicating whether the map will visualize
         * the padding offsets.
         */
        get showPadding(): boolean;
        set showPadding(value: boolean);
        /**
         * Gets and sets a Boolean indicating whether the map should color-code
         * each fragment to show how many times it has been shaded.
         * White fragments have been shaded 8 or more times.
         * Black fragments have been shaded 0 times.
         * This information is useful for debugging.
         */
        get showOverdrawInspector(): boolean;
        set showOverdrawInspector(value: boolean);
        /**
         * Gets and sets a Boolean indicating whether the map will
         * continuously repaint. This information is useful for analyzing performance.
         */
        get repaint(): boolean;
        set repaint(value: boolean);
        get vertices(): boolean;
        set vertices(value: boolean);
        /**
         * Returns the package version of the library
         * @returns Package version of the library
         */
        get version(): string;
        /**
         * Returns the elevation for the point where the camera is looking.
         * This value corresponds to:
         * "meters above sea level" * "exaggeration"
         * @returns The elevation.
         */
        getCameraTargetElevation(): number;
    }
    type ControlPosition$1 = "topleft" | "topright" | "bottomleft" | "bottomright";
    type ControlOptions = {
        /**
         * The position of the control (one of the map corners).
         * Possible values are `'topleft'`, `'topright'`, `'bottomleft'` or `'bottomright'`.
         */
        position?: ControlPosition$1;
    };
    abstract class Control {
        static defaultOptions: Required<ControlOptions>;
        options: Required<ControlOptions>;
        protected _map: LeafletGlMap | null;
        protected _container: HTMLElement;
        constructor(options?: ControlOptions);
        getPosition(): ControlPosition$1;
        /**
         * Sets the position of the control.
         */
        setPosition(position: ControlPosition$1): this;
        /**
         * Returns the HTMLElement that contains the control.
         */
        getContainer(): HTMLElement;
        /**
         * Adds the control to the given map.
         */
        addTo(map: LeafletGlMap): this;
        /**
         * Removes the control from the map it is currently active on.
         */
        remove(): this;
        /**
         * Called when the control is added to the map. Creates and returns the HTMLElement containing the control.
         */
        protected abstract onAdd(map: LeafletGlMap): HTMLElement;
        /**
         * Called when the control is removed from the map.
         */
        protected abstract onRemove(map: LeafletGlMap): void;
        protected _refocusOnMap(e: {
            screenX: number;
            screenY: number;
        }): void;
    }
    type MapPaneNameBuiltIn = "mapPane" | "tilePane" | "overlayPane" | "shadowPane" | "markerPane" | "tooltipPane" | "popupPane";
    type MapPaneName = MapPaneNameBuiltIn | string;
    type ZoomOptions = {
        animate?: boolean | undefined;
    };
    type FitBoundsOptions$1 = ZoomOptions & {
        /**
         * Padding in pixels. Passed to MapLibre.
         */
        padding?: number;
        animate?: boolean;
        paddingTopLeft?: PointExpression;
        paddingBottomRight?: PointExpression;
    };
    type PanOptions = {
        animate?: boolean | undefined;
        duration?: number | undefined;
        easeLinearity?: number | undefined;
        noMoveStart?: boolean | undefined;
    };
    type FitBoundsOptionsLeaf = ZoomOptions & PanOptions & {
        paddingTopLeft?: PointExpression | undefined;
        paddingBottomRight?: PointExpression | undefined;
        padding?: PointExpression | undefined;
        maxZoom?: number | undefined;
    };
    type DomFirableEventTypes = "click" | "dblclick" | "mousedown" | "mouseup" | "mouseover" | "mouseout" | "mousemove" | "contextmenu" | "keypress" | "keydown" | "keyup" | "preclick";
    /**
     * Map creation options. Compared to leaflet, several fields are omitted:
     *
     * - `worldCopyJump`: always true
     * - `zoomAnimationThreshold`: irrelevant, zoom is always animated
     * - `fadeAnimation`: always false, settings doesn't seem to have any effect in MapLibre
     * - `zoomAnimation`: always true, animated zoom is non-issue in MapLibre
     * - `markerZoomAnimation`
     */
    type LeafletGlMapOptions = {
        /**
         * The initial center of the map.
         */
        center?: LatLngExpression;
        /**
         * The initial zoom level of the map.
         */
        zoom?: number;
        /**
         * Minimum zoom level of the map.
         * If not specified and at least one `GridLayer` or `TileLayer` is in the map,
         * the lowest of their `minZoom` options will be used instead.
         */
        minZoom?: number | null;
        /**
         * Maximum zoom level of the map.
         * If not specified and at least one `GridLayer` or `TileLayer` is in the map,
         * the highest of their `maxZoom` options will be used instead.
         */
        maxZoom?: number | null;
        /**
         * Layers of the map.
         */
        layers?: Layer[];
        /**
         * When this option is set, the map restricts the view to the given
         * geographical bounds, bouncing the user back if the user tries to pan
         * outside the view. To set the restriction dynamically, use
         * {@link LeafletGlMap.setMaxBounds} method.
         */
        maxBounds?: MapBounds | null;
        /**
         * The default method for drawing vector layers on the map. `SVGRenderer`
         * or `CanvasRenderer` by default depending on browser support.
         */
        renderer?: RendererBase | null;
        /**
         * Forces the map's zoom level to always be a multiple of this, particularly
         * right after a {@link LeafletGlMap.fitBounds} or a pinch-zoom.
         * By default, the zoom level snaps to the nearest integer; lower values
         * (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
         * means the zoom level will not be snapped after {@link LeafletGlMap.fitBounds} or a pinch-zoom.
         * @default 1
         */
        zoomSnap?: number;
        /**
         * Controls how much the map's zoom level will change after a
         * {@link LeafletGlMap.zoomIn}, {@link LeafletGlMap.zoomOut}, pressing `+`
         * or `-` on the keyboard, or using the zoom control.
         * Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
         * @default 1
         */
        zoomDelta?: number;
        /**
         * Set it to `false` if you don't want popups to close when user clicks the map.
         * @default true
         */
        closePopupOnClick?: boolean;
        /**
         * Whether to use canvas to render paths instead of SVG.
         */
        preferCanvas?: boolean;
        /**
         * When true, allows the user to zoom and pan the map using the keyboard.
         */
        keyboard?: boolean;
        /**
         * Whether attribution is displayed.
         */
        attributionControl?: boolean;
        /**
         * Optional setting to enable DOM-content being visibile (and updated) during zooming
         */
        displayDuringZoom?: boolean;
        /**
         * Max allowed pixel ratio for CanvasLayer instances. Set to undefined for unlimited pixel ratio.
         */
        maxCanvasRatio?: number | null;
        /**
         * When true, WebGL1 will be used even when WebGL2 is available.
         */
        forceWebGL1?: boolean;
        /**
         * Whether a zoom control is added to the map by default.
         */
        zoomControl?: boolean;
        /**
         * Enable or disable double click zoom.
         * @default true
         */
        doubleClickZoom?: boolean;
        /**
         * Enable or disable scroll wheel zoom.
         * @default true
         */
        scrollWheelZoom?: boolean | AroundCenterOptions;
        /**
         * Enable or disable drag panning.
         * @default true
         */
        dragging?: boolean;
        /**
         * Enable or disable touch zoom.
         * @default true
         */
        touchZoom?: boolean | AroundCenterOptions;
    };
    /**
     * The main LeafletGL map object. Creates a MapLibre map internally.
     * You can either you the leaflet-like API on this object, or access the MapLibre map directly with {@link maplibreMap}.
     *
     * @example
     * ```js
     * // Create a map in a div with the id "map"
     * const map = new LeafletGlMap("map");
     * ```
     */
    class LeafletGlMap extends LeafletEvented {
        static defaultOptions: Required<LeafletGlMapOptions>;
        options: Required<LeafletGlMapOptions>;
        /**
         * @internal
         * Injected from popup.ts to avoid circular dependency.
         */
        static Popup: any;
        /**
         * @internal
         * Injected from tooltip.ts to avoid circular dependency.
         */
        static Tooltip: any;
        private _maplibreMap;
        get maplibreMap(): MapLibreMap;
        private _baseContainer?;
        private _lastZoomHandleUpdateZoom;
        private _layers;
        private _pixelOrigin;
        private _interactiveTargets;
        private _mapPane;
        private _panes;
        private _controlCorners?;
        private _controlContainer?;
        /**
         * The default zoom control (only available if the `zoomControl` option was `true` when creating the map).
         */
        private _zoomControl;
        /**
         * @internal
         */
        _popup?: Popup;
        private _leafletContainer;
        private _paneRenderers;
        private _renderer;
        private _zoomInProgress;
        private _moveInProgress;
        private _lastZoomPixelOrigin;
        get leafletMap(): LeafletGlMap;
        /**
         * @internal
         */
        get fadeAnimated(): boolean;
        /**
         * @internal
         */
        get _animatingZoom(): boolean;
        /**
         * @internal
         */
        get draggingMoving(): boolean;
        /**
         * @internal
         */
        get interactiveTargets(): {
            [id: number]: Layer | LeafletGlMap;
        };
        /**
         * Ratio of WebGL viewport pixels to CSS pixels.
         */
        get webGLPixelRatio(): number;
        /**
         * Pixel ratio to be used for CanvasLayer. Computed as `min(webGLPixelRatio, options.maxCanvasRatio)`.
         */
        get canvasPixelRatio(): number;
        /**
         * Creates a new map.
         * @param element - HTML Element in which the map will be created.
         * @param options - Map options.
         */
        constructor(element: HTMLElement, options?: LeafletGlMapOptions);
        /**
         * Creates a new map.
         * @param id - The id of the HTML Element in which the map will be created.
         * @param options - Map options.
         */
        constructor(id: string, options?: LeafletGlMapOptions);
        /**
         * Creates a new map.
         * @param id - HTML Element in which the map will be created, or it's id.
         * @param options - Map options.
         */
        constructor(id: HTMLElement | string, options?: LeafletGlMapOptions);
        /**
         * Controls whether DOM-content is visibile (and updated) during zooming.
         */
        get displayDuringZoom(): boolean;
        set displayDuringZoom(enabled: boolean);
        private _initLayout;
        private _initEvents;
        private _initPanes;
        /**
         * Sets the view of the map (geographical center and zoom) with the given
         * animation options.
         */
        setView(center: LatLngExpression, zoom?: number, options?: ZoomOptions | PanOptions): this;
        /**
         * Sets the zoom of the map.
         */
        setZoom(zoom: number, options?: ZoomOptions): this;
        /**
         * Increases the zoom of the map by `delta` ({@link LeafletGlMapOptions.zoomDelta} by default).
         */
        zoomIn(delta?: number, options?: ZoomOptions): this;
        /**
         * Decreases the zoom of the map by `delta` ({@link LeafletGlMapOptions.zoomDelta} by default).
         */
        zoomOut(delta?: number, options?: ZoomOptions): this;
        /**
         * Zooms the map while keeping a specified geographical point on the map
         * stationary (e.g. used internally for scroll zoom and double-click zoom).
         */
        setZoomAround(latlng: LatLng, zoom: number, options: ZoomOptions): any;
        /**
         * Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
         */
        setZoomAround(latlng: Point, zoom: number, options: ZoomOptions): any;
        /**
         * Zooms the map while keeping a specified geographical point or pixel point on the map
         * stationary (e.g. used internally for scroll zoom and double-click zoom).
         */
        setZoomAround(latlng: LatLng | Point, zoom: number, options: ZoomOptions): any;
        /**
         * Sets a map view that contains the given geographical bounds with the
         * maximum zoom level possible.
         */
        fitBounds(bounds: LeafletBounds, options?: FitBoundsOptions$1): this;
        /**
         * Sets a map view that mostly contains the whole world with the maximum
         * zoom level possible.
         */
        fitWorld(options?: ZoomOptions): this;
        /**
         * Pans the map to a given center.
         */
        panTo(center: LatLngExpression, options?: PanOptions): this;
        /**
         * Pans the map by a given number of pixels (animated).
         */
        panBy(offset: PointExpression, options?: PanOptions): this;
        /**
         * Sets the view of the map (geographical center and zoom) performing a smooth
         * pan-zoom animation.
         */
        flyTo(targetCenter: LatLngExpression, targetZoom?: number, options?: PanOptions): this;
        /**
         * Sets the view of the map with a smooth animation like {@link flyTo},
         * but takes a bounds parameter like {@link fitBounds}.
         */
        flyToBounds(bounds: LatLngBounds, options?: FitBoundsOptionsLeaf): this;
        /**
         * Restricts the map view to the given bounds (see the {@link LeafletGlMapOptions.maxBounds} option).
         */
        setMaxBounds(bounds: LeafletBounds): this;
        /**
         * Sets the lower limit for the available zoom levels (see the {@link LeafletGlMapOptions.minZoom} option).
         */
        setMinZoom(zoom: number): this;
        /**
         * Sets the upper limit for the available zoom levels (see the {@link LeafletGlMapOptions.maxZoom} option).
         */
        setMaxZoom(zoom: number): this;
        /**
         * Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
         */
        panInsideBounds(bounds: LeafletBounds, options: PanOptions): this;
        /**
         * Stops the currently running {@link panTo} or {@link flyTo} animation, if any.
         */
        stop(): this;
        /**
         * Destroys the map and clears all related event listeners.
         */
        remove(): this;
        /**
         * Creates a new map pane with the given name if it doesn't exist already,
         * then returns it. The pane is created as a child of `container`, or
         * as a child of the main map pane if not set.
         */
        createPane(name: MapPaneName, container?: HTMLElement): HTMLElement;
        /**
         * Returns the geographical center of the map view
         */
        getCenter(): LatLng;
        /**
         * Returns the current zoom level of the map view
         */
        getZoom(): number;
        /**
         * Returns the geographical bounds visible in the current map view
         */
        getBounds(): LatLngBounds;
        /**
         * Returns the minimum zoom level of the map (if set in the {@link LeafletGlMapOptions.minZoom} option of the map or of any layers), or `0` by default.
         */
        getMinZoom(): number;
        /**
         * Returns the maximum zoom level of the map (if set in the {@link LeafletGlMapOptions.maxZoom} option of the map or of any layers).
         */
        getMaxZoom(): number;
        /**
         * Returns the maximum zoom level on which the given bounds fit to the map
         * view in its entirety. If `inside` (optional) is set to `true`, the method
         * instead returns the minimum zoom level on which the map view fits into
         * the given bounds in its entirety.
         */
        getBoundsZoom(bounds: LeafletBounds, inside?: boolean, padding?: Point): number;
        /**
         * Returns the current size of the map container (in pixels).
         */
        getSize(): Point;
        /**
         * Returns the bounds of the current map view in projected pixel
         * coordinates (sometimes useful in layer and overlay implementations).
         * Uses either the supplied center & zoom or the map's current center & zoom otherwise.
         */
        getPixelBounds(center?: LatLngExpression, zoom?: number): Bounds;
        /**
         * Returns the bounds of the current map view in mercator coordinates.
         */
        getMercatorBounds(): Bounds;
        /**
         * Returns the projected pixel coordinates of the top left point of
         * the map layer (useful in custom layer and overlay implementations).
         */
        getPixelOrigin(): Point;
        /**
         * Returns the world's bounds in pixel coordinates for zoom level `zoom`.
         * If `zoom` is omitted, the map's current zoom level is used.
         */
        getPixelWorldBounds(zoom?: number): Bounds;
        /**
         * @internal
         */
        getControlCorner(controlCorner: ControlPosition$1): HTMLDivElement | undefined;
        /**
         * Returns a map pane, given its name (its identity).
         */
        getPane(pane: MapPaneName): HTMLElement | undefined;
        /**
         * Returns `true` if the pane with the given name exists.
         */
        hasPane(name: MapPaneName): boolean;
        /**
         * Returns a plain object containing the names of all map pane names as keys and
         * the panes as values.
         */
        getPanes(): {
            [key: MapPaneName]: HTMLElement;
        };
        /**
         * Returns the HTML element that contains the map.
         */
        getContainer(): HTMLElement;
        /**
         * Returns the scale factor to be applied to a map transition from zoom level
         * `fromZoom` to `toZoom`. Used internally to help with zoom animations.
         */
        getZoomScale(toZoom: number, fromZoom?: number): number;
        /**
         * Returns the zoom level that the map would end up at, if it is at `fromZoom`
         * level and everything is scaled by a factor of `scale`. Inverse of
         * {@link getZoomScale}.
         */
        getScaleZoom(scale: number, fromZoom?: number): number;
        /**
         * Projects a geographical coordinate `LatLng` according to the projection
         * of the map's CRS, then scales it according to `zoom` and the CRS's
         * `Transformation`. The result is pixel coordinate relative to
         * the CRS origin.
         */
        project(latlng: LatLngExpression, zoom?: number): Point;
        /**
         * Inverse of {@link project}.
         */
        unproject(point: PointExpression, zoom?: number): LatLng;
        /**
         * Given a pixel coordinate relative to the origin pixel (see {@link getPixelOrigin}),
         * returns the corresponding geographical coordinate (for the current zoom level).
         */
        layerPointToLatLng(point: PointExpression): LatLng;
        /**
         * Given a geographical coordinate, returns the corresponding pixel coordinate
         * relative to the origin pixel (see {@link getPixelOrigin}).
         */
        latLngToLayerPoint(latlng: LatLngExpression): Point;
        /**
         * Returns a `LatLngBounds` with the same size as the given one, ensuring that
         * its center is within the CRS's bounds.
         * By default this means the center longitude is wrapped around the dateline so its
         * value is between -180 and +180 degrees, and the majority of the bounds
         * overlaps the CRS's bounds.
         */
        wrapLatLngBounds(bounds: LeafletBounds): LatLngBounds;
        wrapLatLng(latlng: LatLngExpression): LatLng;
        /**
         * Returns the distance between two geographical coordinates according to
         * the map's CRS. By default this measures distance in meters.
         */
        distance(latlng1: LatLngExpression, latlng2: LatLngExpression): number;
        /**
         * Given a pixel coordinate relative to the map container, returns the corresponding
         * pixel coordinate relative to the origin pixel (see {@link getPixelOrigin}).
         */
        containerPointToLayerPoint(point: PointExpression): Point;
        /**
         * Given a pixel coordinate relative to the origin pixel (see {@link getPixelOrigin}),
         * returns the corresponding pixel coordinate relative to the map container.
         */
        layerPointToContainerPoint(point: PointExpression): Point;
        /**
         * Given a pixel coordinate relative to the map container, returns
         * the corresponding geographical coordinate (for the current zoom level).
         */
        containerPointToLatLng(point: PointExpression): LatLng;
        /**
         * Given a geographical coordinate, returns the corresponding pixel coordinate
         * relative to the map container.
         */
        latLngToContainerPoint(latlng: LatLngExpression): Point;
        /**
         * Given a MouseEvent object, returns the pixel coordinate relative to the
         * map container where the event took place.
         */
        mouseEventToContainerPoint(e: {
            clientX: number;
            clientY: number;
        }): Point;
        /**
         * Given a MouseEvent object, returns the pixel coordinate relative to
         * the origin pixel (see {@link getPixelOrigin}) where the event took place.
         */
        mouseEventToLayerPoint(e: {
            clientX: number;
            clientY: number;
        }): Point;
        /**
         * Given a MouseEvent object, returns geographical coordinate where the
         * event took place.
         */
        mouseEventToLatLng(e: {
            clientX: number;
            clientY: number;
        }): LatLng;
        /**
         * Adds the given layer to the map
         */
        addLayer(layer: Layer): this;
        /**
         * Removes the given layer from the map.
         */
        removeLayer(layer: Layer): this;
        /**
         * Returns `true` if the given layer is currently added to the map
         */
        hasLayer(layer: Layer): boolean;
        /**
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer(method: any, context: any): this;
        private _updatePaneTranslation;
        private _updatePixelOrigin;
        private _handleZoomOrigin;
        private _addLayers;
        /**
         * @internal
         * Returns the top left pixel's offset using either the supplied center & zoom
         * or the map's current center & zoom.
         */
        _getTopLeftPoint(center?: LatLng, zoom?: number): Point;
        /**
         * @internal
         */
        _getNewPixelOrigin(center: LatLng, zoom?: number): Point;
        /**
         * @internal
         */
        _latLngToNewLayerPoint(latlng: LatLngExpression, zoom: number, center: LatLng): Point;
        private _latLngBoundsToNewLayerBounds;
        /**
         * Returns the layer point of the current center.
         */
        private _getCenterLayerPoint;
        /**
         * Returns the offset of the specified place to the current center in pixels.
         */
        private _getCenterOffset;
        /**
         * Runs the given function `fn` when the map gets initialized with
         * a view (center and zoom) and at least one layer, or immediately
         * if it's already initialized, optionally passing a function context.
         */
        whenReady(callback: Function, context?: any): this;
        /**
         * Resolves once the map is ready (style is loaded).
         */
        waitReady(): Promise<void>;
        /**
         * Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
         */
        openPopup(popup: Popup): this;
        /**
         * Creates a popup with the specified content and options and opens it in the given point on a map.
         */
        openPopup(content: OverlayContentBase, latlng: LatLng, options?: PopupOptions): this;
        /**
         * Closes the popup passed in argument, or, if empty, closes the popup previously opened with {@link openPopup}.
         */
        closePopup(popup?: Popup): this;
        /**
         * Opens the specified tooltip.
         */
        openTooltip(tooltip: Tooltip): this;
        /**
         * Creates a tooltip with the specified content and options and open it.
         */
        openTooltip(content: OverlayContentBase, latlng: LatLng, options?: TooltipOptions): this;
        /**
         * Closes the tooltip given as parameter.
         */
        closeTooltip(tooltip: Tooltip): this;
        private _initOverlay;
        _draggableMoved(obj: Layer | LeafletGlMap): boolean;
        private _findEventTargets;
        private _isClickDisabled;
        private _handleDOMEvent;
        private _mouseEvents;
        /**
         * @internal
         */
        _fireDOMEvent(e: MouseEvent | KeyboardEvent, type: DomFirableEventTypes, canvasTargets?: Path[]): void;
        /**
         * @internal
         */
        _getMapPanePos(): Point;
        private _mapLibreEaseTo;
        /**
         * Returns the instance of `Renderer` that should be used to render the given
         * `Path`. It will ensure that the `renderer` options of the map and paths
         * are respected, and that the renderers do exist on the map.
         */
        getRenderer(layer: Path): RendererBase;
        private _getPaneRenderer;
        private _createRenderer;
        /**
         * Returns the range visible of tiles for the given zoom level.
         * The range is always valid, even near the antimeredian or when the world is repeated multiple times.
         */
        getTileBounds(zoom?: number): Bounds;
        /**
         *
         * Control
         *
         */
        /**
         * Adds the given control to the map.
         */
        addControl(control: Control): this;
        /**
         * Removes the given control from the map.
         */
        removeControl(control: Control): this;
        private _initControlPos;
        private _clearControlPos;
    }
    type CustomTileShaderSpec$1 = {
        pixelTransform: string;
    };
    type TileLayerOptions = LayerOptions & {
        /**
         * Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
         * @default 256
         */
        tileSize?: number;
        /**
         * The minimum zoom level down to which this layer will be displayed (inclusive).
         * Modifying this property on a layer that was already added to a map will have no effect.
         * @default 0
         */
        minZoom?: number;
        /**
         * The maximum zoom level up to which this layer will be displayed (inclusive).
         * Modifying this property on a layer that was already added to a map will have no effect.
         * @default 18
         */
        maxZoom?: number;
        /**
         * Opacity of the tiles.
         * @default 1.0
         */
        opacity?: number;
        /**
         * Maximum zoom number the tile source has available. If it is specified,
         * the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
         * from `maxNativeZoom` level and auto-scaled.
         * @default undefined
         */
        maxNativeZoom?: number | null;
        /**
         * Minimum zoom number the tile source has available. If it is specified,
         * the tiles on all zoom levels lower than `minNativeZoom` will be loaded
         * from `minNativeZoom` level and auto-scaled.
         * @default undefined
         */
        minNativeZoom?: number | null;
        /**
         * Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
         */
        subdomains?: string | string[];
        /**
         * When true, device pixel ratio is detected automatically and higher resolution tiles are
         * fetched if needed. Note that the source tile URL must also contain `{r}` that is replaced with `@2x`
         * if higher resolution tiles are needed, otherwise original tiles are fetched.
         */
        detectRetina?: boolean;
        /**
         * Optional custom tile shader specification
         */
        customShader?: CustomTileShaderSpec$1 | null;
        /**
         * Optional layer id - if we want to explicitely set the id of the layer instead of being generated
         */
        layerId?: string | null;
        preRenderTileCallback?: PreRenderRasterTileCallback | null;
        postRenderTileCallback?: PostRenderRasterTileCallback | null;
        /**
         * Optional texture filter mode which overrides default GL.LINEAR
         */
        tileFilter?: TextureFilter | null;
        /**
         * How many extra tiles "beyond the screen edge" to load. Also accepts fractional values.
         * Useful when eg. processing tiles with a shader that samples its neighbourhood.
         * @default 0
         */
        keepBuffer?: number;
        paint?: RasterStyleLayer["paint"] | null;
        /**
         * Bucket ID for fine-grained control of layer ordering. See {@link LayerOrderingRepository}.
         */
        layerBucketId?: number | null;
    };
    /**
     * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under {@link LayerOptions}.
     * Equivalent to MapLibre's `RasterLayer`.
     *
     * @group Layers
     *
     * @example
     *
     * ```js
     * new TileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'}).addTo(map);
     * ```
     */
    class TileLayer extends Layer {
        static defaultOptions: Required<TileLayerOptions>;
        options: Required<TileLayerOptions>;
        /**
         * @internal
         */
        readonly _type: "TileLayer";
        private _url;
        private _containingMap;
        private _alwaysLoadTiles;
        private _visible;
        constructor(url: string, options?: TileLayerOptions);
        /**
         * When true, this layer's source will load tiles that cover the map even when the layer is set to not be visible.
         */
        set alwaysLoadTiles(val: boolean);
        get alwaysLoadTiles(): boolean;
        /**
         * Returns the source associated with this tile layer.
         */
        source(): RasterTileSource | undefined;
        /**
         * Returns the source cache associated with this tile layer.
         */
        sourceCache(): SourceCache | undefined;
        /**
         * Returns the MapLibre layer associated with this tile layer.
         */
        layer(): RasterStyleLayer | undefined;
        private _trySetAlwaysLoaded;
        private _trySetVisibility;
        set visible(val: boolean);
        get visible(): boolean;
        get id(): string | undefined;
        /**
         * @internal
         */
        onAdd(map: LeafletGlMap): this;
        /**
         * @internal
         */
        onRemove(_map: LeafletGlMap): this;
        /**
         * Changes the opacity of the tile layer.
         */
        setOpacity(opacity: number): this;
        /**
         * Returns `true` if any tile in the grid layer has not finished loading.
         */
        isLoading(): boolean;
        /**
         * Causes the layer to clear all the tiles and request them again.
         */
        redraw(): this;
        /**
         * @internal
         */
        getEvents(): LeafletGlEventHandlerFnMap;
        /**
         * Normalizes the {@link TileLayerOptions.tileSize} into a point.
         */
        getTileSize(): Point;
        /**
         * Updates the layer's URL template and redraws it.
         */
        setUrl(url: string): this;
        private _getLayerId;
        private _getSourceId;
        private _addMapLibreObjects;
        private _removeMapLibreObjects;
        private _recreateMaplibreObjects;
    }
    /**
     * @deprecated
     * Instantiates a tile layer object given a `URL template` and optionally an options object.
     *
     * @group Factory Functions
     */
    function tileLayer(url: string, options?: TileLayerOptions): TileLayer;
    type CoordsWithKey = Coords & {
        key: string;
    };
    /**
     * When given tile coordinates, returns a new instance of {@link Coords}
     * with the X component wrapped to the range appropriate for the zoom level of the coords: 0..(2^z)-1.
     *
     * @group Tile Management
     */
    function wrappedCoords(tilePoint: Coords): Coords;
    /**
     * Returns a string representation of the input {@link Coords} that can be used as a key in a dictionary.
     *
     * @group Tile Management
     */
    function getCoordsKey(coords: Coords): string;
    /**
     * A quad tree intended for tile management.
     * An node can be set, updated or deleted using {@link set}.
     * All nodes that should be rendered for a given map view can be retrieved using {@link gatherOrderedRenderable}.
     *
     * @group Tile Management
     */
    class TileQuadTree<T> {
        private _root;
        /**
         * Set the payload for a given quadtree entry.
         * When payload is null, the entry is deleted (if it exists).
         * When payload is not null, the entry's payload is set, or the entry is created if it does not exist yet.
         */
        set(targetX: number, targetY: number, targetZ: number, payload: T | null): void;
        /**
         * Deletes the quadtree entry at the given coordiantes.
         */
        delete(targetX: number, targetY: number, targetZ: number): void;
        /**
         * Returns all tiles that should be rendered to cover the given bounds at the given zoom level.
         * Returned tiles are ordered from lowest zoom levels to highest.
         * Uses tiles of the exact specified zoom level if required, otherwise uses other zoom levels, preferring higher zooms that desired.
         */
        gatherOrderedRenderable(tileBounds: Bounds, tileZoom: number, maxLowerZoomAllowed: number, // how many lower zoom levels are we allowed to use
        maxHigherZoomAllowed: number): Coords[];
        /**
         * Expands the `renderable` set to contain tiles that cover as much area of the given entry as possible,
         * while using as low zoom levels as possible.
         * Returns true if the given entry is entirely covered by renderable tiles (itself or children).
         */
        private _gatherUsableChildren;
    }
    type LoadTileFunc<T> = (tile: Coords, abort: AbortSignal) => Promise<T | null>;
    type BeforeTileDeletedFunc<T> = (tile: Coords, data: T | null) => void;
    type AwaitedTile<TTile> = {
        status: "success";
        tile: TTile;
    } | {
        status: "failed";
    } | {
        status: "disposed";
    } | {
        status: "aborted";
    };
    /**
     * A class for automatically managing tiles. Uses a {@link TileQuadTree} internally.
     * The generic argument is the tile data type.
     *
     * Update it with the current map view using {@link update}.
     * This will automatically trigger loading of all tiles needed for this map view, and deletes or cancels any that are no longer needed.
     * Or {@link manualUpdate} to supply list of tiles to load and delete directly.
     *
     * Retrieve data for a given tile using {@link getData}.
     * Get all renderable {@link Coords} for a given map view using {@link getOrderedTilePyramid}.
     * Delete all loaded tiles using {@link dispose}. This will call `beforeTileDeleted` for each deleted tile.
     *
     * @group Tile Management
     */
    class TileCache<T> extends LeafletEvented {
        private _pendingTiles;
        private _cachedTiles;
        private _quadtree;
        private _tileRequests;
        private _deleteQueue;
        private _deleteLoop;
        private _lastBounds;
        private _lastZoom;
        private _loadTile;
        private _beforeTileDeleted;
        deleteWaitTimeSeconds: number;
        /**
         * How many tiles are currently being loaded.
         */
        get pendingTilesCount(): number;
        /**
         * How many tiles are currently cached.
         * A tile is cached if it is required by the last {@link update} or {@link manualUpdate} call
         * and it has done loading (either successfully or not).
         */
        get cachedTilesCount(): number;
        /**
         * Returns how many tiles are required by the last {@link update} or {@link manualUpdate} call.
         * This is computed as {@link pendingTilesCount} + {@link cachedTilesCount}.
         */
        get requestedTilesCount(): number;
        /**
         * Creates a new TileCache instance.
         *
         * Set {@link loadTile} to your function for loading a tile.
         * Set {@link beforeTileDeleted} to your function for deleting a tile.
         * @param loadTile - Executed to load a tile. May return `null` if the tile cannot be loaded (eg. returns 404).
         * The result (be it successful or null) will be cached for as long as the tile remains in the ideally-loaded set.
         *
         * If the abort controller is signalled, the function *must* throw an object
         * with a string field `message` that contains the word "aborted".
         *
         * If the tile set has limited bounds or min/max zoom, then such constraints
         * should by handled by this function by returning `null` for tiles outside the acceptable limits.
         * @param beforeTileDeleted - Executed when a tile is about to be deleted from the tile cache.
         * Can be called both from {@link update} or {@link manualUpdate} and from {@link dispose}.
         *
         * Note: the {@link data} parameter given to the function may be null, if the {@link loadTile} function returned null for this tile.
         */
        constructor(loadTile: LoadTileFunc<T>, beforeTileDeleted?: BeforeTileDeletedFunc<T>);
        /**
         * Returns the data (or `null`) for the given coords.
         * Also accepts coordinates that are outside the main world (x \< 0 or x \> 2^z),
         * for which tiles in the main world are returned.
         * Note that `null` is returned both when the tile is not present and when the load failed (but the tile would otherwise be present).
         * Distinguish between these states using {@link hasTile}.
         */
        getData(coords: Coords): T | null;
        /**
         * Returns whether the given tile coordinates are present in the tile cache,
         * regardless of whether the load for this tile was successful (tile has data) or not (tile is `null`).
         * Also accepts coordinates that are outside the main world (x \< 0 or x \> 2^z),
         * for which tiles in the main world are returned.
         */
        hasTile(coords: Coords): boolean;
        /**
         * Returns a list of tiles that are loaded and cover the given bounds+zoom as best as possible.
         * The list is ordered from lowest zoom to highest, then from lowest to highest Y, then from lowest to highest X.
         * @param tileBounds - The tile bounds that should be covered. Can be outside the main world copy, eg. [x:-2, y:0 .. x:3, y:5].
         * @param tileZoom - The tile zoom that should be covered.
         * @param maxLowerZoomAllowed - If a tile at the specified zoom level is unavailable, its parent or children may be rendered instead.
         * This value is the maximal allowed difference in zoom levels when rendering a **less** detailed tile instead of the ideal one.
         * @param maxHigherZoomAllowed - If a tile at the specified zoom level is unavailable, its parent or children may be rendered instead.
         * This value is the maximal allowed difference in zoom levels when rendering a **more** detailed tile instead of the ideal one.
         */
        getOrderedTilePyramid(tileBounds: Bounds, tileZoom: number, maxLowerZoomAllowed: number, maxHigherZoomAllowed: number): Coords[];
        /**
         * Manages tiles so that the currently visible map region is loaded.
         * Loads any tiles that are visible but not loaded or pending,
         * deletes or cancels loading of any tiles that are not visible.
         * @param tileBounds - The tile extents of the visible map region, in tile indices. Depends on the zoom level. At zoom 2, valid extents are at most 0..3, at zoom 4, they are 0..15, etc.
         * @param tileZoom - The zoom level for the previous parameter.
         * @param forced - If true, the tile cache is updated even if the given bounds and zoom are identical to the last {@link update} call. Used e.g. by grid-layer to re-add content on zoom-end
         */
        update(tileBounds: Bounds, tileZoom: number, forced?: boolean): void;
        /**
         * Fires loading of tiles specified to be loaded (if not loading already), deletes or cancels tiles specified to be deleted.
         * A variant of the {@link update} call, but the caller is in complete control of what tiles are loaded and deleted.
         * Useful when the tile cache is in fact dependent on another tile cache somewhere else.
         * @param toLoad - The array of tiles that should be loaded. Loading is not fired for tiles that are being loaded already or that are already cached.
         * @param toDelete - The array of tiles that should be deleted. Must not contain any tile that is in the {@link toLoad} array. Cached tiles are deleted, tiles that are still loading are cancelled.
         */
        manualUpdate(toLoad: CoordsWithKey[], toDelete: CoordsWithKey[]): void;
        /**
         * Note: the tile cache is no longer usable after calling this method.
         *
         * Deletes all tiles from this tile cache.
         * {@link _beforeTileDeleted} is called for each deleted tile.
         * All pending tile loads and awaitTile promises are aborted,
         * internal tile delete timeout loop is cleared.
         */
        dispose(): void;
        /**
         * Asynchronously returns a tile once it is loaded.
         * However the loading of this tile can only be triggered by the user moving the map
         * and the tile becoming visible in the map view.
         * Always returns tiles from the latest cache available at the time of calling this function:
         * returns tiles from the next cache, if any is present, otherwise returns tiles from the current cache.
         *
         * You can optionally supply an abort signal. Signalling it will cancel the tile request
         * and remove it from the internal queues.
         */
        awaitTile(coords: Coords, abort?: AbortSignal): Promise<AwaitedTile<T>>;
        private _checkTilesForDeletion;
        private _deleteTile;
        private _shouldDeleteTile;
        private _triggerTileLoad;
    }
    type LevelTransform = {
        translate: Point;
        scale: number;
    };
    type GridTile = {
        element: HTMLElement;
        coordinates: Coords;
    };
    type GridLayerOptions = LayerOptions & {
        /**
         * Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
         */
        tileSize: number | Point;
        /**
         * The minimum zoom level down to which this layer will be displayed (inclusive).
         */
        minZoom?: number;
        /**
         * The maximum zoom level up to which this layer will be displayed (inclusive).
         */
        maxZoom?: number;
        /**
         * `Map pane` where the grid layer will be added.
         */
        pane?: string;
        /**
         * A custom class name to assign to the tile layer. Empty by default.
         */
        className?: string;
        /**
         * When panning the map, keep this many rows and columns of tiles before unloading them.
         */
        keepBuffer?: number;
    };
    /**
     * A layer for creating a grid of `div` tiles that can contain generic DOM content.
     *
     * @group Layers
     */
    class GridLayer<T> extends Layer {
        static defaultOptions: Required<GridLayerOptions>;
        options: Required<GridLayerOptions>;
        set showBorders(show: boolean);
        get showBorders(): boolean;
        private _showBorders;
        protected _container?: HTMLDivElement;
        private _level?;
        private _zooming;
        protected _tileCache: TileCache<T>;
        protected _gridTiles: Map<string, GridTile>;
        constructor(options?: GridLayerOptions);
        get container(): HTMLElement | undefined;
        get levelTransform(): LevelTransform | undefined;
        /**
         * Loads the data for a given tile.
         *
         * Derived classes **should** implement this function.
         * @param _coords - Coordinates of the requested tile. These will always be in the primary world copy.
         * @param _abort - Abort controller for aborting the data request. Used by the tile cache for example when the user pans the map away before the tile is done loading.
         * @returns The fetched tile data, or null if the loading of tile data fails in any way.
         */
        protected _loadTileData(_coords: Coords, _abort: AbortSignal): Promise<T | null>;
        /**
         * Creates the HTML contents of a given tile
         *
         * Derived classes **should** implement this function.
         * @param tileRoot - The root element of the tile. This is where the contents should be added.
         * @param coords - The coordinates of the tile. These may be outside the main world copy, for example the X may be negative if the user is near -180W.
         * @param data - The previously fetched data for this tile.
         */
        protected _createTileContents(tileRoot: HTMLElement, coords: Coords, _data: T): void;
        /**
         * Called when a grid tile DOM is created.
         */
        protected _onTileLoaded(tileCoords: Coords, tile?: HTMLElement | null): void;
        /**
         * Causes the layer to clear all the tiles and request them again.
         */
        reload(): this;
        onAdd(map: LeafletGlMap): this;
        onRemove(_map: LeafletGlMap): this;
        getTileSize(): Point;
        protected getTilePos(coords: Point | Coords): Point;
        private _createGridTile;
        private _update;
        /**
         * Removes all tiles from the layer.
         */
        protected _removeAllTiles(): void;
        private _init;
        private _destroy;
        private _onZoom;
        private _onZoomStart;
        private _onZoomEnd;
        private _onMapMove;
        private _hideShowLayer;
        private _initContainer;
        private _updateLevels;
        private _renderDebugTileBorder;
    }
    function gridLayer<T>(options?: GridLayerOptions): GridLayer<T>;
    /**
     * Extended {@link LayerGroup} that makes it easier to do the same thing to all its member layers:
     *  * {@link bindPopup} binds a popup to all of the layers at once (likewise with {@link bindTooltip})
     *  * Events are propagated to the {@link FeatureGroup}, so if the group has an event
     * handler, it will handle events from any of the layers. This includes mouse events
     * and custom events.
     *  * Has `layeradd` and `layerremove` events
     *
     * @group Internal Layers
     */
    class FeatureGroup extends LayerGroup {
        addLayer(layer: Layer): this;
        removeLayer(layer: Layer): this;
        /**
         * Sets the given path options to each layer of the group that has a `setStyle` method.
         */
        setStyle(style: PopupOptions | StyleFunction): this;
        /**
         * Brings the layer group to the top of all other layers.
         */
        bringToFront(): this;
        /**
         * Brings the layer group to the back of all other layers.
         */
        bringToBack(): this;
        /**
         * Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
         */
        getBounds(): LatLngBounds;
        /**
         * Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
         */
        openPopup(latlng?: LatLngExpression): this;
    }
    /**
     * @deprecated
     * Create a feature group, optionally given an initial set of layers and an `options` object.
     *
     * @group Factory Functions
     */
    function featureGroup(layers?: Layer[], options?: LayerOptions): FeatureGroup;
    type BaseGeoJsonObject = geojson.Geometry | geojson.Feature | geojson.FeatureCollection;
    type GeoJsonObject = BaseGeoJsonObject | BaseGeoJsonObject[];
    type GeoJsonLeaf = geojson.Geometry | geojson.Feature;
    type GeoJSONOptions<P = any> = InteractiveLayerOptions & {
        /**
         * A Function defining how GeoJSON points spawn Leaflet layers.
         * It is internally called when data is added, passing the GeoJSON point
         * feature and its LatLng.
         *
         * The default is to spawn a default Marker:
         *
         * ```
         * function(geoJsonPoint, latlng) {
         *     return L.marker(latlng);
         * }
         * ```
         */
        pointToLayer?(geoJsonPoint: geojson.Feature<geojson.Point, P>, latlng: LatLng): Layer;
        /**
         * PathOptions or a Function defining the Path options for styling GeoJSON lines and polygons,
         * called internally when data is added.
         *
         * The default value is to not override any defaults:
         *
         * ```
         * function (geoJsonFeature) {
         *     return {}
         * }
         * ```
         */
        style?: PathOptions | StyleFunction | undefined;
        /**
         * A Function that will be called once for each created Feature, after it
         * has been created and styled. Useful for attaching events and popups to features.
         *
         * The default is to do nothing with the newly created layers:
         *
         * ```
         * function (feature, layer) {}
         * ```
         */
        onEachFeature?(feature: GeoJsonLeaf, layer: Layer): void;
        /**
         * A Function that will be used to decide whether to show a feature or not.
         *
         * The default is to show all features:
         *
         * ```
         * function (geoJsonFeature) {
         *     return true;
         * }
         * ```
         */
        filter?(geoJsonFeature: GeoJsonLeaf): boolean;
        /**
         * A Function that will be used for converting GeoJSON coordinates to LatLngs.
         * The default is the coordsToLatLng static method.
         */
        coordsToLatLng?(coords: [
            number,
            number
        ] | [
            number,
            number,
            number
        ]): LatLng;
        /** Whether default Markers for "Point" type Features inherit from group options. */
        markersInheritOptions?: boolean | undefined;
    };
    /**
     * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
     * GeoJSON data and display it on the map. Extends {@link FeatureGroup}.
     *
     * @group Layers
     *
     * @example
     *
     * ```js
     * geoJSON(data, {
     *     style: function (feature) {
     *         return {color: feature.properties.color};
     *     }
     * }).bindPopup(function (layer) {
     *     return layer.feature.properties.description;
     * }).addTo(map);
     * ```
     */
    class GeoJSON<P = any> extends FeatureGroup {
        options: Required<GeoJSONOptions<P>>;
        /**
         * @internal
         */
        _layers: {
            [id: number]: Layer;
        };
        constructor(geojson?: GeoJsonObject, options?: GeoJSONOptions<P>);
        /**
         * Adds a GeoJSON object to the layer.
         */
        addData(geojson: GeoJsonObject): this;
        /**
         * Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
         * If `layer` is omitted, the style of all features in the current layer is reset.
         */
        resetStyle(layer?: Layer): this;
        /**
         * Changes styles of GeoJSON vector layers with the given style function.
         */
        setStyle(style: StyleFunction | PathOptions): this;
        private _setLayerStyle;
        private _addFeatureOrGeometry;
    }
    /**
     * @deprecated
     *
     * Creates a GeoJSON layer. Optionally accepts an object in
     * [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
     * (you can alternatively add it later with `addData` method) and an `options` object.
     *
     * @group Factory Functions
     */
    function geoJSON<P = any>(geojson: GeoJsonObject, options?: GeoJSONOptions<P>): GeoJSON<P>;
    class Circle extends CircleMarker {
        /**
         * Radius of the circle, in meters.
         */
        protected _mRadius: number;
        protected _radiusY: number;
        /**
         * @internal
         */
        get _radiusPixels(): number;
        constructor(latlng: LatLngExpression, options?: CircleMarkerOptions);
        constructor(latlng: LatLngExpression, radius?: number, options?: CircleMarkerOptions);
        constructor(latlng: LatLngExpression, options?: CircleMarkerOptions | number, legacyOptions?: CircleMarkerOptions);
        /**
         * Sets the radius of a circle. Units are in meters.
         */
        setRadius(radius: number): this;
        /**
         * Returns the current radius of a circle. Units are in meters.
         */
        getRadius(): number;
        /**
         * Returns the `LatLngBounds` of the path.
         */
        getBounds(): LatLngBounds;
        /**
         * @internal
         */
        _project(): void;
    }
    /**
     * @deprecated
     * Instantiates a circle object given a geographical point, and an options object
     * which contains the circle radius.
     *
     * @group Factory Functions
     */
    function circle(latlng: LatLngExpression, options?: CircleMarkerOptions): Circle;
    /**
     * @deprecated
     * Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
     * Do not use in new applications or plugins.
     *
     * @group Factory Functions
     */
    function circle(latlng: LatLngExpression, radius?: number, options?: CircleMarkerOptions): Circle;
    type RotatedImageOverlayOptions = ImageOverlayOptions & {
        /**
         * Clockwise rotation angle in degrees.
         * @default 0
         */
        angle?: number;
    };
    /**
     * A rotated variant of {@link ImageOverlay}.
     *
     * @group Layers
     */
    class RotatedImageOverlay extends ImageOverlay {
        static defaultOptions: Required<RotatedImageOverlayOptions>;
        options: Required<RotatedImageOverlayOptions>;
        constructor(url: string, bounds: LatLngBoundsExpression, options?: RotatedImageOverlayOptions);
        protected _reset(): void;
        protected _rotate(): void;
    }
    class Polygon extends Polyline {
        static defaultOptions: Required<PolylineOptions>;
        options: Required<PolylineOptions>;
        /**
         * @internal
         */
        _latlngs: LatLng[][] | LatLng[][][];
        constructor(latlngs: LatLngExpressionMultiPolygonShape, options?: PolylineOptions);
        isEmpty(): boolean;
        /**
         * Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
         */
        getCenter(): LatLng;
        protected _convertLatLngs(latlngs: LatLngExpressionShape): LatLngShape;
        protected _setLatLngs(latlngs: LatLngExpressionShape): void;
        protected _defaultShape(): LatLng[];
        protected _clipPoints(): void;
        protected _updatePath(): void;
        /**
         * @internal
         * Needed by the `Canvas` renderer for interactivity
         */
        _containsPoint(p: Point): boolean;
        /**
         * Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precisionDigits`.
         * Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
         */
        toGeoJSON(precisionDigits?: number): geojson.Feature;
    }
    /**
     * @deprecated
     * Creates a new Polygon instance.
     *
     * @group Factory Functions
     */
    function polygon(latlngs: LatLngExpressionMultiPolygonShape, options?: PolylineOptions): Polygon;
    type ParsedOptions = {
        opacity?: number;
        href?: string;
        color?: string;
        rotation?: number;
        weight?: number;
        x?: number;
        y?: number;
        xunits?: "pixels" | "fraction";
        yunits?: "pixels" | "fraction";
        id?: string;
    } & {
        [key: string]: unknown;
    };
    type ParsedStyle = ParsedOptions & {
        fillColor?: string;
        fillOpacity?: number;
        fill?: boolean;
        icon?: KMLIcon;
    } & {
        [key: string]: ParsedOptions;
    };
    /**
     * A layer for displaying KML files.
     *
     * @group Layers
     */
    class KML extends FeatureGroup {
        protected _kml: XMLDocument;
        _layers: Record<string, never>;
        latLngs: LatLng[];
        constructor(kml: XMLDocument, options?: LayerOptions);
        protected _addKML(xml: XMLDocument): void;
        protected _parseKML(xml: XMLDocument): Layer[];
        /**
         * Return false if e's first parent Folder is not [folder] - returns true if no parent Folders.
         */
        protected _checkFolder(e: Element, folder?: Element): boolean;
        protected _parseStyles(xml: XMLDocument): ParsedStyle;
        protected _parseStyle(xml: Element): ParsedStyle;
        protected _parseStyleMap(xml: XMLDocument, existingStyles: ParsedStyle): void;
        protected _parseFolder(xml: Element, style: ParsedStyle): Layer | void;
        protected _parsePlacemark(place: Element, xml: Element | XMLDocument, style: ParsedStyle, options?: ParsedStyle): Layer | void;
        protected _parseCoords(xml: XMLDocument | Element): LatLng[];
        protected _parseLineString(line: XMLDocument | Element, _xml: XMLDocument | Element, options: ParsedStyle): Polyline | void;
        protected _parseTrack(_unused: never, xml: XMLDocument | Element, options: ParsedStyle): Polyline | void;
        protected _parsePoint(line: Element, _xml: XMLDocument | Element, options: ParsedStyle): KMLMarker | void;
        protected _parsePolygon(line: Element, _xml: XMLDocument | Element, options: ParsedStyle): Polygon | void;
        protected _getLatLngs(xml: XMLDocument): LatLng[];
        protected _readCoords(el: Element): LatLng[];
        protected _readGxCoords(el: Element): LatLng[];
        protected _parseGroundOverlay(xml: Element): RotatedImageOverlay;
    }
    type KMLAnchorUnits = "pixels" | "fraction";
    type KMLIconOptions = IconOptions & {
        anchorType?: {
            x?: KMLAnchorUnits;
            y?: KMLAnchorUnits;
        };
        anchorRef?: {
            x?: number;
            y?: number;
        };
    };
    class KMLIcon extends Icon {
        static defaultOptions: Required<KMLIconOptions>;
        options: Required<KMLIconOptions>;
        constructor(options?: KMLIconOptions);
        protected _setIconStyles(img: HTMLImageElement, name: IconImgName): void;
        applyCustomStyles(img: HTMLImageElement): void;
        /**
         * Roughly equivalent to marker icon's Icon.Default class.
         */
        static Default: typeof KMLIcon;
    }
    type KMLMarkerOptions = MarkerOptions & {
        icon?: KMLIcon;
    };
    class KMLMarker extends Marker {
        options: Required<KMLMarkerOptions>;
        constructor(latlng: LatLngExpression, options?: KMLMarkerOptions);
    }
    /**
     * @deprecated
     * Creates a new instance of a KML layer.
     *
     * @group Factory Functions
     */
    function kml(kml: XMLDocument, options?: LayerOptions): KML;
    type SpeedSplitOptions = {
        /**
         * Adjusts the color gradient of lines based on speed.
         * @default 110
         */
        maxSpeed?: number;
        /**
         * How many differently colored chunks to use at most when coloring a line based on speed.
         * @default 200
         */
        chunks?: number;
    };
    type GPXOptions = SpeedSplitOptions & MarkerOptions & PolylineOptions & LayerOptions & {
        /**
         * When true, `<wpt>` tags are displayed as markers, otherwise they are ignored.
         * @default undefined
         */
        display_wpt?: boolean;
        /**
         * Unused?
         */
        async?: boolean;
    };
    /**
     * A layer for displaying GPX files.
     *
     * @group Layers
     */
    class GPX extends FeatureGroup {
        static defaultOptions: {
            maxSpeed: number;
            chunks: number;
            pane: string | null;
            attribution: string | null;
        };
        options: GPXOptions & Required<SpeedSplitOptions> & Required<LayerOptions>;
        private _gpx;
        constructor(gpx: XMLDocument | string, options?: GPXOptions);
        addGPX(gpx: XMLDocument, options?: GPXOptions): this;
        addGPX(url: string, options?: GPXOptions, async?: boolean): this;
        parse(): this;
        private _humanReadableLength;
        private loadXML;
        /**
         * @internal
         */
        _polylineLen(polyLines: Polyline): number;
        parseGPX(xml: XMLDocument, options?: GPXOptions): Polyline | Marker | FeatureGroup | null;
        private _parseName;
        private _parseTrkSeg;
        private _parseWpt;
        speedSplitEnable(options: SpeedSplitOptions): this;
        speedSplitDisable(): this;
        private _speedSplit;
    }
    type GraticuleZoomIntervalSettings = {
        start: number;
        end: number;
        interval: number;
    };
    type CardinalDirection = "N" | "S" | "E" | "W";
    type LatLngGraticuleOptions = LayerOptions & {
        /**
         * Show the grid tick label at the edges of the map.
         * @default true
         */
        showLabel?: boolean;
        /**
         * Opacity of the Graticule and Label.
         * @default 1
         */
        opacity?: number;
        /**
         * The width of the graticule lines.
         * @default 0.8
         */
        weight?: number;
        /**
         * The color of the graticule lines.
         * @default '#aaa'
         */
        color?: string;
        /**
         * Color of the tick label. When not set, inherits graticule line color.
         * Not set by default.
         */
        fontColor?: string | null;
        /**
         * Font Style for the tick label.
         * @default '12px Verdana'
         */
        font?: string;
        /**
         * Used to achieve dashed lines.
         * @default [0,0]
         */
        dashArray?: [
            number,
            number
        ];
        /**
         * Interval of polyline.
         * @default 0
         */
        lngLineCurved?: number;
        /**
         * Interval of polyline.
         * @default 0
         */
        latLineCurved?: number;
        /**
         * How far apart are graticule lines spaced at what zoom levels.
         * It is possible to set separate values for latitude and longitude.
         */
        zoomInterval?: GraticuleZoomIntervalSettings[] | {
            latitude: GraticuleZoomIntervalSettings[];
            longitude: GraticuleZoomIntervalSettings[];
        };
        /**
         * Used to name sides of the world.
         * @default `['N','S','E','W']`
         */
        sides?: CardinalDirection[];
        /**
         * @internal
         * Separate graticule interval for latitude.
         */
        latInterval?: GraticuleZoomIntervalSettings[] | null;
        /**
         * @internal
         * Separate graticule interval for longitude.
         */
        lngInterval?: GraticuleZoomIntervalSettings[] | null;
        /**
         * Optional function for formatting tick labels.
         */
        latFormatTickLabel?: ((lat: number) => string) | null;
        /**
         * Optional function for formatting tick labels.
         */
        lngFormatTickLabel?: ((lat: number) => string) | null;
    };
    /**
     * Create a Canvas as ImageOverlay to draw the Lat/Lon Graticule,
     * and show the axis tick label on the edge of the map.
     * Author: lanwei\@cloudybay.com.tw
     *
     * @group Layers
     */
    class LatLngGraticule extends Layer {
        static defaultOptions: Required<LatLngGraticuleOptions>;
        options: Required<LatLngGraticuleOptions>;
        private _canvas;
        private _currLngInterval;
        private _currLatInterval;
        private _currZoom;
        constructor(options?: LatLngGraticuleOptions);
        onAdd(map: LeafletGlMap): this;
        onRemove(map: LeafletGlMap): this;
        addTo(map: LeafletGlMap): this;
        setOpacity(opacity: number): this;
        bringToFront(): this;
        bringToBack(): this;
        protected _initCanvas(): void;
        protected _reset(): void;
        protected _onCanvasLoad(): void;
        protected _updateOpacity(): void;
        protected _formatLat(lat: number): string;
        protected _formatLng(lng: number): string;
        protected _calcInterval(): void;
        protected _draw(label: boolean): void;
        protected _drawLatLine(latTick: number, label: boolean, ctx: CanvasRenderingContext2D, txtHeight: number, lonLeft: number, lonRight: number, canvasWidth: number): void;
        protected _drawLonLine(lonTick: number, label: boolean, ctx: CanvasRenderingContext2D, txtHeight: number, latTop: number, latBottom: number, canvasHeight: number): void;
        protected _latLngToCanvasPoint(latlng: LatLngExpression): Point;
    }
    type ZoomControlOptions = ControlOptions & {
        /**
         * The text set on the 'zoom in' button. Can be HTML.
         */
        zoomInText?: string;
        /**
         * The title set on the 'zoom in' button.
         */
        zoomInTitle?: string;
        /**
         * The text set on the 'zoom out' button. Can be HTML.
         */
        zoomOutText?: string;
        /**
         * The title set on the 'zoom out' button.
         */
        zoomOutTitle?: string;
    };
    class ZoomControl extends Control {
        static defaultOptions: Required<ZoomControlOptions>;
        options: Required<ZoomControlOptions>;
        protected _disabled: boolean;
        protected _zoomInButton: HTMLAnchorElement;
        protected _zoomOutButton: HTMLAnchorElement;
        constructor(options?: ZoomControlOptions);
        protected onAdd(map: LeafletGlMap): HTMLElement;
        protected onRemove(map: LeafletGlMap): void;
        disable(): this;
        enable(): this;
        protected _zoomIn(e: any): void;
        protected _zoomOut(e: any): void;
        protected _createButton(html: any, title: any, className: any, container: any, fn: any): HTMLAnchorElement;
        protected _updateDisabled(): void;
    }
    /**
     * Creates a zoom control.
     *
     * @group Factory Functions
     */
    function zoom(options?: ZoomControlOptions): ZoomControl;
    /**
     * Returns the unique ID of an object, assigning it one if it doesn't have it.
     */
    function stamp(obj: object): number;
    function falseFn(): false;
    type LoadTileFunc$1<T> = (tile: Coords, abort: AbortSignal) => Promise<T | null>;
    type OnTileLoadedFunc<T> = (tile: Coords, data: T) => void;
    /**
     * A base class for rendering tiled 2D canvas content as a layer. See {@link CanvasLayer}.
     * Assumes that the content is tile-based, exposes a protected function {@link _drawTile} for rendering a single tile.
     *
     * @group Layers
     */
    abstract class CanvasTileLayer<TileDataType> extends CanvasLayer {
        protected _lastMovementTileUpdateTime: Date;
        protected _moving: boolean;
        protected _tileCache: TileCache<TileDataType>;
        constructor(options: CanvasLayerOptions, loadTile: LoadTileFunc$1<TileDataType>, tileLoaded?: OnTileLoadedFunc<TileDataType>);
        onAdd(map: LeafletGlMap): this;
        onRemove(map: LeafletGlMap): this;
        redraw(): this;
        protected _draw(tileZoom: number): void;
        /**
         * Override this method to draw a single tile. Canvas creation, clearing and scissoring is handled automatically.
         * @param ctx  - Canvas 2D context.
         * @param tileData  - Data for this tile. Never null.
         * @param targetZoom - Desired zoom level to be rendered. Not necessarily the zoom level of the tile. (We might use parent or child if the desired tile is not yet loaded.)
         * @param tileZ - The zoom level of the tile.
         * @param tileStartX - Where to start drawing the tile, in canvas pixels.
         * @param tileStartY - Where to start drawing the tile, in canvas pixels.
         * @param tileWidth - Tile width in canvas pixels.
         * @param tileHeight - Tile height in canvas pixels.
         */
        protected abstract _drawTile(ctx: CanvasRenderingContext2D, tileData: TileDataType, targetZoom: number, tileZ: number, tileStartX: number, tileStartY: number, tileWidth: number, tileHeight: number): void;
        private _drawTiles;
        private _onMove;
        private _moveStart;
        private _moveEnd;
    }
    /**
     * Returns true if `latlngs` is a flat array, false is nested.
     */
    function isLatLngArrayFlat(latlngs: LatLng[] | LatLng[][] | LatLng[][][]): latlngs is LatLng[];
    function isLatLngArrayFlat(latlngs: LatLngExpression[] | LatLngExpression[][] | LatLngExpression[][][]): latlngs is LatLngExpression[];
    function isLatLngArraySinglyNested(latlngs: LatLng[][] | LatLng[][][]): latlngs is LatLng[][];
    function isLatLngArraySinglyNested(latlngs: LatLngExpression[][] | LatLngExpression[][][]): latlngs is LatLngExpression[][];
    type Projection$1 = {
        /**
         * The bounds (specified in CRS units) where the projection is valid.
         */
        get bounds(): Bounds;
        /**
         * Projects geographical coordinates into a 2D point.
         * Only accepts actual `LatLng` instances, not arrays.
         */
        project(latlng: LatLng): Point;
        /**
         * The inverse of `project`. Projects a 2D point into a geographical location.
         * Only accepts actual `Point` instances, not arrays.
         */
        unproject(point: Point): LatLng;
    };
    class Transformation {
        private _a;
        private _b;
        private _c;
        private _d;
        /**
         * Creates a `Transformation` object with the given coefficients.
         */
        constructor(array: number[]);
        constructor(a: number, b: number, c: number, d: number);
        /**
         * Returns a transformed point, optionally multiplied by the given scale.
         * Only accepts actual `L.Point` instances, not arrays.
         */
        transform(point: Point, scale?: number): Point;
        /**
         * @internal
         * Destructive transform (faster).
         */
        _transform(point: Point, scale?: number): Point;
        /**
         * Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
         */
        untransform(point: Point, scale?: number): Point;
    }
    abstract class CRS {
        abstract projection: Projection$1;
        abstract transformation: Transformation;
        /**
         * Projects geographical coordinates into pixel coordinates for a given zoom.
         */
        latLngToPoint(latlng: LatLng, zoom: number): Point;
        /**
         * The inverse of `latLngToPoint`. Projects pixel coordinates on a given
         * zoom into geographical coordinates.
         */
        pointToLatLng(point: Point, zoom: number): LatLng;
        /**
         * Projects geographical coordinates into coordinates in units accepted for
         * this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
         */
        project(latlng: LatLng): Point;
        /**
         * Given a projected coordinate returns the corresponding LatLng.
         * The inverse of `project`.
         */
        unproject(point: Point): LatLng;
        /**
         * Returns the scale used when transforming projected coordinates into
         * pixel coordinates for a particular zoom. For example, it returns
         * `256 * 2^zoom` for Mercator-based CRS.
         */
        scale(zoom: number): number;
        /**
         * Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
         */
        zoom(scale: number): number;
        /**
         * Returns the projection's bounds scaled and transformed for the provided `zoom`.
         */
        getProjectedBounds(zoom: number): Bounds | null;
        /**
         * Returns the distance between two geographical coordinates.
         */
        abstract distance(latlng1: LatLng, latlng2: LatLng): number;
        /**
         * Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
         */
        abstract get code(): string;
        /**
         * An array of two numbers defining whether the longitude (horizontal) coordinate
         * axis wraps around a given range and how. Defaults to `[-180, 180]` in most
         * geographical CRSs. If `undefined`, the longitude axis does not wrap around.
         * @returns [min, max]
         */
        get wrapLng(): [
            number,
            number
        ] | undefined;
        /**
         * Like `wrapLng`, but for the latitude (vertical) axis.
         * @returns [min, max]
         */
        get wrapLat(): [
            number,
            number
        ] | undefined;
        /**
         * Returns a `LatLng` where lat and lng has been wrapped according to the
         * CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
         */
        wrapLatLng(latlng: LatLng): LatLng;
        /**
         * Returns a `LatLngBounds` with the same size as the given one, ensuring
         * that its center is within the CRS's bounds.
         * Only accepts actual `L.LatLngBounds` instances, not arrays.
         */
        wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds;
    }
    abstract class EarthClass extends CRS {
        get wrapLng(): [
            number,
            number
        ];
        /**
         * Mean Earth Radius, as recommended for use by
         * the International Union of Geodesy and Geophysics,
         * see https://rosettacode.org/wiki/Haversine_formula
         */
        readonly R: number;
        /**
         * Distance between two geographical points using spherical law of cosines approximation.
         */
        distance(latlng1: LatLng, latlng2: LatLng): number;
    }
    const Earth: EarthClass;
    function simplify(points: Point[], tolerance?: number): Point[];
    function pointToSegmentDistance(p: Point, p1: Point, p2: Point): number;
    function squaredDistanceOfClosestPointOnSegment(p: Point, p1: Point, p2: Point): number;
    function closestPointOnSegment(p: Point, p1: Point, p2: Point): Point;
    function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: boolean, round?: boolean): Point[] | false;
    function polylineCenter(latlngsRaw: LatLng[] | LatLng[][] | LatLng[][][], crs: CRS): LatLng;
    const LineUtil: {
        simplify: typeof simplify;
        pointToSegmentDistance: typeof pointToSegmentDistance;
        squaredDistanceOfClosestPointOnSegment: typeof squaredDistanceOfClosestPointOnSegment;
        closestPointOnSegment: typeof closestPointOnSegment;
        clipSegment: typeof clipSegment;
        polylineCenter: typeof polylineCenter;
    };
    /**
     * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
     * Inherits `Renderer`.
     *
     * @example
     *
     * Use SVG by default for all paths in the map:
     *
     * ```js
     * const map = map('map', {
     *     renderer: svg()
     * });
     * ```
     *
     * Use a SVG renderer with extra padding for specific vector geometries:
     *
     * ```js
     * var map = map('map');
     * var myRenderer = svg({ padding: 0.5 });
     * var line = polyline( coordinates, { renderer: myRenderer } );
     * var circle = circle( center, { renderer: myRenderer } );
     * ```
     */
    class SVGRenderer extends RendererBase {
        protected _svgSize?: Point;
        protected _rootGroup?: SVGGElement;
        protected _initContainer(): SVGSVGElement;
        protected _destroyContainer(): void;
        protected _resizeContainer(): Point;
        protected _update(): void;
        /**
         * @internal
         */
        _initPath(layer: Path): void;
        /**
         * @internal
         */
        _addPath(layer: Path): void;
        /**
         * @internal
         */
        _removePath(layer: Path): void;
        /**
         * @internal
         */
        _updatePath(layer: Path): void;
        /**
         * @internal
         */
        _updateStyle(layer: Path): void;
        /**
         * @internal
         */
        _updatePoly(layer: Polyline, closed?: boolean): void;
        /**
         * @internal
         */
        _updateCircle(layer: CircleMarker): void;
        private _setPath;
        /**
         * @internal
         */
        _bringToFront(layer: Path): void;
        /**
         * @internal
         */
        _bringToBack(layer: Path): void;
    }
    function svg(options?: RendererBaseOptions): SVGRenderer;
    class CanvasRenderer extends RendererBase {
        private _postponeUpdatePaths;
        private _ctx?;
        private _ctxScale;
        private _redrawBounds?;
        private _drawing;
        private _mouseHoverThrottled;
        private _hoveredLayer?;
        private _redrawRequest?;
        private _drawFirst?;
        private _drawLast?;
        private _layerInfos;
        _container: HTMLCanvasElement;
        /**
         * @internal
         */
        getEvents(): LeafletEventHandlerFnMap & {
            contentupdate?: LeafletEventHandlerFn | undefined;
            addpoint?: LeafletPointEventHandlerFn | undefined;
            addline?: LeafletLineEventHandlerFn | undefined;
            loaded?: LeafletEventHandlerFn | undefined;
            addlayer?: LayerEventHandlerFn | undefined;
            tileloaded?: TileCacheEventHandlerFn | undefined;
            beforetiledeleted?: TileCacheEventHandlerFn | undefined;
            alltilesloaded?: LeafletEventHandlerFn | undefined;
        } & {
            viewprereset: () => void;
        };
        private _onViewPreReset;
        onAdd(map: LeafletGlMap): this;
        protected _initContainer(): HTMLElement;
        protected _destroyContainer(): void;
        protected _resizeContainer(): Point;
        protected _updatePaths(): void;
        protected _update(): void;
        protected _reset(): void;
        /**
         * @internal
         */
        _initPath(layer: Path): void;
        /**
         * @internal
         */
        _addPath(layer: Path): void;
        /**
         * @internal
         */
        _removePath(layer: Path): void;
        /**
         * @internal
         */
        _updatePath(layer: Path): void;
        /**
         * @internal
         */
        _updateStyle(layer: Path): void;
        private _updateDashArray;
        private _requestRedraw;
        private _extendRedrawBounds;
        private _redraw;
        private _clear;
        private _draw;
        /**
         * @internal
         */
        _updatePoly(layer: Polyline, closed?: boolean): void;
        /**
         * @internal
         */
        _updateCircle(layer: Circle): void;
        private _fillStroke;
        private _onClick;
        private _onMouseMove;
        private _handleMouseOut;
        private _handleMouseHover;
        private _fireEvent;
        /**
         * @internal
         */
        _bringToFront(layer: Path): void;
        /**
         * @internal
         */
        _bringToBack(layer: Path): void;
    }
    /**
     * @deprecated
     * Creates a Canvas renderer with the given options.
     *
     * @group Factory Functions
     */
    function canvas(options?: RendererBaseOptions): CanvasRenderer;
    function isWebGL2(gl: WebGLRenderingContext | WebGL2RenderingContext): gl is WebGL2RenderingContext;
    type CacheAllocationToken<TValue> = {
        value: TValue;
        /**
         * A cached key that was used to retrieve this value.
         */
        _stringKey: string;
    };
    type GetStringKeyFunc<TKey> = (key: TKey) => string;
    type LoadFunc<TKey, TValue> = (key: TKey, abort: AbortSignal) => Promise<TValue>;
    type DeleteFunc<TValue> = (value: TValue) => void;
    /**
     * A cache that manages values with reference counting and asynchronous loading.
     *
     * Usage:
     * - Call {@link get} to get a value associated with a key. If the value is not cached, it will be loaded.
     * - The returned token must be passed to the {@link free} function when you are done with the value.
     * - Values are deleted from the cache and cleaned up when all tokens referencing them have been freed.
     *
     * Note: this class has a very specific use case, as caching of remote files is done by the browser
     * and automatic object disposal is done by GC.
     * Use this class when two or more consumers may want to use a resouce that requires notrivial processing to obtain.
     * Our specific use case is caching preprocessed tiles.
     *
     * @template TKey The type of the cache key.
     * @template TValue The type of the cached value.
     */
    class ReferenceCountedCache<TKey, TValue> {
        private _cache;
        private _currentlyLoading;
        private _waiting;
        private _disposed;
        private _timeoutInterval;
        private _getStringKey;
        private _load;
        private _delete?;
        private _deleteTimeoutSeconds;
        get deleteTimeoutSeconds(): number;
        /**
         * Sets the time (in seconds) for how long should no longer needed tiles be kept in memory
         * before being deleted. nonzero values prevent wasteful loading and deletion of tiles
         * when the user is moving the map erratically.
         *
         * When set, checks all unused tile timers and deletes any that have exceeded this time limit.
         */
        set deleteTimeoutSeconds(value: number);
        /**
         * Creates a new ReferenceCountedCache instance.
         *
         * @param getStringKeyFunc - Function that converts a key object to a string representation. This function must always return the **same string** for the **same contents** of the key object.
         * @param loadFunc - Asynchronous function to load or create a value for a given key. This function must not throw and must always complete in a reasonable time (use timeouts!).
         * @param deleteFunc - An optional function to clean up or delete a value when it is no longer referenced by any token.
         */
        constructor(getStringKeyFunc: GetStringKeyFunc<TKey>, loadFunc: LoadFunc<TKey, TValue>, deleteFunc?: DeleteFunc<TValue>);
        /**
         * Retrieves a value associated with the given key.
         * Either gets the value from the cache, or triggers loading of the value using the supplied load function,
         * or, if the value is already being loaded but not yet in the cache, waits for the value to load and then returns it.
         *
         * Optionally accepts an abort controller. The internal loading of a given tile is only aborted if all {@link get} calls awaiting it are aborted.
         *
         * @returns An allocation token that contains the retrieved value. Use this token to free the value using {@link free} once it is no longer needed.
         */
        get(key: TKey, abort?: AbortSignal): Promise<CacheAllocationToken<TValue>>;
        /**
         * Waits for a value for a given key to be loaded, but does not trigger the load itself.
         * Loading of the value must be started elsewhere by calling {@link get}.
         * Returned token must later be freed using {@link free}, same as with tokens returned from {@link get}.
         */
        awaitLoad(key: TKey, abort?: AbortSignal): Promise<CacheAllocationToken<TValue>>;
        /**
         * Frees the value token. Removes this reference from the value, deleting it completely if it is no longer referenced by any non-freed token.
         */
        free(token: CacheAllocationToken<TValue>): void;
        /**
         * Deletes all resources (intervals, cache contents) and aborts all load requests.
         */
        dispose(): void;
        private _deleteItem;
        private _checkTimeouts;
    }
    /**
     * Adds a custom load resource function that will be called when using a URL that starts with a custom url schema.
     * This will happen in the main thread, and workers might call it if they don't know how to handle the protocol.
     * The example below will be triggered for custom:// urls defined in the sources list in the style definitions.
     * The function passed will receive the request parameters and should return with the resulting resource,
     * for example a pbf vector tile, non-compressed, represented as ArrayBuffer.
     *
     * @param customProtocol - the protocol to hook, for example 'custom'
     * @param loadFn - the function to use when trying to fetch a tile specified by the customProtocol
     * @example
     * ```ts
     * // This will fetch a file using the fetch API (this is obviously a non interesting example...)
     * addProtocol('custom', async (params, abortController) => {
     *      const t = await fetch(`https://${params.url.split("://")[1]}`);
     *      if (t.status == 200) {
     *          const buffer = await t.arrayBuffer();
     *          return {data: buffer}
     *      } else {
     *          throw new Error(`Tile fetch error: ${t.statusText}`);
     *      }
     *  });
     * // the following is an example of a way to return an error when trying to load a tile
     * addProtocol('custom2', async (params, abortController) => {
     *      throw new Error('someErrorMessage'));
     * });
     * ```
     */
    function addProtocol(customProtocol: string, loadFn: AddProtocolAction): void;
    /**
     * Removes a previously added protocol in the main thread.
     *
     * @param customProtocol - the custom protocol to remove registration for
     * @example
     * ```ts
     * removeProtocol('custom');
     * ```
     */
    function removeProtocol(customProtocol: string): void;
    /**
     * Options for generating a tile mesh.
     * Can optionally configure any of the following:
     * - mesh subdivision granularity
     * - border presence
     * - special geometry for the north and/or south pole
     */
    type CreateTileMeshOptions = {
        /**
         * Specifies how much should the tile mesh be subdivided.
         * A value of 1 leads to a simple quad, a value of 4 will result in a grid of 4x4 quads.
         */
        granularity?: number;
        /**
         * When true, an additional ring of quads is generated along the border, always extending `EXTENT_STENCIL_BORDER` units away from the main mesh.
         */
        generateBorders?: boolean;
        /**
         * When true, additional geometry is generated along the north edge of the mesh, connecting it to the pole special vertex position.
         * This geometry replaces the mesh border along this edge, if one is present.
         */
        extendToNorthPole?: boolean;
        /**
         * When true, additional geometry is generated along the south edge of the mesh, connecting it to the pole special vertex position.
         * This geometry replaces the mesh border along this edge, if one is present.
         */
        extendToSouthPole?: boolean;
    };
    /**
     * Stores the prepared vertex and index buffer bytes for a mesh.
     */
    type TileMesh<T extends Uint16Array | Uint32Array> = {
        /**
         * The vertex data. Each vertex is two 16 bit signed integers, one for X, one for Y.
         */
        vertices: Int16Array;
        /**
         * The index data. Each triangle is defined by three indices. The indices may either be 16 bit or 32 bit unsigned integers,
         * depending on the mesh creation arguments and on whether the mesh can fit into 16 bit indices.
         */
        indices: T;
        /**
         * A helper boolean indicating whether the indices are 32 bit.
         */
        uses32bitIndices: T extends Uint32Array ? true : false;
    };
    /**
     * Describes desired type of vertex indices, either 16 bit uint, 32 bit uint, or, if undefined, any of the two options.
     */
    type IndicesType = "32bit" | "16bit" | undefined;
    /**
     * Creates a mesh of a quad that covers the entire tile (covering positions in range 0..EXTENT),
     * is optionally subdivided into finer quads, optionally includes a border
     * and optionally extends to the north and/or special pole vertices.
     * Additionally the resulting mesh indices type can be specified using `forceIndicesSize`.
     * @example
     * ```
     * // Creating a mesh for a tile that can be used for raster layers, hillshade, etc.
     * const meshBuffers = createTileMesh({
     *     granularity: map.style.projection.subdivisionGranularity.tile.getGranularityForZoomLevel(tileID.z),
     *     generateBorders: true,
     *     extendToNorthPole: tileID.y === 0,
     *     extendToSouthPole: tileID.y === (1 << tileID.z) - 1,
     * }, '16bit');
     * ```
     * @param options - Specify options for tile mesh creation such as granularity or border.
     * @param forceIndicesSize - Specifies what indices type to use. The values '32bit' and '16bit' force their respective indices size. If undefined, the mesh may use either size, and will pick 16 bit indices if possible. If '16bit' is specified and the mesh exceeds 65536 vertices, an exception is thrown.
     * @returns Typed arrays of the mesh vertices and indices.
     */
    function createTileMesh<T extends IndicesType>(options: CreateTileMeshOptions, forceIndicesSize?: T): T extends "32bit" ? TileMesh<Uint32Array> : T extends "16bit" ? TileMesh<Uint16Array> : TileMesh<Uint16Array | Uint32Array>;
    /**
     * Returns the package version of the library
     * @returns Package version of the library
     */
    function getVersion(): string;
    /**
     * Gets and sets the maximum number of images (raster tiles, sprites, icons) to load in parallel,
     * which affects performance in raster-heavy maps. 16 by default.
     *
     * @returns Number of parallel requests currently configured.
     * @example
     * ```ts
     * getMaxParallelImageRequests();
     * ```
     */
    function getMaxParallelImageRequests(): number;
    /**
     * Sets the maximum number of images (raster tiles, sprites, icons) to load in parallel,
     * which affects performance in raster-heavy maps. 16 by default.
     *
     * @example
     * ```ts
     * setMaxParallelImageRequests(10);
     * ```
     */
    function setMaxParallelImageRequests(numRequests: number): void;
    
    
    
    
}

/* eslint-enable */
